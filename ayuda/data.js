var contents = new Array("   Iris Cheng  Iris Cheng  1  0  2003-11-04T17:29:00Z  2003-11-04T17:29:00Z  1  167  952  Westar  7  2  1117  10.2625    Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rAce2_Filter      a spatial- an Adaptive Contrast  and  Enhance-     ment filter      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT  Ace2_Filter([in] long* image,[in] long wsize,[in]double alpha, [in] double  beta,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rSize      \n\r\n\rLong    mask size (3,5,7,9,...)      \n\r\n\rAlpha      \n\r\n\rDouble    local mean      \n\r\n\rBeta      \n\r\n\rDouble    Local gain factor      \n\r\n\rDescription      The ACE2 filter is a spatial-domain method for contrast  and     dynamic  range  modifications with less limitation on linear     contrast stretching. For more  detail,  see  &quot;Digital  image     enhancement  and noise filtering by use of local statistics&quot;     by J.S.Lee&nbsp;        ACE2_filter = K2 * m_l(r,c) + K1 * [I(r,c) - m_l(r,c)]&nbsp;     Where I(i,j) represents the pixel brightness  value  of  the     original  image  and m_l(r,c) is the arithmetic mean bright-     ness value of an (n x n) window  that  is  centered  on  the     pixel position (r,c).  The parameters &quot;K1&quot; = local gain fac-     tor and &quot;K2&quot; = local mean factor.&nbsp;&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Ace2_Filter","scr\\COM_HELP/Ace2_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:34:00Z  2004-06-04T00:34:00Z  1  135  776  SIUE  6  1  910  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rAcuity_Nightvision_Filter        \n\r\n\rvisual acuity and nightvision  simulations        \n\r\n\rFunction Prototype        \n\r\n\rAcuity_Nightvision_Filter([in] long* image,[in] long reason, [in] long threshold, [in] long  choice,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rreason      \n\r\n\rlong      \n\r\n\r1 = nightvision,  0 = acuity simulation        \n\r\n\rthreshold      \n\r\n\rlong      \n\r\n\rbinary threshold for nightvision  simulation        \n\r\n\rchoice      \n\r\n\rlong      \n\r\n\rvisual acuity value (20, 30, 40, ...)        \n\r\n\rDescription        \n\r\n\rPerforms visual acuity and nightvision goggles simulations. For visual acuity, set  &lt;reason&gt; to \'n\', set &lt;threshold&gt; to -1, and specify the desired  acuity &lt;choice&gt; as the numerator of a standard visual acuity rating,  such as \'50\' to simulate 20/50 vision.  \n\r\n\r For nightvision goggles simulation, set &lt;reason&gt; to  \'y\', select a threshold value (1-154), and set &lt;choice&gt; to -1.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Acuity_Nightvision_Filter","scr\\COM_HELP/Acuity_Nightvision_Filter.html","   ACADEMIC COMPUTING  Normal  P!Nk  16  14  2009-12-04T16:40:00Z  2009-12-04T17:03:00Z  2  123  705  SIUE  5  1  827  12.00    140  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                                   \n\r\n\rName      \n\r\n\rAD_Filter        \n\r\n\rPerforms anisotropic diffusion filter        \n\r\n\rFunction Prototype        \n\r\n\rAD_Filter([in] long* image, [in] long*  iteration_num, [in] long speed, [in] long edge_height, [out,retval] long*  Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\riteration_num      \n\r\n\rlong      \n\r\n\rmaximum number of complete iterations        \n\r\n\rspeed      \n\r\n\rlong      \n\r\n\rnumber of diffusion that is to be applied  at each iteration        \n\r\n\redge_height      \n\r\n\rlong      \n\r\n\rMinimum strength of edges that is to be  preserved by the filter                                \n\r\n\rDescription        \n\r\n\rThis function applies anisotropic diffusion  filter to &lt;image&gt;. It iteratively removes the noise from &lt;image&gt;  while preserving strong edges by stopping diffusion at them. The strength of  the edges that is to be preserved is specified by &lt;edge_height&gt;.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","AD_Filter","scr\\COM_HELP/ad_filter.html","   Iris Cheng  Iris Cheng  1  0  2003-11-04T17:27:00Z  2003-11-04T17:27:00Z  1  164  935  Westar  7  2  1097  10.2625    Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rAdapt_Median_Filter      a ranked-order based  adaptive  median filter      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT  Adapt_Median_Filter([in] long* image,[in] long mask_size,[out,retval] long*  Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rwmax      \n\r\n\rlong     Mask size      \n\r\n\rDescription      Ranked-order based adaptive median filter is used to  remove     positive and negative impulse noises in an image.      The Algorithm:      Xmed = median value in window      Xmin = minimum value in window      Xmax = maximum value in window      Xrc = current pixel value at (r,c)      (Level 1) T1 = Xmed - Xmin, T2 = Xmed - Xmax      (Level 2) U1 = Xrc - Xmin,  U2 = Xrc - Xmax      Level 1: If T1&gt;0&amp;T2&lt;0, goto Level 2               Else increase window size      Level 2: If U1&gt;0&amp;U2&lt;0, output = Xrc               Else output=Xmed&nbsp;     For more details see H. Hwang, R.A. Haddad, &quot;Adaptive Median     Filters: New Algorithms and Results&quot;, IEEE Trans. Image Pro-     cessing, Vol. 4, pp. 499-501, April 1995.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Adapt_Median_Filter","scr\\COM_HELP/Adapt_Median_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:33:00Z  2004-06-04T00:33:00Z  1  164  938  SIUE  7  2  1100  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rAdaptive_Contrast_Filter        \n\r\n\radaptive contrast filter        \n\r\n\rFunction Prototype        \n\r\n\rAdaptive_Contrast_Filter([in] long*  image,[in] double k1, [in] double k2,[in] long kernel_size,[in] double  min_gain, [in] double max_gain,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rk1      \n\r\n\rdouble      \n\r\n\rlocal gain factor multiplier (typically  between 0 and 1)        \n\r\n\rk2      \n\r\n\rdouble      \n\r\n\rlocal mean multiplier (between 0 and 1)        \n\r\n\rkernel_size      \n\r\n\rlong      \n\r\n\rsize of local window (an odd number)        \n\r\n\rmin_gain      \n\r\n\rdouble      \n\r\n\rthe minimum local gain factor        \n\r\n\rmax_gain      \n\r\n\rdouble      \n\r\n\rthe maximum local gain factor        \n\r\n\rDescription        \n\r\n\rThe adaptive contrast enhancement filter is  used to adjustthe contrast differently in different regions of the image.The  adaptive contrast filter is based on the following equation:  \n\r\n\r adaptive_contrast_filter = (k1* M{I(r,c)} *  (I(r,c) m_l(r,c)) + k2*m_l(r,c)) / sigma_l(r,c)  \n\r\n\r where M{I(r,c)} is the mean for the entire  image I(r,c), sigma_l is the local standard deviation, m_l is the local mean  and k1, k2 are constants between 0 and 1.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Adaptive_Contrast_Filter","scr\\COM_HELP/Adaptive_Contrast_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T22:57:00Z  2004-06-03T22:58:00Z  1  75  429  SIUE  3  1  503  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rAdd_Image        \n\r\n\radds two images        \n\r\n\rFunction Prototype        \n\r\n\rAdd_Image([in] long* input_im1,[in] long* input_im2, [out,retval]  long* result_im);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to newly allocated Image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im1      \n\r\n\rLong *      \n\r\n\rpointer to an Image structure        \n\r\n\rinput_im2      \n\r\n\rLong *      \n\r\n\rpointer to an Image structure        \n\r\n\rDescription        \n\r\n\rThis function uses the CVIP function \'add_Matrix\' to perform bitwise addition of the two  images. Complex matrices are supported.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Add_Image","scr\\COM_HELP/Add_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:34:00Z  2004-06-04T00:35:00Z  1  156  895  SIUE  7  2  1049  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rAlpha_Filter        \n\r\n\ralpha_filter used when an image  contains both short and long tailed types of noise such as Gaussian and salt  and pepper noises. Filter varies between a median and a mean filter.        \n\r\n\rFunction Prototype        \n\r\n\rAlpha_Filter([in] long* image,[in] long mask_size, [in]  long p,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to Image structure.        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rthe size of the filtering window (e.g., 3-&gt;3x3).        \n\r\n\rp      \n\r\n\rlong      \n\r\n\rnumber of maximum and minimum pixels to be excluded from the mean  calculation.        \n\r\n\rDescription        \n\r\n\rFilter is based on order statistics. The parameter  p determines how many of the endpoints are eliminated from the ordered data.  Returns the mean of the filter window after the endpoints have been removed.  Size of filter should be an odd integer limited from &lt; 3 31 &gt;, and size  of trim is limited from &lt;1-4&gt;.  \n\r\n\rWorks best on images that contain both  short and long tailed type noise. Keep filtering mask small to minimize  blurring.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Alpha_Filter","scr\\COM_HELP/Alpha_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T22:58:00Z  2004-06-03T22:59:00Z  1  71  406  SIUE  3  1  476  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rAnd_Image        \n\r\n\rperforms logical AND of two images        \n\r\n\rFunction Prototype        \n\r\n\rAnd_Image([in] long* input_im1,[in] long* input_im2, [out,retval]  long* result_im);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to newly allocated Image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im1      \n\r\n\rLong *      \n\r\n\rpointer to an Image structure        \n\r\n\rinput_im2      \n\r\n\rLong *      \n\r\n\rpointer to an Image structure        \n\r\n\rDescription        \n\r\n\rThis function performs a bitwise AND of two  images. Complex data is NOT supported.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","And_Image","scr\\COM_HELP/And_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:33:00Z  2004-06-03T23:33:00Z  1  90  515  SIUE  4  1  604  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rArea        \n\r\n\rcalculates area of an object of interest        \n\r\n\rFunction Prototype        \n\r\n\rArea([in] long* image,[in] int r, [in] int c, [out,retval] long* Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong *      \n\r\n\rA value of type long int:  area        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rPointer to the labeled image        \n\r\n\rr      \n\r\n\rint      \n\r\n\rrow coordinate of a point on the labeled  image        \n\r\n\rc      \n\r\n\rint      \n\r\n\rcolumn coordinate of a point on the labeled  image        \n\r\n\rDescription        \n\r\n\rThe program gets the sum of pixels whose  gray level values equal to a specific label. This label is the gray level  value of the point of coordinates &lt;r, c&gt; on the labeled image.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Area","scr\\COM_HELP/Area.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:34:00Z  2004-06-03T23:34:00Z  1  107  610  SIUE  5  1  716  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rAspect        \n\r\n\rcalculates aspect ratio of an object of  interest        \n\r\n\rFunction Prototype        \n\r\n\rAspect([in] long* image,[in] int r, [in] int c, [out,retval] long* Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong *      \n\r\n\rA value of type double: aspect ratio        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rPointer to the labeled image        \n\r\n\rr      \n\r\n\rint      \n\r\n\rrow coordinate of a point on the labeled  image        \n\r\n\rc      \n\r\n\rint      \n\r\n\rcolumn coordinate of a point on the labeled  image        \n\r\n\rDescription        \n\r\n\rThe program calculates aspect ratio of the  object of interest on the labeled image Aspect ration is equal to difference  between maximum column value and minimum column value of the object divided  by difference between maximum row value and minimum row value of the object.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Aspect","scr\\COM_HELP/Aspect.htm","   ACADEMIC COMPUTING  pat  3  1  2004-06-03T23:04:00Z  2010-09-17T21:49:00Z  1  82  471  SIUE  3  1  552  12.00    Clean  Clean  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                                   \n\r\n\rName      \n\r\n\rAssemble_Bands        \n\r\n\rAdd monochrome image planes to create a  multispectral image.        \n\r\n\rFunction Prototype        \n\r\n\rAssemble_Bands([in] long image[3], [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to newly allocated Image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong[3]      \n\r\n\rArray of image pointers        \n\r\n\rDescription        \n\r\n\rAdd monochrome image planes to create a  multispectral image. Supports COMPLEX data formats.  \n\r\n\rIf any color images are passed, only their  first color band is used. Returns NULL if error is encountered.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Assemble_Bands","scr\\COM_HELP/Assemble_Bands.html","   Mounika  Normal  jhansi  62  76  2003-11-04T17:29:00Z  2010-01-06T21:32:00Z  1  130  741  SIUE  6  1  870  11.9999    125  Clean  Clean    false  false  false                  MicrosoftInternetExplorer4             \n\r\n\rName      \n\r\n\rAuto_Threshold_Segment      a segmentation- automatic thresholding       \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Auto_Threshold_Segment([in] long* inputImage,float limit, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rlimit      \n\r\n\rfloat    difference between old and new threshold  \n\r\n\r&nbsp;     \n\r\n\rDescription        \n\r\n\r&nbsp;  \n\r\n\rAuto threshold is a method to find the threshold  automatically. This is an iterative process, easily implemented via computer  program. Auto threshold is also called as Isodata  or K-means algorithm.  \n\r\n\r                                                                        \n\r\n\r       \n\r\n\rMean1  is the pixels greater than Told   \n\r\n\rMean2  is the pixels less than Told  \n\r\n\r&nbsp;  \n\r\n\raverage of the two mean values:            Tnew = (m1 + m2) /2  \n\r\n\rTold  -Tnew &lt; limit then Tnew  is the threshold value otherwise  replace old threshold with new and find the mean values.  \n\r\n\r&nbsp;        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Auto_Threshold_Segment","scr\\COM_HELP/Auto_Threshold_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:37:00Z  2004-06-03T23:37:00Z  1  103  589  SIUE  4  1  691  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rBilinear_Interp        \n\r\n\rshrinks or enlarges an image        \n\r\n\rFunction Prototype        \n\r\n\rBilinear_Interp([in] long* image, [in] float factor,[out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult Image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the input image        \n\r\n\rfactor      \n\r\n\rfloat      \n\r\n\rfactor &gt; 1 to enlarge, factor &lt; 1 to  shrink        \n\r\n\rDescription        \n\r\n\rThis function shrinks or enlarges an image  using bilinear interpolation to calculate the gray-level value of new pixels.  This technique provides a smooth appearance, especially when enlarging an  image. The newly-created pixel values are linearly interpolated from formerly  adjacent pixels, thus producing even transitions.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Bilinear_Interp","scr\\COM_HELP/Bilinear_Interp.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:04:00Z  2004-06-04T00:05:00Z  1  90  519  SIUE  4  1  608  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rBintocvip        \n\r\n\rconvert binary file to CVIP file format        \n\r\n\rFunction Prototype        \n\r\n\rBintocvip([ in ] BSTR *File_Name, [in] long data_bands, [in] long color_order,  [in] long interleaved, [in] long height, [in] int  width, [in] long verbose, [out, retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR *      \n\r\n\rfile name of the image        \n\r\n\rdata_bands      \n\r\n\rlong      \n\r\n\rdata bands        \n\r\n\rcolor_order      \n\r\n\rlong      \n\r\n\rclor order        \n\r\n\rinterleaved      \n\r\n\rlong      \n\r\n\rinterleaved        \n\r\n\rheight      \n\r\n\rlong      \n\r\n\rheight        \n\r\n\rwidth      \n\r\n\rlong      \n\r\n\rwidth        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rverbose        \n\r\n\rDescription        \n\r\n\rconvert binary file to CVIP file format        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Bintocvip","scr\\COM_HELP/Bintocvip.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:09:00Z  2004-06-03T23:09:00Z  1  137  786  SIUE  6  1  922  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rBit_Compress        \n\r\n\rPerforms bit-plane runlength  coding        \n\r\n\rFunction Prototype        \n\r\n\rBit_Compress([ in ] BSTR *File_Name, [in] long* Input_image, [in]long sect);        \n\r\n\rReturn Value        \n\r\n\rNone      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rsect      \n\r\n\rlong      \n\r\n\rbitmask of planes to retain        \n\r\n\rDescription        \n\r\n\rbit_compress takes three  parameters, the input Image pointer, the filename to store the encoded data,  and the bits to retain. This algorithm decomposes the input image into eight  binary bitplanes each corressponding  to each bit position in an eight bit binary. Then each bitplane  is runlength coded separately and written into an  individual file name derived from the input filename. The user is advised not  to provide the extension for the filename because the program automaticaly appends suitable extension with numbers to  identify the bitplane files.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Bit_Compress","scr\\COM_HELP/Bit_Compress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:10:00Z  2004-06-03T23:10:00Z  1  164  936  SIUE  7  2  1098  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rBit_deCompress        \n\r\n\rPerforms bit-plane runlength  coding        \n\r\n\rFunction Prototype        \n\r\n\rBit_Decompress([ in ] BSTR *File_Name, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rreturned pointer to the uncompressed image  structure, a valid Image pointer on success, a NULL pointer on failure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rsect      \n\r\n\rlong      \n\r\n\rbitmask of planes to retain        \n\r\n\rDescription        \n\r\n\rbit_decompress takes a pointer to  the encoded data file name, and returns a pointer to the decompressed image.  Since there are eight files with the same name with different extension(each file corresponds to a bitplane),  the program automatically derives the extension and decodes each file sequentialy. So, the user is advised not to enter the  extension. Even the user enters a wrong extension the program takes care of  it by appending the proper extension. It generates seven images and returns  the pointer to the eigth image. Each image  corresponds to the one of the eight bitplane of the  originalimage.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Bit_decompress","scr\\COM_HELP/Bit_decompress.htm","   ACADEMIC COMPUTING  Normal  akharba  2  3  2004-11-03T03:09:00Z  2006-07-08T22:44:00Z  1  150  856  SIUE  7  2  1004  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4        \n\r\n\rName      \n\r\n\rBoiecox_Filter      performs a Boie Cox edge detection on the image      \n\r\n\rFunction Prototype        \n\r\n\rBoiecox_Filter([in] long* image,[in] double var,[in] long  do_threshold, [in] long do_hyst,  [in] long thin, [in] double high_threshold, [in] double  low_threshold, [out] long *imageThreshold,  [out] long *imageHyst, [out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an input Image structure      \n\r\n\rlow_threshold      \n\r\n\rdouble    Low threshold scale factor for the hysteresis threshold value estimated from the image      \n\r\n\rhigh_threshold      \n\r\n\rdouble    High threshold scale factor for the hysteresis threshold value estimated from the image      \n\r\n\rvar  \n\r\n\r&nbsp;  \n\r\n\rdo_threshold  \n\r\n\r&nbsp;  \n\r\n\rdo_hyst  \n\r\n\r&nbsp;  \n\r\n\r thin  \n\r\n\r&nbsp;  \n\r\n\rimageThreshold  \n\r\n\r&nbsp;  \n\r\n\rimageHyst      \n\r\n\rdouble  \n\r\n\r&nbsp;  \n\r\n\rlong       \n\r\n\r&nbsp;  \n\r\n\rlong  \n\r\n\r&nbsp;  \n\r\n\rlong  \n\r\n\r&nbsp;  \n\r\n\rlong*  \n\r\n\r&nbsp;  \n\r\n\rlong*    Variance… 0.5&lt;=var&lt;=5Threshold value&nbsp;Hysteresis thresholding&nbsp;Distance between final line pointsPointer to thresholded image structure&nbsp;Pointer to hysteresis image structure      \n\r\n\rDescription      &nbsp;&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.               \n\r\n\r&nbsp;","Boiecox_Filter","scr\\COM_HELP/Boiecox_Filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:10:00Z  2004-06-03T23:11:00Z  1  119  681  SIUE  5  1  799  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rBtc_Compress        \n\r\n\r2 level Block Truncation Coding (BTC)  scheme        \n\r\n\rFunction Prototype        \n\r\n\rBtc_Compress([in] BSTR *File_Name, [in] long* Input_image, [in]long blocksize);        \n\r\n\rReturn Value        \n\r\n\rNone      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rblocksize      \n\r\n\rlong      \n\r\n\rblocksize        \n\r\n\rDescription        \n\r\n\r The  image is first divided into blocks, and then the digital representation of  each pixel in a block is truncated to one bit by thresholding  and moment preserving selection of binary levels. The function code was  developed from Chapter 5 Section 6 &quot;Block Truncation Compression&quot;  (P176 P181) in &quot;Digital Picture Processing&quot; Volume1, second  edition, Azriel Rosenfeld and Avinash  C. KakYiyan. Academic Press, INC. San Diego, CA. 1982        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Btc_Compress","scr\\COM_HELP/Btc_Compress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:11:00Z  2004-06-03T23:11:00Z  1  128  736  SIUE  6  1  863  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rBtc_Decompression        \n\r\n\r2 level Block Truncation Coding (BTC)  scheme        \n\r\n\rFunction Prototype        \n\r\n\rBtc_Decompression([ in ] BSTR *File_Name, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rreturned pointer to the uncompressed image  structure, a valid Image pointer on success, a NULL pointer on failure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rDescription        \n\r\n\r The  image is first divided into blocks, and then the digital representation of  each pixel in a block is truncated to one bit by thresholding  and moment preserving selection of binary levels. The function code was  developed from Chapter 5 Section 6 &quot;Block Truncation Compression&quot;  (P176 P181) in &quot;Digital Picture Processing&quot; Volume1, second  edition, Azriel Rosenfeld and Avinash  C. KakYiyan. Academic Press, INC. San Diego, CA. 1982        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Btc_Decompression","scr\\COM_HELP/Btc_Decompression.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:12:00Z  2004-06-03T23:12:00Z  1  154  878  SIUE  7  2  1030  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rBtc2_Compress        \n\r\n\ra Block Truncation Coding (BTC) scheme  using multilevel coding        \n\r\n\rFunction Prototype        \n\r\n\rBtc2_Compress([in] BSTR *File_Name, [in] long* Input_image,  [in]long blocksize);        \n\r\n\rReturn Value        \n\r\n\rNone      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rblocksize      \n\r\n\rlong      \n\r\n\rblocksize        \n\r\n\rDescription        \n\r\n\rMultilevel BTC is a form of block truncation  coding that greatly improves the resulting image fidelity compared to the use  of the standard BTC, when applied to visually complex images. The improvement  comes from the use of a minmax error criterion in  place of the conventional two-level moment-preserving quantizer.  This approach to implementation uses block quantization map encoding and  decoding. The function code was developed from &quot;Multilevel Block  Truncation Coding Using a Minimax Error Criterion  for HighFidelity Compression of Digital Images.&quot;,  Yiyan Wu and David C. Coll,  IEEE TRANSACTIONS ON COMMUNICATIONS. VOL.41, NO.8, AUGUST 1993        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Btc2_Compress","scr\\COM_HELP/Btc2_Compress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:13:00Z  2004-06-03T23:13:00Z  1  163  934  SIUE  7  2  1095  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rBtc2_Decompression        \n\r\n\ra Block Truncation Coding (BTC) scheme  using multilevel coding        \n\r\n\rFunction Prototype        \n\r\n\rBtc2_Decompression([ in ] BSTR *File_Name, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rreturned pointer to the uncompressed image  structure, a valid Image pointer on success, a NULL pointer on failure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rDescription        \n\r\n\rMultilevel BTC is a form of block  truncation coding that greatly improves the resulting image fidelity compared  to the use of the standard BTC, when applied to visually complex images. The  improvement comes from the use of a minmax error  criterion in place of the conventional two-level moment-preserving quantizer. This approach to implementation uses block  quantization map encoding and decoding. The function code was developed from  &quot;Multilevel Block Truncation Coding Using a Minimax  Error Criterion for HighFidelity Compression of  Digital Images.&quot;, Yiyan Wu and David C. Coll, IEEE TRANSACTIONS ON COMMUNICATIONS. VOL.41, NO.8,  AUGUST 1993        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Btc2_Decompression","scr\\COM_HELP/Btc2_Decompression.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:14:00Z  2004-06-03T23:14:00Z  1  156  893  SIUE  7  2  1047  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rBtc3_Compress        \n\r\n\ra Block Truncation Coding (BTC) scheme  using predictive multilevel coding        \n\r\n\rFunction Prototype        \n\r\n\rBtc3_Compress([in] BSTR *File_Name, [in] long* Input_image,  [in]long blocksize);        \n\r\n\rReturn Value        \n\r\n\rNone      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rblocksize      \n\r\n\rlong      \n\r\n\rblocksize        \n\r\n\rDescription        \n\r\n\rPredictive multilevel BTC is another form  of block truncation coding (see btc2) that improves the resulting image  fidelity compared to the use of the standard BTC, when applied to visually  complex images. The improvement with the predictive method comes from the use  of interblock and intrablock  prediction and vector encoding/decoding, in place of the conventional  two-level moment-preserving quantizer. The function  code was developed from &quot;Multilevel Block Truncation Coding Using a Minimax Error Criterion for HighFidelity  Compression of Digital Images.&quot;, Yiyan Wu and  David C. Coll, IEEE TRANSACTIONS ON COMMUNICATIONS.  VOL.41, NO.8, AUGUST 1993        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Btc3_Compress","scr\\COM_HELP/Btc3_Compress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:14:00Z  2004-06-03T23:15:00Z  1  166  948  SIUE  7  2  1112  10.3501    Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rBtc3_Decompression        \n\r\n\ra Block Truncation Coding (BTC) scheme  using predictive multilevel coding        \n\r\n\rFunction Prototype        \n\r\n\rBtc3_Decompression([ in ] BSTR *File_Name,  [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rreturned pointer to the uncompressed image  structure, a valid Image pointer on success, a NULL pointer on failure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rDescription        \n\r\n\rPredictive multilevel BTC is another form  of block truncation coding (see btc2) that improves the resulting image  fidelity compared to the use of the standard BTC, when applied to visually  complex images. The improvement with the predictive method comes from the use  of interblock and intrablock prediction and vector encoding/decoding, in  place of the conventional two-level moment-preserving quantizer. The function  code was developed from &quot;Multilevel Block Truncation Coding Using a  Minimax Error Criterion for HighFidelity Compression of Digital  Images.&quot;, Yiyan Wu and David C. Coll, IEEE TRANSACTIONS ON  COMMUNICATIONS. VOL.41, NO.8, AUGUST 1993        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Btc3_Decompression","scr\\COM_HELP/Btc3_Decompression.html","   Iris Cheng  Iris Cheng  1  0  2003-11-04T17:11:00Z  2003-11-04T17:11:00Z  1  232  1326  Westar  11  3  1555  10.2625    Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rButterworth_Band_Pass      performs  Butterworth  band   pass     filtering      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT  Butterworth_Band_Pass([in] long* image,[in] long   block_size, [in] long      dc,  [in] long            inner, [in] long   outer, [in] long  order,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rblock_size      \n\r\n\rLong*    desired block size&nbsp;      \n\r\n\rDc      \n\r\n\rLong     drop(0) or retain(1) dc component&nbsp;      \n\r\n\rInner      \n\r\n\rLong     - inner cutoff frequency&nbsp;      \n\r\n\rOuter      \n\r\n\rLong     outer cutoff frequency&nbsp;      \n\r\n\rOrder      \n\r\n\rlong     filter order&nbsp;      \n\r\n\rDescription      This function performs two-dimensional Butterworth  bandpass     filtering  in  transform  domain  on input image. The filter     transfer function of order &lt;order&gt; is:             H(u,v) = -[ {1 / (1+ pow(k, 2*f_order))} -1]           where k = D(u,v)W/[pow(D(u,v), 2) - pow(D0, 2)]     D(u, v) is the distance from the origin, W the width of  the     band,  and  D0  is  the  center of the band. W is calculated     using the inner and outer cut-off frequencies specified. The     frequency  components  within the band enclosed by inner and     outer cut-off frequencies are not attenuated. All other fre-     quency  components outside the band are attenuated according     to the transfer function.  The band is a 1/4 of  a  circular     band if the dc component is on the upper left-hand corner of     its transform plane. If dc equals 1, the dc  component  will     be retained, if dc equals, the dc component will be dropped.&nbsp;&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Butterworth_Band_Pass","scr\\COM_HELP/Butterworth_Band_Pass.html","   Iris Cheng  Iris Cheng  1  0  2003-11-04T17:12:00Z  2003-11-04T17:12:00Z  1  232  1326  Westar  11  3  1555  10.2625    Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rButterworth_Band_Reject      performs Butterworth  band  reject     filtering  \n\r\n\r&nbsp;        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT  Butterworth_Band_Reject([in] long* image,[in] long            block_size, [in] long            dc,  [in] long      inner, [in] long   outer, [in] long  order,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rblock_size      \n\r\n\rLong*    desired block size&nbsp;      \n\r\n\rDc      \n\r\n\rLong     drop(0) or retain(1) dc component&nbsp;      \n\r\n\rInner      \n\r\n\rLong     - inner cutoff frequency&nbsp;      \n\r\n\rOuter      \n\r\n\rLong     outer cutoff frequency&nbsp;      \n\r\n\rOrder      \n\r\n\rlong     filter order&nbsp;      \n\r\n\rDescription      Butterworth_Band_Reject() performs two-dimensional  butter-     worth  bandreject  filtering  in  transform  domain on input     image. The filter transfer function of order &lt;order&gt; is:                  H(u,v) = 1 / (1+ pow(k, 2*order))         where k = D(u,v)W / [pow(D(u,v), 2) - pow(D0, 2)]     D(u, v) is the distance from the origin, W the width of  the     band,  and  D0  is  the  center of the band. W is calculated     using the inner and outer cut-off frequencies specified. The     frequency  components  within the band enclosed by inner and     outer cut-off frequencies are attenuated  according  to  the     transfer function.  All frequencies outside the band are not     attenuated.  The band is a 1/4 of a circular band if the  dc     component  is on the upper left-hand corner of its transform     plane. If dc equals 1, the dc component will be retained, if     dc equals, the dc component will be dropped.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Butterworth_Band_Reject","scr\\COM_HELP/Butterworth_Band_Reject.html","   Iris Cheng  Iris Cheng  2  2  2003-11-04T17:12:00Z  2003-11-04T17:37:00Z  1  205  1172  Westar  9  2  1375  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rButterworth_High        \n\r\n\rHRESULT Butterworth_High([in]  long* image,[in] long block_size, [in] long      dc,  [in] long cutoff, [in] long order,[out,retval] long* Result_Image);        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Raster_Deblur_Filter([in] long* image,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rblock_size      \n\r\n\rLong*    desired block size&nbsp;      \n\r\n\rDc      \n\r\n\rLong     drop(0) or retain(1) dc component&nbsp;      \n\r\n\rCutoff      \n\r\n\rLong     cutoff frequency      \n\r\n\rOrder      \n\r\n\rlong     filter order&nbsp;      \n\r\n\rDescription      Butterworth_High()  performs   two-dimensional   butterworth     highpass  filtering in transform domain on input image.  The     parameter cutoff defines  the  cut-off  frequency  locus  at     points  for  which the filter transfer function H(u,v) is at     0.7071 of its maximum value. All components inside the  cir-     cle (or 1/4 circle if dc component is on the upper-left-hand     corner of  its  transform  plane)  of  radius  &quot;cutoff&quot;  are     attenuated  according  to  the  transition  from passband to     stopband, depending on the degree of filter  order  f_order.     All  frequencies   component outside the circle (or 1/4 cir-     cle) are passed with no attenuation.   If dc equals  1,  the     dc   component  will  be  retained, if dc = 0, dc componenet     will be dropped.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Butterworth_High","scr\\COM_HELP/Butterworth_High.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:13:00Z  2003-11-04T17:38:00Z  1  195  1112  Westar  9  2  1305  10.2625    Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rButterworth_Low        \n\r\n\rperforms Butterworth lowpass filtering        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT  Butterworth_Low([in] long* image,[in] long block_size,  [in] long      dc, [in] long cutoff,  [in] long order,[out,retval] long*  Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rblock_size      \n\r\n\rLong*    desired block size&nbsp;      \n\r\n\rDc      \n\r\n\rLong     drop(0) or retain(1) dc component&nbsp;      \n\r\n\rCutoff      \n\r\n\rLong     cutoff frequency      \n\r\n\rOrder      \n\r\n\rlong     filter order&nbsp;      \n\r\n\rDescription      Butterworth_Low()  performs   two-dimensional   butterworth     lowpass  filtering  in transform domain on input image.  The     parameter cutoff defines  the  cut-off  frequency  locus  at     points  for  which the filter transfer function H(u,v) is at     0.7071 of its maximum value. All components inside  the  the     circle  (or 1/4 circle if dc component is on the upper-left-     hand corner of its transform plane) of radius  &quot;cutoff&quot;  are     passed  with  no  attenuation, while all frequencies outside     the circle (or 1/4 circle) are attenuated by the  transition     from  passband  to  stopband  which  depend on the degree of     filter order f_order. If dc equals 1, the dc component  will     be retained, if dc = 0, dc componenet will be dropped.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Butterworth_Low","scr\\COM_HELP/Butterworth_Low.html","   ACADEMIC COMPUTING  Normal  akharba  7  23  2004-07-05T20:18:00Z  2006-07-08T22:47:00Z  1  114  655  SIUE  5  1  768  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4        \n\r\n\rName      \n\r\n\rCanny_Filter      performs a Canny edge detection on the image      \n\r\n\rFunction Prototype        \n\r\n\rCanny_Filter([in]  long* image,[in] double low,[in]double high, [in] double var,[in]  long *nonmax_mag, [in] long *nonmax_dir, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an input Image structure      \n\r\n\rlow      \n\r\n\rdouble    Low threshold scale factor for the hysteresis threshold value estimated from the image      \n\r\n\rhigh      \n\r\n\rdouble    High threshold scale factor for the hysteresis threshold value estimated from the image      \n\r\n\rvar  \n\r\n\r&nbsp;  \n\r\n\rnonmax_mag  \n\r\n\r&nbsp;  \n\r\n\rnonmax_dir      \n\r\n\rdouble  \n\r\n\r&nbsp;  \n\r\n\rlong*       \n\r\n\r&nbsp;  \n\r\n\rlong*    Variance… 0.5&lt;=var&lt;=5Pointer to an immediate image structure&nbsp;Pointer to an immediate image structure&nbsp;      \n\r\n\rDescription      &nbsp;&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.               \n\r\n\r&nbsp;","Canny_Filter","scr\\COM_HELP/Canny_Filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:52:00Z  2004-06-03T23:52:00Z  1  48  276  SIUE  2  1  323  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCast_Image        \n\r\n\rcast image data type to specific type        \n\r\n\rFunction Prototype        \n\r\n\rCast_Image([in] long* image,[in] long dtype);        \n\r\n\rReturn Value        \n\r\n\rnone      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to a image        \n\r\n\rdtype      \n\r\n\rlong      \n\r\n\rThe image data type converted to        \n\r\n\rDescription        \n\r\n\rcast image data type to specific type        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Cast_Image","scr\\COM_HELP/Cast_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:15:00Z  2004-06-04T00:15:00Z  1  116  664  SIUE  5  1  779  10.3501    Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCentroID        \n\r\n\rcalculates centroid coordinates of an  object of interest        \n\r\n\rFunction Prototype        \n\r\n\rCentroID([in] long* input_im1, [in] long r,  [in] long c ,[out,retval] VARIANT *result_array);        \n\r\n\rReturn Value        \n\r\n\rresult_array      \n\r\n\rVARIANT      \n\r\n\rA pointer to int; first value is the row  coordinate, second is column coordinate.        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im1      \n\r\n\rlong *      \n\r\n\rPointer to the image        \n\r\n\rr      \n\r\n\rint      \n\r\n\rrow coordinate of a point on the labeled  image        \n\r\n\rc      \n\r\n\rint      \n\r\n\rcolumn coordinate of a point on the labeled  image        \n\r\n\rDescription        \n\r\n\rThe program calculates the centroid  coordinates of the object of interest on the labeled image according to  equations given in chapter 2 of the book:  \n\r\n\r Computer  Vision and Image Processing: A practical Approach Using CVIPtools  S.E.Umbaugh, Prentice Hall, 1997        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","CentroID","scr\\COM_HELP/CentroID.html","   Mounika  Normal  jhansi  41  52  2003-11-04T17:29:00Z  2010-01-06T21:32:00Z  1  110  631  SIUE  5  1  740  11.9999    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4             \n\r\n\rName      \n\r\n\rCerchar_Filter      a spatial- an multispectral image edge detecting filter      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Cerchar_Filter([in]  long* inputImage, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *    &nbsp; Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong *    pointer to an Image structure \n\r\n\r&nbsp;\n\r\n\r&nbsp;     \n\r\n\r&nbsp;Description        \n\r\n\rCervenka  and Charvat Filter is used  to find the edges in multispectral images. This can be applied to three band  color images, as well as multispectral satellite images.  \n\r\n\rThe result of this edge detector  at pixel (r,c) is  \n\r\n\r&nbsp;                                                                        \n\r\n\r       \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rIb(r,c) is the arithmetic average of all the pixels in all  bands at pixel location (r,c)&nbsp;&nbsp;   \n\r\n\r     &nbsp;is  the value at location (r,c) in the bth band, with a total of n bands  \n\r\n\r&nbsp;        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Cerchar_Filter","scr\\COM_HELP/cerchar_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T01:14:00Z  2004-06-04T01:14:00Z  1  38  223  SIUE  1  1  260  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCheck_Bin        \n\r\n\rcheck the bin        \n\r\n\rFunction Prototype        \n\r\n\rCheck_Bin([in] long* image,[out,retval] long* Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong*      \n\r\n\rThe return structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong*      \n\r\n\rThe input image        \n\r\n\rDescription        \n\r\n\rcheck the bin        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Check_Bin","scr\\COM_HELP/Check_Bin.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:44:00Z  2004-06-04T00:44:00Z  1  56  325  SIUE  2  1  380  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCheck_xform_history        \n\r\n\rCheck tranform result image history        \n\r\n\rFunction Prototype        \n\r\n\rCheck_xform_history([in] long* image,[in] int filter, [out,retval] long* Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong *      \n\r\n\rAddress of the history structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rInput image        \n\r\n\rfilter      \n\r\n\rint      \n\r\n\rType of the filter        \n\r\n\rDescription        \n\r\n\rheck tranform result image history        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","Check_xform_history","scr\\COM_HELP/Check_xform_history.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T01:11:00Z  2004-06-04T01:11:00Z  1  54  314  SIUE  2  1  367  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rClose_Consol        \n\r\n\rTo disable console redirection        \n\r\n\rFunction Prototype        \n\r\n\rClose_Consol()        \n\r\n\rReturn Value        \n\r\n\rN/A      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rN/A      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rDescription        \n\r\n\rConsole Redirection allow user to see the CVIPtools function standard  output information thru the memo box at the bottom of the GUI  \n\r\n\rTo disable console redirection (detail see Chen\'s thesis)        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Close_Consol","scr\\COM_HELP/Close_Consol.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T01:18:00Z  2004-06-04T01:18:00Z  1  31  177  SIUE  1  1  207  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rClose_Console        \n\r\n\rTo disable the console output        \n\r\n\rFunction Prototype        \n\r\n\rClose_Console()        \n\r\n\rReturn Value        \n\r\n\rN/A      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rN/A      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rDescription        \n\r\n\rTo disable the console output        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Close_Console","scr\\COM_HELP/Close_Console.html","   ACADEMIC COMPUTING  Normal  Mounika  28  114  2004-06-04T00:01:00Z  2010-04-30T15:50:00Z  1  258  1474  SIUE  12  3  1729  11.5606      false  false  false                  MicrosoftInternetExplorer4        \n\r\n\rName      \n\r\n\rColor_Contrast_Enhance        \n\r\n\rImproves the color of the image        \n\r\n\rFunction Prototype        \n\r\n\rColor_Contrast_Enhance([in]  LONG* inputImage, [in] LONG low_limit, [in] LONG high_limit, [in] FLOAT  low_clip, [in] FLOAT high_clip, [out,retval] LONG* outputImage);        \n\r\n\rReturn Value        \n\r\n\rOutput Image      \n\r\n\rlong *      \n\r\n\rOutput image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong *      \n\r\n\rpointer to an Image structure (data type  equal to or less precise than type CVIP_FLOAT)        \n\r\n\rlow_limit      \n\r\n\rint      \n\r\n\rlower limit for stretch        \n\r\n\rhigh_limit      \n\r\n\rint      \n\r\n\rhigh limit for stretch        \n\r\n\rlow_clip      \n\r\n\rfloat      \n\r\n\rpercentage of low values to clip before  stretching        \n\r\n\rhigh_clip      \n\r\n\rfloat      \n\r\n\rpercentage of high values to clip before  stretching        \n\r\n\rDescription        \n\r\n\rColor contrast enhance is an algorithm used  create brighter and better images. This takes color image as input. This  performs the HSL transform and performs different processes in step by step  process. First remap the image to CVIP_BYTE and then perform HSL transform,  next extract the hue band, saturation band and lightness band. Remap the  saturation band to CVIP_BYTE and then perform histogram equalization, which  improves and intensifies color richness. Cast the luminance band to  CVIP_FLOAT then perform a histogram stretch on the luminance band to improve  the contrast. After the histogram stretch, except luminance band the other  two bands are in BYTE format so cast the luminance to CVIP_FLOAT then combine  processed HSL bands and then apply inverse HSL transform.  \n\r\n\rThis function increases contrast in an  image by stretching the histogram to span the range low_limit to high_limit.  To improve performance of the function when outliers are present, percentages  low_clip and high_clip pixel values can be removed before the stretch takes  place.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Color_Contrast_Enhance","scr\\COM_HELP/Color_Contrast_Enhancement.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:01:00Z  2004-06-04T00:02:00Z  1  290  1659  SIUE  13  3  1946  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rColorXform        \n\r\n\rtransforms an RGB image into a new color  space        \n\r\n\rFunction Prototype        \n\r\n\rColorXform([in] long* image,[in]long newcspace,  [in]double *norm, [in]double*refwhite,[in] long  dir, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an Image structure (data type  equal to or less precise than type CVIP_FLOAT)        \n\r\n\rnewcspace      \n\r\n\rlong      \n\r\n\rdesired color space        \n\r\n\rnorm      \n\r\n\rdouble *      \n\r\n\rpointer to a normalization vector        \n\r\n\rrefwhite      \n\r\n\rdouble *      \n\r\n\rpointer to reference white values (for LUV  and LAB only)        \n\r\n\rdir      \n\r\n\rlong      \n\r\n\rdirection of transform (1 =&gt; (RGB-&gt;newcspace) else (newcspace-&gt;RGB)        \n\r\n\rDescription        \n\r\n\rTransforms an RGB image into a new color  space specified by &lt;newcspace&gt;, one of...  \n\r\n\r HSL  Hue/Saturation/Lightness,  \n\r\n\r HSV  Hue/Saturation/Value,  \n\r\n\r SCT  Spherical Coordinates Transform,  \n\r\n\r CCT  Cylindrical Coordinates Transform,  \n\r\n\r LAB  C.I.E. L*a*b* Color Coordinate System,  \n\r\n\r LUV  C.I.E. L*u*v* Color Coordinate System,  \n\r\n\r XYZ  Chromaticity Coordinate System.  \n\r\n\r Each  transform requires that the input image be normalized between 0 and 1. A  pointer to a normalization vector &lt;norm&gt; must be passed that contains a  set of values to normalize the image bands with. (e.g.  norm[0] = norm[1] = norm[2] = 255.0). If &lt;norm&gt; is NULL then it will be  assumed that the input image is already normalized. colorxform is capable of performing several inverse  transforms as well. If &lt;dir&gt; is passed as any other value except for  one then the inverse transform (&lt;newcspace&gt;-&gt;RGB)  will be performed. Currently the only inverse transforms that are supported  are HSL-&gt;RGB &amp; HSV-&gt;RGB. If either a L*a*b* or L*u*v* transform is  requested then an additional parameter &lt;refwhite&gt;  must be passed as well (e.g. refwhite[0] = refwhite[1] = refwhite[2] = 1.0 ). All transforms will also be  normalized to the range [0.0 ... 1.0] except for L*a*b* and L*u*v* whose  range will vary with different values of reference white.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","ColorXform","scr\\COM_HELP/ColorXform.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:57:00Z  2004-06-03T23:57:00Z  1  61  350  SIUE  2  1  410  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCondRemap_Image        \n\r\n\rcondition remap the image        \n\r\n\rFunction Prototype        \n\r\n\rCondRemap_Image([in] long* image,   long dtype,                   int min,             int max,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an image        \n\r\n\rdtype      \n\r\n\rlong      \n\r\n\rdata type        \n\r\n\rmin      \n\r\n\rint      \n\r\n\rminimum value        \n\r\n\rmax      \n\r\n\rint      \n\r\n\rmaximum value        \n\r\n\rDescription        \n\r\n\rcondition remap the image        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","CondRemap_Image","scr\\COM_HELP/CondRemap_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:35:00Z  2004-06-04T00:35:00Z  1  155  885  SIUE  7  2  1038  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rContra_Filter        \n\r\n\ra non-linear mean filter which is better at removing gaussian type noise and preserving edge features than the  mean filter.        \n\r\n\rFunction Prototype        \n\r\n\rContra_Filter([in] long* image,[in] long mask_size, [in]  long p,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to Image structure.        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rthe size of the filtering window (e.g., 3-&gt;3x3).        \n\r\n\rp      \n\r\n\rlong      \n\r\n\rfilter order        \n\r\n\rDescription        \n\r\n\rReturns the sum of the pixels in the filter  window raised to the power &quot;p+3&quot;, divided by the sum of the pixels  in the filter window raised to the power &quot;p&quot;. Size of filter should  be an odd integer limited from &lt; 3 31 &gt;, and order of filter is limited  from &lt;-5 to +5&gt;.  \n\r\n\rWorks well on images containing positive  outlier noise if the parameter P is negative, and on images containing  negative outlier noise if the parameter P is positive. P should remain small  (3-3) for better performance. Keep filter mask size small to reduce blurring.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","Contra_Filter","scr\\COM_HELP/Contra_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:38:00Z  2004-06-03T23:38:00Z  1  403  2303  SIUE  19  5  2701  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCopy_Paste        \n\r\n\rcopy a subimage  from one image and paste to the same or another image        \n\r\n\rFunction Prototype        \n\r\n\rCopy_Paste([in] long* src_image, [in] long* dest_image, [in] int start_r, [in] int start_c, [in] int height, [in] int width, [in] int dest_r, [in] int dest_c, [in] long  transparent,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult Image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rsrc_image      \n\r\n\rlong *      \n\r\n\rsource image to copy the subimage        \n\r\n\rdest_image      \n\r\n\rlong *      \n\r\n\rdestination image for pasting        \n\r\n\rstart_r      \n\r\n\rint      \n\r\n\rrow value of the upper-left corner of the subimage on srcImg        \n\r\n\rstart_c      \n\r\n\rint      \n\r\n\rcolumn value of the upper-left corner of  the subimage on srcImg        \n\r\n\rheight      \n\r\n\rint      \n\r\n\rheight of desired subimage        \n\r\n\rwidth      \n\r\n\rint      \n\r\n\rwidth of desired subimage        \n\r\n\rdest_r      \n\r\n\rint      \n\r\n\rrow value of the upper-left corner of the destImg area to paste the subimage        \n\r\n\rdest_c      \n\r\n\rint      \n\r\n\rcolumn value of the upper-left corner of  the destImg area to paste the subimage        \n\r\n\rtransparent      \n\r\n\rlong      \n\r\n\rwhether the paste is transparent or not        \n\r\n\rDescription        \n\r\n\rThe copy_paste(3) function copies a  subimage from the srcImg  and paste it to the destImg. copy_paste is designed for cross-image copy-paste,  but it also works for copy-paste within the same image, which is indicated by  making srcImg == destImg.  \n\r\n\r If  the subimage is too large, the size will be  adjusted automatically so the subimage can be  successfully copied from the srcImg and pasted to  the destImg. At the same time, an error message is  put to the standard error to warn the user of the event. crop_paste handles any CVIP_TYPE data types by  first boosting both images to CVIP_FLOAT; and remapping the resulting image  to the data type of the dest_Img.  \n\r\n\r When  a subimage is copy-pasted from a REAL image to a  COMPLEX image, the real data on srcImg is also used  as the imaginary data for pasting. When a subimage  is copy-pasted from a COMPLEX image to a REAL image, the imaginary components  are discarded.  \n\r\n\r When  copy-pasting from image of N bands to another image of M bands, band mapping  is done in the following way. For band band_no in  the destImg, band (band_no*N/M)  on the srcImg is used. For example, when copying  from single band image (N = 1) to a color image (M=3), the single band data  is used for all three bands in the resulting image (band_no  = 0, 1, 2). On the other hand, when copying from a three band image to a  single band image, only the red band is used.  \n\r\n\r For  a non-transparent pasting, the original data in the destImg  will be overwritten by the subimage from the srcImg. On the other hand, a transparent pasting will add  the data of the subimage to the existing destImg data. But other region of the destImg  might turn out to be relatively darker when transparent pasting is used.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Copy_Paste","scr\\COM_HELP/Copy_Paste.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:38:00Z  2004-06-03T23:39:00Z  1  66  379  SIUE  3  1  444  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCreate_Black        \n\r\n\rcreates a black PGM image        \n\r\n\rFunction Prototype        \n\r\n\rCreate_Black([in] int width, [in] int  height,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rwidth      \n\r\n\rint      \n\r\n\rWidth of the result image        \n\r\n\rheight      \n\r\n\rint      \n\r\n\rHeight of the result image        \n\r\n\rDescription        \n\r\n\rCreates a black PGM image of size height by  width. Used as a background image for certain geometric functions.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Create_Black","scr\\COM_HELP/Create_Black.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:39:00Z  2004-06-03T23:39:00Z  1  93  533  SIUE  4  1  625  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCreate_Checkboard        \n\r\n\rcreate checkerboard image (black and white)        \n\r\n\rFunction Prototype        \n\r\n\rCreate_Checkboard([in] int width, [in]int  height,[in]int firstx,[in]int firsty,[in]int blockx,[in]int  blocky,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rwidth      \n\r\n\rint      \n\r\n\rWidth of the result image        \n\r\n\rheight      \n\r\n\rint      \n\r\n\rHeight of the result image        \n\r\n\rfirstx      \n\r\n\rint      \n\r\n\rfirst column of checkerboard        \n\r\n\rfirsty      \n\r\n\rint      \n\r\n\rfirst row fo checkerboard        \n\r\n\rblockx      \n\r\n\rint      \n\r\n\rwidth of checkerboard blocks        \n\r\n\rblocky      \n\r\n\rint      \n\r\n\rheight of checkerboard blocks        \n\r\n\rDescription        \n\r\n\rcreate checkerboard image (black and white)        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Create_Checkboard","scr\\COM_HELP/Create_Checkboard.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:40:00Z  2004-06-03T23:40:00Z  1  77  440  SIUE  3  1  516  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCreate_Circle        \n\r\n\rcreate a circle image        \n\r\n\rFunction Prototype        \n\r\n\rCreate_Circle([in] int width, [in] int  height,[in]int centerx,[in]int centery,[in]int radius,[out,retval] long*  Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rwidth      \n\r\n\rint      \n\r\n\rWidth of the result image        \n\r\n\rheight      \n\r\n\rint      \n\r\n\rHeight of the result image        \n\r\n\rcenterx      \n\r\n\rint      \n\r\n\rcircle center column coordinate        \n\r\n\rcentery      \n\r\n\rint      \n\r\n\rcircle center rwo coordinate        \n\r\n\rradius      \n\r\n\rint      \n\r\n\rradius of circle        \n\r\n\rDescription        \n\r\n\rcreate a circle image        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Create_Circle","scr\\COM_HELP/Create_Circle.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:40:00Z  2004-06-03T23:41:00Z  1  68  388  SIUE  3  1  455  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCreate_Cosine        \n\r\n\rcreate cosine wave image        \n\r\n\rFunction Prototype        \n\r\n\rCreate_Cosine([in] int img_size,  [in] int frequency, [in] int  choice,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimg_size      \n\r\n\rint      \n\r\n\rnumber of rows (and columns) in new image        \n\r\n\rfrequency      \n\r\n\rint      \n\r\n\rsine wave frequency        \n\r\n\rchoice      \n\r\n\rint      \n\r\n\renter 1 for horizontal, 2 for vertical  cosine        \n\r\n\rDescription        \n\r\n\rcreate cosine wave image        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Create_Cosine","scr\\COM_HELP/Create_Cosine.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  5  2004-06-04T01:18:00Z  2004-10-12T23:30:00Z  1  95  547  SIUE  4  1  641  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCreate_Degenerate_Circle        \n\r\n\rTo create a degenerate circle (with a  linear blur)        \n\r\n\rFunction Prototype        \n\r\n\rCreate_Degenerate_Circle( [in] int width, [in] int  height, [in] int centerx,  [in]int centery, [in] int radius1,[in] int radius2, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong*      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rwidth      \n\r\n\rint      \n\r\n\rthe width of the image        \n\r\n\rheight      \n\r\n\rint      \n\r\n\rthe height of the image        \n\r\n\rcenterx      \n\r\n\rint      \n\r\n\rthe x coordinate (column) of the center        \n\r\n\rcentery      \n\r\n\rint      \n\r\n\rthe y coordinate (row) of the center        \n\r\n\rradius1      \n\r\n\rint      \n\r\n\rthe circle radius        \n\r\n\rradius2      \n\r\n\rint      \n\r\n\rthe blur radius        \n\r\n\rDescription        \n\r\n\rTo create a degenerate circle        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","Create_Degenerate_Circle","scr\\COM_HELP/Create_Degenerate_Circle.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T01:06:00Z  2004-06-04T01:07:00Z  1  85  487  SIUE  4  1  571  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCreate_Ellipse        \n\r\n\rCreate ellipse image        \n\r\n\rFunction Prototype        \n\r\n\rCreate_Ellipse([in] int width, [in] int  height,[in]int centerx,[in]int centery,[in]int hor_length,[in]int ver_length,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong*      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rwidth      \n\r\n\rint      \n\r\n\rThe width of the image        \n\r\n\rheight      \n\r\n\rint      \n\r\n\rThe height of the image        \n\r\n\rcenterx      \n\r\n\rint      \n\r\n\rThe x coordinate of the center        \n\r\n\rcentery      \n\r\n\rint      \n\r\n\rThe y coordinate of the center        \n\r\n\rhor_length      \n\r\n\rint      \n\r\n\rHorizontal length        \n\r\n\rver_length      \n\r\n\rint      \n\r\n\rVertical length        \n\r\n\rDescription        \n\r\n\rCreate ellipse image        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","Create_Ellipse","scr\\COM_HELP/Create_Ellipse.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  12  2004-07-13T19:41:00Z  2004-07-13T19:46:00Z  1  95  545  SIUE  4  1  639  10.3501    Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCreate_Line        \n\r\n\rcreates a line image        \n\r\n\rFunction Prototype        \n\r\n\rCreate_Line([in ] int width, [in] int  height, [in] int start_c, [in] int start_r, [in] int end_c, [in] int end_r,[out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rwidth      \n\r\n\rint      \n\r\n\rWidth of the resultant line image        \n\r\n\rheight      \n\r\n\rint      \n\r\n\rHeight of the resultant line image        \n\r\n\rstart_c      \n\r\n\rint      \n\r\n\rStarting (first) column coordinate of line        \n\r\n\rstart_r      \n\r\n\rint      \n\r\n\rStarting (first) row coordinate of line        \n\r\n\rend_c      \n\r\n\rint      \n\r\n\rEnding (last) column coordinate of line        \n\r\n\rend_r      \n\r\n\rint      \n\r\n\rEnding (last) row coordinate of line        \n\r\n\rDescription        \n\r\n\rcreates a line image        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Create_Line","scr\\COM_HELP/Create_Line.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:41:00Z  2004-06-03T23:41:00Z  1  85  488  SIUE  4  1  572  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCreate_Rectangle        \n\r\n\rcreate a rectangle image        \n\r\n\rFunction Prototype        \n\r\n\rCreate_Rectangle([in ] int width, [in] int  height, [in] int tlx, [in] int tly, [in] int sqwidth, [in] int  sqheight,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rwidth      \n\r\n\rint      \n\r\n\rWidth of the result image        \n\r\n\rheight      \n\r\n\rint      \n\r\n\rHeight of the result image        \n\r\n\rtlx      \n\r\n\rint      \n\r\n\rfirst column coordinate of line        \n\r\n\rtly      \n\r\n\rint      \n\r\n\rfirst row coordinate of line        \n\r\n\rsqwidth      \n\r\n\rint      \n\r\n\rwidth of rectangle        \n\r\n\rsqheight      \n\r\n\rint      \n\r\n\rrectangle height        \n\r\n\rDescription        \n\r\n\rcreate a rectangle image        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Create_Rectangle","scr\\COM_HELP/Create_Rectangle.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:41:00Z  2004-06-03T23:42:00Z  1  66  381  SIUE  3  1  446  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCreate_Sine        \n\r\n\rcreate sine wave image        \n\r\n\rFunction Prototype        \n\r\n\rCreate_Sine([in] int img_size,  [in] int frequency, [in] int  choice,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimg_size      \n\r\n\rint      \n\r\n\rnumber of rows (and columns) in new image        \n\r\n\rfrequency      \n\r\n\rint      \n\r\n\rsine wave frequency        \n\r\n\rchoice      \n\r\n\rint      \n\r\n\renter 1 for horizontal, 2 for vertical  cosine        \n\r\n\rDescription        \n\r\n\rcreate sine wave image        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Create_Sine","scr\\COM_HELP/Create_Sine.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:42:00Z  2004-06-03T23:42:00Z  1  81  466  SIUE  3  1  546  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCreate_Squarewave        \n\r\n\rcreate square wave        \n\r\n\rFunction Prototype        \n\r\n\rCreate_Squarewave([in] int img_size,  [in] int frequency, [in] int  choice,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimg_size      \n\r\n\rint      \n\r\n\rnumber of rows (and columns) in new image        \n\r\n\rfrequency      \n\r\n\rint      \n\r\n\rsine wave frequency        \n\r\n\rchoice      \n\r\n\rint      \n\r\n\renter 1 for horizontal, 2 for vertical  cosine        \n\r\n\rDescription        \n\r\n\rThis function creates a horizontal or vertical square wave image of  size img_sizeXimg_size, of frequency 1 to 256.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Create_Squarewave","scr\\COM_HELP/Create_Squarewave.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:43:00Z  2004-06-03T23:43:00Z  1  124  712  SIUE  5  1  835  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCrop        \n\r\n\rcrops a sub-image        \n\r\n\rFunction Prototype        \n\r\n\rCrop([in] long* image, [in] int row_offset,  [in] int col_offset, [in] int rows, [in] int cols,[out,retval] long*  Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an Image structure        \n\r\n\rrow_offset      \n\r\n\rint      \n\r\n\rrow coordinate of upper-left corner        \n\r\n\rcol_offset      \n\r\n\rint      \n\r\n\rcolumn coordinate of upper-left corner        \n\r\n\rrows      \n\r\n\rint      \n\r\n\rheight of desired subimage        \n\r\n\rcols      \n\r\n\rint      \n\r\n\rwidth of desired subimage        \n\r\n\rDescription        \n\r\n\rThis function allows the user to specify a  subimage to be cropped from an input image. The user specifies the row and column  coordinates of the upper-left corner of the desired area, along with the  subimage\'s width and height. The passed image is deleted. The function works  on all data types and supports complex images.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Crop","scr\\COM_HELP/Crop.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T01:17:00Z  2004-06-04T01:18:00Z  1  52  297  SIUE  2  1  348  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCVIP_OUTPUT        \n\r\n\rCheck the redirection pipe buffer and return the string in the buffer        \n\r\n\rFunction Prototype        \n\r\n\rSet_Console([in] long Handle);        \n\r\n\rReturn Value        \n\r\n\rsMessage      \n\r\n\rBSTR*      \n\r\n\rthe message string in the pipe buffer        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rN/A      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rDescription        \n\r\n\rCheck the redirection pipe buffer and return the string in the buffer        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","CVIP_OUTPUT","scr\\COM_HELP/CVIP_OUTPUT.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:30:00Z  2004-06-03T23:30:00Z  1  187  1066  SIUE  8  2  1251  10.3501    Clean  Clean                  MicrosoftInternetExplorer4    \n\r    \n\r\n\rName      \n\r\n\rCVIPhalftone        \n\r\n\rconverts a grayscale image to a binary  image        \n\r\n\rFunction Prototype        \n\r\n\rCVIPhalftone([in] long* image, [ in ] int halftone, [ in  ] int maxval, [ in ]  float fthreshval, [ in ] long retain_image,  [ in ] long verbose,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rreturned pointer to the uncompressed image  structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rhalftone      \n\r\n\rint      \n\r\n\rindicates method used to convert from grayscale to binary. (one of QT_FS,  QT_THRESH, QT_DITHER8, QT_CLUSTER3, QT_CLUSTER4, QT_CLUSTER8)        \n\r\n\rmaxval      \n\r\n\rint      \n\r\n\rspecifies maximum range of input image  (usually 255)        \n\r\n\rfthreshval      \n\r\n\rfloat      \n\r\n\rthreshold value (for QT_THRESH) between [0.0... 1.0].        \n\r\n\rretain_image      \n\r\n\rlong      \n\r\n\rretain image after writing (CVIP_YES or CVIP_NO)?        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rshall I be verbose (CVIP_YES or CVIP_NO)?        \n\r\n\rDescription        \n\r\n\rQuantizes a grayscale image to two levels  (a binary image). Possible methods of quantization are: (1) QT_FS -Floyd  Steinberg error diffusion, (2) QT_THRESH -simple thresholding,  (3) QT_DITHER8 Bayer\'s ordered dither and (4) QT_CLUSTER3, QT_CLUSTER4 and  QT_CLUSTER8 three different sizes of 45-degree clustered-dot dither.  Floyd-Steinberg will almost always give the best looking results.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","CVIPhalftone","scr\\COM_HELP/CVIPhalftone.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:05:00Z  2004-06-04T00:05:00Z  1  57  331  SIUE  2  1  387  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCviptoccc        \n\r\n\rconvert CVIP to ccc        \n\r\n\rFunction Prototype        \n\r\n\rCviptoccc([ in ] BSTR *File_Name, [in] long maxcolor,[in] long verbose, [in] long dermvis,[in]  long* cvip_Image);        \n\r\n\rReturn Value        \n\r\n\rnone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR *      \n\r\n\rFile name of the image        \n\r\n\rmaxcolor      \n\r\n\rlong      \n\r\n\rmax color        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rverbose        \n\r\n\rdermvis      \n\r\n\rlong      \n\r\n\rdermvis        \n\r\n\rDescription        \n\r\n\rconvert CVIP to ccc        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Cviptoccc","scr\\COM_HELP/Cviptoccc.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:05:00Z  2004-06-04T00:06:00Z  1  71  411  SIUE  3  1  481  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCviptoeps        \n\r\n\rconvert CVIP to EPS        \n\r\n\rFunction Prototype        \n\r\n\rCviptoeps([ in ] BSTR *File_Name,[in] long* cvip_Image, [in] double scale_x,  [in] double scale_y, [in] long band, [in] long  verbose);        \n\r\n\rReturn Value        \n\r\n\rnone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_name      \n\r\n\rBSTR *      \n\r\n\rfile name of the image        \n\r\n\rcvip_image      \n\r\n\rlong *      \n\r\n\rPointer to the image        \n\r\n\rscale_x      \n\r\n\rdouble      \n\r\n\rscale of x        \n\r\n\rscale_y      \n\r\n\rdouble      \n\r\n\rscale of y        \n\r\n\rband      \n\r\n\rlong      \n\r\n\rnumber of band        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rverbose        \n\r\n\rDescription        \n\r\n\rconvert CVIP to EPS        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Cviptoeps","scr\\COM_HELP/Cviptoeps.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:06:00Z  2004-06-04T00:06:00Z  1  59  338  SIUE  2  1  396  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCviptogif        \n\r\n\rconvert CVIP to GIF        \n\r\n\rFunction Prototype        \n\r\n\rCviptogif([in] BSTR *File_Name,[in] long* cvip_Image, [in] long interlace, [in] long verbose);        \n\r\n\rReturn Value        \n\r\n\rnone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR *      \n\r\n\rFile name of the image        \n\r\n\rcvip_image      \n\r\n\rlong *      \n\r\n\rPointer of the image        \n\r\n\rinterlace      \n\r\n\rlong      \n\r\n\rif do interlace        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rif verbose        \n\r\n\rDescription        \n\r\n\rconvert CVIP to GIF        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Cviptogif","scr\\COM_HELP/Cviptogif.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:07:00Z  2004-06-04T00:07:00Z  1  58  336  SIUE  2  1  393  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCviptoiris        \n\r\n\rConvert CVIP to IRIS        \n\r\n\rFunction Prototype        \n\r\n\rCviptoiris([ in ] BSTR *File_Name,[in] long* cvip_Image,[in] long verbose,[in] long prt_type);        \n\r\n\rReturn Value        \n\r\n\rNone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR *      \n\r\n\rfile name of the image        \n\r\n\rcvip_image      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rif verbose        \n\r\n\rprt_type      \n\r\n\rlong      \n\r\n\rprt type        \n\r\n\rDescription        \n\r\n\rConvert CVIP to IRIS        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Cviptoiris","scr\\COM_HELP/Cviptoiris.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T00:06:00Z  2004-06-04T01:24:00Z  1  SIUE  1  1  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 \n\r\n\r&nbsp;","Cviptoitex","scr\\COM_HELP/Cviptoitex.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:08:00Z  2004-06-04T00:08:00Z  1  88  502  SIUE  4  1  589  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCviptojpg        \n\r\n\rConvert CVIP to JPEG        \n\r\n\rFunction Prototype        \n\r\n\rCviptojpg([ in ] BSTR *File_Name, [in]  long* Input_image,[in ] int quality, [in] long grayscale, [in] long optimize,  [in] int smooth, [in] long verbose, [in]BSTR *qtablesFile);        \n\r\n\rReturn Value        \n\r\n\rNone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR *      \n\r\n\rfile name of the image        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rquality      \n\r\n\rint      \n\r\n\rquality        \n\r\n\rgrayscale      \n\r\n\rlong      \n\r\n\rif grayscale        \n\r\n\roptimize      \n\r\n\rlong      \n\r\n\rif optimize        \n\r\n\rsmooth      \n\r\n\rint      \n\r\n\rif smooth        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rif verbose        \n\r\n\rqtablesFile      \n\r\n\rBSTR *      \n\r\n\rquantization table        \n\r\n\rDescription        \n\r\n\rConvert CVIP to JPEG        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Cviptojpg","scr\\COM_HELP/Cviptojpg.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:08:00Z  2004-06-04T00:09:00Z  1  52  300  SIUE  2  1  351  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCviptopnm        \n\r\n\rConvert CVIP to PNM        \n\r\n\rFunction Prototype        \n\r\n\rCviptopnm([ in ] BSTR *File_Name,[in] long*  cvip_Image, [in] long verbose);        \n\r\n\rReturn Value        \n\r\n\rNone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR *      \n\r\n\rfile name of the image        \n\r\n\rcvip_image      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rif verbose        \n\r\n\rDescription        \n\r\n\rConvert CVIP to PNM        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Cviptopnm","scr\\COM_HELP/Cviptopnm.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:09:00Z  2004-06-04T00:09:00Z  1  58  335  SIUE  2  1  392  10.3501    Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCviptoras        \n\r\n\rConvert CVIP to RAS        \n\r\n\rFunction Prototype        \n\r\n\rCviptoras([ in ] BSTR *File_Name,[in] long*  cvip_Image, [in] long pr_type, [in] long verbose);        \n\r\n\rReturn Value        \n\r\n\rNone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR *      \n\r\n\rfile name of the image        \n\r\n\rcvip_image      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rif verbose        \n\r\n\rpr_type      \n\r\n\rlong      \n\r\n\rpr type        \n\r\n\rDescription        \n\r\n\rConvert CVIP to RAS        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Cviptoras","scr\\COM_HELP/Cviptoras.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:09:00Z  2004-06-04T00:10:00Z  1  88  503  SIUE  4  1  590  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCviptotiff        \n\r\n\rConvert CVIP to TIFF        \n\r\n\rFunction Prototype        \n\r\n\rCviptotiff([ in ] BSTR *File_Name,[in] long* cvip_Image, [in] long compression, [in] long fillorder, [in] long g3options, [in] long predictor, [in]  long rowsperstrip, [in] long verbose);        \n\r\n\rReturn Value        \n\r\n\rNone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR *      \n\r\n\rfile name of the image        \n\r\n\rcvip_image      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rcompression      \n\r\n\rlong      \n\r\n\rcompression        \n\r\n\rfillorder      \n\r\n\rlong      \n\r\n\rfill order        \n\r\n\rg3options      \n\r\n\rlong      \n\r\n\r&nbsp;        \n\r\n\rpredictor      \n\r\n\rlong      \n\r\n\r&nbsp;        \n\r\n\rrowsperstrip      \n\r\n\rlong      \n\r\n\rrows per strip        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rif verbose        \n\r\n\rDescription        \n\r\n\rConvert CVIP to TIFF        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Cviptotiff","scr\\COM_HELP/Cviptotiff.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:10:00Z  2004-06-04T00:10:00Z  1  72  415  SIUE  3  1  486  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rCviptovip        \n\r\n\rConvert CVIP to VIP        \n\r\n\rFunction Prototype        \n\r\n\rCviptovip([ in ] BSTR *File_Name,[in] long*  cvip_Image, [in] long verbose,[in] long save_history,[in] long  is_compressed);        \n\r\n\rReturn Value        \n\r\n\rNone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR *      \n\r\n\rfile name of the image        \n\r\n\rcvip_image      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rif verbose        \n\r\n\rsave_history      \n\r\n\rlong      \n\r\n\rif save the history        \n\r\n\ris_compressed      \n\r\n\rlong      \n\r\n\rif the image is compressed        \n\r\n\rDescription        \n\r\n\rConvert CVIP to VIP        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Cviptovip","scr\\COM_HELP/Cviptovip.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T01:04:00Z  2004-06-04T01:04:00Z  1  47  270  SIUE  2  1  316  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rDate_Range        \n\r\n\rGet the Date Range        \n\r\n\rFunction Prototype        \n\r\n\rDate_Range([in] long* input_im1, [out,retval] VARIANT *result_array);        \n\r\n\rReturn Value        \n\r\n\rresult_array      \n\r\n\rVARIANT *      \n\r\n\rThe return structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im1      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rDescription        \n\r\n\rGet the Date Range        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Data_Range","scr\\COM_HELP/Data_Range.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T17:05:00Z  2003-11-04T17:38:00Z  1  74  426  Westar  3  1  499  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rDct_Transform      perform dct transform      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Dct_Transform([in]  long* image,[in] long block_size,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rBlock_size      \n\r\n\rlong     block size      \n\r\n\rDescription      dct_transform transforms an image from the  spatial  to  the     frequency  domain  in  a  blockwise fashion using a discrete     cosine transform.&nbsp;           \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Dct_Transform","scr\\COM_HELP/Dct_Transform.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:52:00Z  2004-06-03T23:53:00Z  1  36  211  SIUE  1  1  246  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rDelete_Image        \n\r\n\rRelease a image structure        \n\r\n\rFunction Prototype        \n\r\n\rDelete_Image([in] long* image);        \n\r\n\rReturn Value        \n\r\n\rNone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an image        \n\r\n\rDescription        \n\r\n\rRelease a image structure        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Delete_Image","scr\\COM_HELP/Delete_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:00:00Z  2004-06-03T23:00:00Z  1  112  645  SIUE  5  1  756  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rDivide_Image        \n\r\n\rdivides two images        \n\r\n\rFunction Prototype        \n\r\n\rDivide_Image([in] long* input_im1, [in] long* input_im2, [in] long zero2num, [out,retval] long* result_im);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to newly allocated Image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im1      \n\r\n\rlong *      \n\r\n\rpointer to an Image structure        \n\r\n\rinput_im2      \n\r\n\rlong *      \n\r\n\rpointer to an Image structure        \n\r\n\rzero2num      \n\r\n\rlong      \n\r\n\rmethod of handling 0s in denominator        \n\r\n\rDescription        \n\r\n\rThis function performs bitwise division of  two images. Data type of each image is promoted to float, where needed.  Complex matrices are supported. If zero2num = CVIP_YES, the numerator data is  used in the resulting image in case the denominator is 0; otherwise, the  resulting image data is set to 0.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Divide_Image","scr\\COM_HELP/Divide_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:15:00Z  2004-06-03T23:16:00Z  1  216  1236  SIUE  10  2  1450  10.3501    Clean  Clean                  MicrosoftInternetExplorer4    \n\r    \n\r\n\rName      \n\r\n\rDpc_Compress        \n\r\n\rcompresses an image using differential  pulse code modulation        \n\r\n\rFunction Prototype        \n\r\n\rDpc_Compress([ in ] BSTR *File_Name, [in] long* Input_image, [in]float ratio,[in]int  bit_length, [in] int  clipping, [in]int direction, [in]int origin, [in]float deviation);        \n\r\n\rReturn Value        \n\r\n\rNone      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rration      \n\r\n\rfloat      \n\r\n\rthe correlation factor        \n\r\n\rbit_length      \n\r\n\rint      \n\r\n\rnumber of bits for compression (1 to 8)        \n\r\n\rclipping      \n\r\n\rint      \n\r\n\rclip to maximum value (1), otherwise 0        \n\r\n\rdirection      \n\r\n\rint      \n\r\n\rscan image horizontally (0) or vertically  (1)        \n\r\n\rorigin      \n\r\n\rint      \n\r\n\ruse original (1) or reconstructed (0)  values        \n\r\n\rdeviation      \n\r\n\rfloat      \n\r\n\r&nbsp;        \n\r\n\rDescription        \n\r\n\rDPCM is a compression technique that uses  the predictive method of differential pulse code modulation. It is based on the  observation that adjacent pixels are highly correlated within real images,  and it is wasteful to store repeated, large values to represent consecutive  pixels. Rather, DPCM  \n\r\n\rStores an initial value, followed by the  difference between the initial value and subsequent pixel values. For  example, a line of 10 white pixels (value = 255) would usually be represented  in 80 bits(8 bits/pixel X 10 pixels), whereas with  DPCM, only 17 bits are needed: the first pixel needs 8 bits, but each of the  other pixels only requires 1 bit, since the difference between the initial  value and the others is zero (255 255 = 0).   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Dpc_Compress","scr\\COM_HELP/Dpc_Compress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:16:00Z  2004-06-03T23:16:00Z  1  175  998  SIUE  8  2  1171  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rDpc_Decompress        \n\r\n\rcompresses an image using differential  pulse code modulation        \n\r\n\rFunction Prototype        \n\r\n\rDpc_Decompress([ in ] BSTR *File_Name, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rreturned pointer to the uncompressed image  structure, a valid Image pointer on success, a NULL pointer on failure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rDescription        \n\r\n\rDPCM is a compression technique that uses  the predictive method of differential pulse code modulation. It is based on  the observation that adjacent pixels are highly correlated within real  images, and it is wasteful to store repeated, large values to represent  consecutive pixels. Rather, DPCM  \n\r\n\rStores an initial value, followed by the  difference between the initial value and subsequent pixel values. For  example, a line of 10 white pixels (value = 255) would usually be represented  in 80 bits(8 bits/pixel X 10 pixels), whereas with  DPCM, only 17 bits are needed: the first pixel needs 8 bits, but each of the  other pixels only requires 1 bit, since the difference between the initial  value and the others is zero (255 255 = 0).        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Dpc_Decompress","scr\\COM_HELP/Dpc_Decompress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  2  1  2004-06-04T00:19:00Z  2004-06-04T00:19:00Z  1  38  222  SIUE  1  1  259  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rDraw_mesh        \n\r\n\rdraw the mesh        \n\r\n\rFunction Prototype        \n\r\n\rDraw_mesh([in] long* image,[in] long* pmesh);        \n\r\n\rReturn Value        \n\r\n\rNone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rPointer to the image        \n\r\n\rpmesh      \n\r\n\rlong *      \n\r\n\rmesh array        \n\r\n\rDescription        \n\r\n\rdraw the mesh        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Draw_mesh","scr\\COM_HELP/Draw_mesh.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:53:00Z  2004-06-03T23:53:00Z  1  43  248  SIUE  2  1  290  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rDuplicate_Image        \n\r\n\rDuplicate image        \n\r\n\rFunction Prototype        \n\r\n\rDuplicate_Image([in] long* image,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an image        \n\r\n\rDescription        \n\r\n\rDuplicate image        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","Duplicate_Image","scr\\COM_HELP/Duplicate_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:53:00Z  2004-06-04T00:54:00Z  1  69  398  SIUE  3  1  466  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rDynRLC_Compression        \n\r\n\rDynamic RLC compression        \n\r\n\rFunction Prototype        \n\r\n\rDynRLC_Compression([in] BSTR* File_Name, [in] long *inputImage, [in] long WindowSize,  [out, retval] long * result);        \n\r\n\rReturn Value        \n\r\n\rresult      \n\r\n\rlong *      \n\r\n\rif success return 1 otherwise 0        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR*      \n\r\n\rthe compressed file name        \n\r\n\rinputImage      \n\r\n\rlong*      \n\r\n\rPointer to the input image        \n\r\n\rWindowSize      \n\r\n\rlong      \n\r\n\rRun Length Coding Window Size        \n\r\n\rDescription        \n\r\n\rDynamic RLC compression        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","DynRLC_Compression","scr\\COM_HELP/DynRLC_Compression.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:54:00Z  2004-06-04T00:54:00Z  1  50  286  SIUE  2  1  335  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rDynRLC_deCompression        \n\r\n\rDynamic RLC decompression        \n\r\n\rFunction Prototype        \n\r\n\rDynRLC_deCompression([in] BSTR* File_Name, [out, retval] long *Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR*      \n\r\n\rthe compressed file name        \n\r\n\rDescription        \n\r\n\rDynamic RLC decompression        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","DynRLC_deCompression","scr\\COM_HELP/DynRLC_deCompression.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:36:00Z  2004-06-04T00:36:00Z  1  332  1895  SIUE  15  4  2223  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rEdge_Detect_Filter        \n\r\n\rperform edge detection        \n\r\n\rFunction Prototype        \n\r\n\rEdge_Detect_Filter([in] long* image, [in] long program, [in] long mask_choice,  [in] long mask_size, [in] long keep_dc,  [in] long threshold,[in] long threshold1, [in] long thresh,[in] long thr,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rprogram      \n\r\n\rlong      \n\r\n\rdesired edge detector        \n\r\n\rmask_choice      \n\r\n\rlong      \n\r\n\rtype of smoothing filter        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rLaplacian mask (1 or 2)        \n\r\n\rkeep_dc      \n\r\n\rlong      \n\r\n\r0 (no) or 1 (yes)        \n\r\n\rthreshold      \n\r\n\rlong      \n\r\n\rvalue for binary threshold        \n\r\n\rthreshold1      \n\r\n\rlong      \n\r\n\rFrei-Chen projection method        \n\r\n\rthresh      \n\r\n\rlong      \n\r\n\rFrei-Chen projection threshold        \n\r\n\rthr      \n\r\n\rlong      \n\r\n\rangle (in radians) for Frei-Chen  edge or line projection threshold        \n\r\n\rDescription        \n\r\n\rThis function applies various edge  detection algorithms to &lt;imageP&gt;. The  difference between this function and edge_detect_setup  is that this function gets all the required input from the parameters,  instead from the standard input. Edge detectors available for &lt;program&gt;  are:  \n\r\n\r EDGE_KIRSCH  \n\r\n\r EDGE_ROBINSON  \n\r\n\r EDGE_PYRAMID  \n\r\n\r EDGE_LAPLACIAN  \n\r\n\r EDGE_SOBEL  \n\r\n\r EDGE_ROBERTS  \n\r\n\r EDGE_PREWITT  \n\r\n\r EDGE_FREI  \n\r\n\r If a  smoothing filter is desired as a preprocessing step, set &lt;mask_choice&gt; to:  \n\r\n\r 1 =  Gaussian blur  \n\r\n\r 2 =  generic lowpass 1  \n\r\n\r 3 =  generic lowpass 2  \n\r\n\r 4 =  neighborhood average  \n\r\n\r For  &lt;mask_size&gt;: If you select EDGE_LAPLACIAN,  set &lt;mask_size&gt;:  \n\r\n\r 1 =  [0,-1,0; -1,4,-1; 0,-1,0]  \n\r\n\r 2 =  [1,-2,1; -2,4,-2; 1,-2,1]  \n\r\n\r If  you select EDGE_SOBEL, set &lt;mask_size&gt;:  kernel size (3,5,or 7)  \n\r\n\r If  you select EDGE_ROBERTS, set &lt;mask_size&gt;:  \n\r\n\r 1 =  G[f(x,y)]=[f(x,y)-f(x+1,y)]^2+[f(x,y)-f(x,y+1)]^2}^1/2)  \n\r\n\r 2 =  G[f(x,y)]=|f(x,y)-f(x+1,y+1)|+|f(x+1,y)-f(x,y+1)|  \n\r\n\r If  you select EDGE_PREWITT, set &lt;mask_size&gt; to  desired kernel size  \n\r\n\r If  you select EDGE_FREI, you need to set the following: &lt;threshold1&gt; :  \n\r\n\r 1 =  Project onto edge subspace  \n\r\n\r 2 =  Project onto line subspace  \n\r\n\r 3 =  Show complete projection  \n\r\n\r &lt;thresh&gt; :  \n\r\n\r 1 =  Set threshold on edge projection  \n\r\n\r 2 =  Set threshold on line projection  \n\r\n\r 3 =  Smallest angle between the above  \n\r\n\r&nbsp;  \n\r\n\r If  &lt;thresh&gt; = 1 or 2, set &lt;thr&gt; =  threshold angle (radians)  \n\r\n\r NOTE: FOR ALL OF THE ABOVE PARAMETERS, USE  THE VALUE -1 FOR ANY PARAMETER NOT NEEDED.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","Edge_Detect_Filter","scr\\COM_HELP/Edge_Detect_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:36:00Z  2004-06-04T00:36:00Z  1  68  392  SIUE  3  1  459  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rEdge_Link_Filter        \n\r\n\rconnects pixels to form lines        \n\r\n\rFunction Prototype        \n\r\n\rEdge_Link_Filter([in] long* image,[in] long  connection,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an binary Image        \n\r\n\rconnection      \n\r\n\rlong      \n\r\n\rmaximum connect distance        \n\r\n\rDescription        \n\r\n\rThis function links pixels in a binary  image that are separated by no more than &lt;connection&gt; pixels.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Edge_Link_Filter","scr\\COM_HELP/Edge_Link_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:43:00Z  2004-06-03T23:43:00Z  1  123  704  SIUE  5  1  826  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rEnlarge        \n\r\n\rEnlarges an image to a user-defined size        \n\r\n\rFunction Prototype        \n\r\n\rEnlarge([in] long* image, [in] int row, [in] int col,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an Image structure        \n\r\n\rrow      \n\r\n\rint      \n\r\n\rnumber of rows for enlarged image        \n\r\n\rcol      \n\r\n\rint      \n\r\n\rnumber of columns for enlarged image        \n\r\n\rDescription        \n\r\n\rEnlarge allows the user to specify the number  of rows and columns in the resultant image, corresponding to the height and  width of the new image. The integers specified for row and column sizes must  be equal to or greater than the input image sizes or an error results.  \n\r\n\r Because the user may enter different values  for height and width, enlarge may be used to geometrically distort the image  in a rubber-sheet fashion.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Enlarge","scr\\COM_HELP/Enlarge.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:10:00Z  2004-06-04T00:11:00Z  1  42  241  SIUE  2  1  282  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rEpstocvip        \n\r\n\rConvert EPS to CVIP        \n\r\n\rFunction Prototype        \n\r\n\rEpstocvip([ in ] BSTR *File_Name,[in] long verbose);        \n\r\n\rReturn Value        \n\r\n\rNone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR *      \n\r\n\rfile name of the image        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rif verbose        \n\r\n\rDescription        \n\r\n\rConvert EPS to CVIP        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Epstocvip","scr\\COM_HELP/Epstocvip.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T17:30:00Z  2003-11-04T17:39:00Z  1  98  559  Westar  4  1  656  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rEuler      calculates the euler number      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT  Euler([in] long* image,[in] long row, [in] long col,  [out,retval] long *Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rR      \n\r\n\rLong    row coordinate of a point on the labeled image      \n\r\n\rC      \n\r\n\rLong    column coordinate of a point on the labeled image      \n\r\n\rDescription      This function calculates the euler number of  na  object  of     interest  on  a  labeled image. The Euler number is equal to     the number of upstream-facing convexities minus  the  number     of upstream-facing concavities.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Euler","scr\\COM_HELP/Euler.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T17:29:00Z  2003-11-04T17:39:00Z  1  145  833  Westar  6  1  977  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rExp_Ace_Filter      a  method  to  enhance  the  contrast  and     dynamic range of the image      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Exp_Ace_Filter([in] long* image,[in] long wsize,[in]double alpha, [in] double beta,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rSize      \n\r\n\rLong    mask size (3,5,7,9,...)      \n\r\n\rAlpha      \n\r\n\rDouble    local mean      \n\r\n\rBeta      \n\r\n\rDouble    Local gain factor      \n\r\n\rDescription      exp_ACE\'s algorithms are able to enhance  the  contrast  and     dynamic  range of the image. exp_ACE\'s algorithm uses linear     brightness stretching to modify  the  dynamic  range  of  an     image.&nbsp;      output =  M*[I(r,c)/M]**k1 + [m_l(r,c)/I(r,c)]**k2&nbsp;      where M =  the number of gray levels (255)            m_l = the local mean            k1 = Local gain factor (exponent)            k2 = Local mean factor (exponent)            kernel size = size of local window&nbsp;&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Exp_Ace_Filter","scr\\COM_HELP/Exp_Ace_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:05:00Z  2004-06-03T23:05:00Z  1  85  486  SIUE  4  1  570  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rExtract_Band        \n\r\n\rloads an Image structure with data from the  specified image file        \n\r\n\rFunction Prototype        \n\r\n\rExtract_Band([in] long* image,[in] int bandno, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to newly allocated Image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rbandno      \n\r\n\rint      \n\r\n\rband number to be extracted from the image.        \n\r\n\rDescription        \n\r\n\rDescription: Create a monochrome image from  a color image by extracting a color plane. Supports COMPLEX data formats.  Returns NULL if error is encountered.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Extract_Band","scr\\COM_HELP/Extract_Band.html","   Jhansi  jhansi  5  2  2003-11-04T17:08:00Z  2010-01-06T21:28:00Z  1  90  513  SIUE  4  1  602  11.9999    120  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                                  \n\r\n\rName      \n\r\n\rFft_Mag      extract magnitude of fft      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Fft_Mag([in] long*  image,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\r&nbsp;      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rDescription      This function performs two types of  operations:   normalize     phase by setting                      REAL = magnitude                      IMAG = 0     where magnitude is a constant, and remaps  the  magnitude  data  into  a     CVIP_BYTE image:                      magnitude = sqrt( REAL^2 + IMAG^2)&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Fft_Mag","scr\\COM_HELP/FFT_Mag.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:08:00Z  2003-11-04T17:39:00Z  1  160  913  Westar  7  2  1071  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rFft_Phase      extract phase of fft      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Fft_Phase([in] long* image,[in] long remap_norm,  [in] double k,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rremap_norm      \n\r\n\rLong    0 = remaps the phase data and returns                         a CVIP_BYTE image                     1 = normalizes the magnitude, using value                         of k, returns a complex image      \n\r\n\rK      \n\r\n\rDouble    constant to normalize the magnitude      \n\r\n\rDescription      This function performs two types of  operations:   normalize     magnitude by setting                      REAL = k*cos(phase_angle)                      IMAG = k*sin(phase_angle)     where k is a constant, and remaps  the  phase  data  into  a     CVIP_BYTE image:                      phase = arctan(IMAG/REAL)&nbsp;     Phase data are values between 0 -- 2*PI, values between PI/4     --  5*PI/4  are remapped to 255 -- 0; values between -3*PI/4     -- PI/4 are remapped to 0 -- 255.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Fft_Phase","scr\\COM_HELP/Fft_Phase.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:39:00Z  2003-11-04T17:39:00Z  1  79  455  Westar  3  1  533  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rFft_Transform      perform fast Fourier transform      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Fft_Transform([in] long* image,[in] long block_size,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *     Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rBlock_size      \n\r\n\rlong     block size      \n\r\n\rDescription      This function performs  a  Fast  forward  Fourier  Transform     (FFT)  on  an  image.Block  sizes  in power of two should be     specified,otherwise segmentation fault will occur.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Fft_Transform","scr\\COM_HELP/Fft_Transform.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:28:00Z  2003-11-04T17:39:00Z  1  47  269  Westar  2  1  315  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rFile_To_Mesh        \n\r\n\rRead  mesh from  file        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT File_To_Mesh([ in ] BSTR *File_Name,  [out, retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rFile_Name      \n\r\n\rBSTR*    Mesh file name      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rDescription      Read mesh from file      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","File_To_Mesh","scr\\COM_HELP/File_To_Mesh.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:55:00Z  2004-06-04T00:55:00Z  1  131  751  SIUE  6  1  881  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rFractal_Compression        \n\r\n\rFractal compression function        \n\r\n\rFunction Prototype        \n\r\n\rFractal_Compression([in] long *inputImage, [in] BSTR *File_Name,  [in]  double Tolerate, [in] long min_part, [in] long max_part, [in] long dom_type,  [in] long dom_step, [in] long c1, [in] long c2,  [in] long s_bits, [in] long o_bits,  [out, retval] long * result);        \n\r\n\rReturn Value        \n\r\n\rresult      \n\r\n\rlong *      \n\r\n\rthe return value        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong*      \n\r\n\rThe Pointer to the input image        \n\r\n\rFile_Name      \n\r\n\rBSTR*      \n\r\n\rthe compressed file name        \n\r\n\rTolerate      \n\r\n\rdouble      \n\r\n\rtolerance value        \n\r\n\rmin_part      \n\r\n\rlong      \n\r\n\r     recursion size min        \n\r\n\rmax_part      \n\r\n\rlong      \n\r\n\r     recursion size max        \n\r\n\rdom_type      \n\r\n\rlong      \n\r\n\r     domain type        \n\r\n\rdom_step      \n\r\n\rlong      \n\r\n\r     domain step        \n\r\n\rc1      \n\r\n\rlong      \n\r\n\r(y/n) for searching 24 domain classes        \n\r\n\rc2      \n\r\n\rlong      \n\r\n\r(y/n) for searching 3 domain classes        \n\r\n\rs_bit1      \n\r\n\rlong      \n\r\n\rscaling bits        \n\r\n\ro_bit1      \n\r\n\rlong      \n\r\n\roffset bits        \n\r\n\rDescription        \n\r\n\rFractal compression function        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Fractal_Compression","scr\\COM_HELP/Fractal_Compression.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:56:00Z  2004-06-04T00:56:00Z  1  49  281  SIUE  2  1  329  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rFractal_deCompression        \n\r\n\rFractal decompression        \n\r\n\rFunction Prototype        \n\r\n\rFractal_deCompression([in] BSTR *File_Name, [out, retval] long * Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR*      \n\r\n\rthe compressed file name        \n\r\n\rDescription        \n\r\n\rFractal decompression        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Fractal_deCompression","scr\\COM_HELP/Fractal_deCompression.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  9  4  2004-06-04T00:27:00Z  2005-12-01T22:22:00Z  1  444  2534  SIUE  21  5  2973  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rFuzzyc_Segment        \n\r\n\rimage segmentation based on fuzzy c-means        \n\r\n\rFunction Prototype        \n\r\n\rFuzzyc_Segment([in] long* image,[in] double variance, [out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to 3-band Image structure  \n\r\n\r(Note: ‘CVIPtools converts 1-band Image  into 3-band Image before performing Fuzzy c-means segmentation, and then extracts  1-band image from the segmentation result which is returned as the final output’)             \n\r\n\rvariance      \n\r\n\rdouble      \n\r\n\rvalue for Gaussian kernal  variance        \n\r\n\rDescription        \n\r\n\rColor image segmentation based on thresholding and the fuzzy c-means can be divided into  two stages: coarse and fine segmentation. The coarse segmentation is intended  to reduce the computational burden required for the fine segmentation the  fuzzy c-means. In coarse segmentation, a scale-space filter is used to  analyze the histograms of the three color components. It determines the  number of valid classes and assigns classified pixels to these classes  according to the threshold value (safety margins). The fine segmentation uses  fuzzy c-means to assign the remaining unclassified pixels to their closest  class. Histogram analysis using the scale-space filter in coarse segmentation  stage is a technique that involves generating a multiscale  description of histogram by convolving it with a series of Gaussians of  gradually increasing width, and marking the location and direction of the  sign change of zero-crossing in its second derivatives. The parameter (x, tau)-space is known to be the scale-space where tau is the scale constant. The scale constant tau is inversely proportional to the number of peaks and  valleys that can be extracted from the histograms. The importance of this  fact is that if prior knowledge is known about a particular type of image, tau can be set to be a constant to obtain the desired  number of peaks and values, and the process can be made unsupervised. The tau value that will give satisfactory result in most of  the color space used in an experiment is 5. After histogram analysis, valid  classes will be determined according to the safety margin (Usually 5% 20%)  specified by user. Classified pixels will be assigned to their valid classes,  and the other pixels will be tagged as unclassified. In this implementation,  they will appear as white pixels (255) on the image. The larger the safety  margin, the more accurate the result of the segmentation will be, and the  more computational efforts it will need when using the fuzzy c-means in fine  stage. In fine segmentation stage, the fuzzy membership of the unclassified  pixels will be calculated and assigned to the class where they have the  maximum membership value. The last parameter the user has to decide when  using the program is the display color of the result image. The user has the  option of using the means value for each valid class or the predefined colors  for the segmented regions.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Fuzzyc_Segment","scr\\COM_HELP/Fuzzyc_Segment.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:23:00Z  2004-06-04T00:23:00Z  1  136  781  SIUE  6  1  916  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGamma_Noise        \n\r\n\rAdd gamma noise to an image        \n\r\n\rFunction Prototype        \n\r\n\rGamma_Noise([in] long* image,[in] double var, [in] int alpha,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rvar      \n\r\n\rdouble      \n\r\n\rvariance of noise distribution        \n\r\n\ralpha      \n\r\n\rint      \n\r\n\ralpha parameter distribution (see equation)        \n\r\n\rDescription        \n\r\n\rGamma type noise is the result of low-pass  filtering of an image containing negative exponential noise as the result of  acquiring an image which is illuminated by a coherent laser. It\'s histogram  is defined as follows:  \n\r\n\r Gi^(alpha-1)  \n\r\n\r hi =  -----------------exp(-(Gi/a))  \n\r\n\r (alpha-1)!a^alpha  \n\r\n\rwhere Gi is the grey-level value of the ith pixel, a*a*alpha is the variance, and alpha  determines the shape of the histogram: aplha=1  gives a negative exponential histogram, and alpha=infinity gives a Gaussian  histogram.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Gamma_Noise","scr\\COM_HELP/Gamma_Noise.html","   Iris Cheng  ACADEMIC COMPUTING  3  10  2004-11-22T06:46:00Z  2004-11-22T06:51:00Z  1  97  553  Westar  4  1  649  10.3501    Clean  Clean                  MicrosoftInternetExplorer4           \n\r\n\rName      \n\r\n\rGaussian_Blur_Filter        \n\r\n\ran smoothing filter with a  Gaussian weighting to the mask coefficients        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Gaussian_Blur_Filter([in] long*  image,[in] long kernel, [out,retval] long*  \n\r\n\rResult_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rkernel      \n\r\n\rLong    kernel size, from 3 to 7      \n\r\n\rDescription      This function acts as a Gaussian smoothing filter. It is similar tothe mean filter but has a Gaussian weighting to the mask coefficientswhich fall off as we get away from the center pixel. Allowable kernelsizes range from 3x3 to 7x7.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Gaussian_Blur_Filter","scr\\COM_HELP/Gaussian_Blur_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:24:00Z  2004-06-04T00:24:00Z  1  110  627  SIUE  5  1  736  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGaussian_Noise        \n\r\n\rAdd gaussian  noise to an image        \n\r\n\rFunction Prototype        \n\r\n\rGaussian_Noise([in] long* image,[in] double var, [in]  double mean,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rvar      \n\r\n\rdouble      \n\r\n\rvariance of noise distribution        \n\r\n\rmean      \n\r\n\rdouble      \n\r\n\rmean or average value of noise distribution        \n\r\n\rDescription        \n\r\n\rGaussian noise is the most common type of  noise appearing in an image. It is called such because it has the Gaussian  shaped histogram as shown by the following equation:  \n\r\n\r hi =  ( exp((Gi-m)/(2*sigma^2)) ) / (sigma*sqrt(2*pi) )  \n\r\n\r where Gi is the grey-level value  of the ith pixel, sigma is the variance, m is the  mean.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Gaussian_Noise","scr\\COM_HELP/Gaussian_Noise.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:37:00Z  2004-06-04T00:37:00Z  1  103  590  SIUE  4  1  692  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGeometric_Filter        \n\r\n\ra non-linear mean filter which is better at removing gaussian type noise and preserving edge features than the  mean filter.        \n\r\n\rFunction Prototype        \n\r\n\rGeometric_Filter([in] long* image,[in] long mask_size,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to Image structure        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rthe size of the filtering window (e.g., 3-&gt;3x3).        \n\r\n\rDescription        \n\r\n\rReturns the product of all the pixels in  the filter window raised to the power of 3/N*N. Size of filter should be an  odd integer limited from &lt; 3 31 &gt;. A zero pixel value will result in  the filtered value being zero.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Geometric_Filter","scr\\COM_HELP/Geometric_Filter.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T17:13:00Z  2003-11-04T17:40:00Z  1  279  1594  Westar  13  3  1870  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGeometric_Mean        \n\r\n\rperforms a parametric wiener filter        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Geometric_Mean([in] long* image,[in] long* image1,[in]  long* image2,[in] long* image3,[in] double gamma,[in] double alpha,[in] long  choice,[in] long cutoff,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rGamma      \n\r\n\rDouble    \'gamma\' in the generalized restorationequation.      \n\r\n\rAlpha      \n\r\n\rDouble    \'alpha\' in the  generalized  restoration  equation.      \n\r\n\rChoice      \n\r\n\rLong    sets the maximum gain using the DC value  as  a     baseline      \n\r\n\rCutoff      \n\r\n\rLong    cutoff frequency for filtering      \n\r\n\rImage1      \n\r\n\rlong *    pointer to the degraded image      \n\r\n\rImage2      \n\r\n\rlong *    pointer to the original  image  power  spectral     density&nbsp;      \n\r\n\rDescription      This function performs a parametric wiener filter.  See  any     image processing textbook for info on Wiener Filters.&nbsp;     The function does its own memory management, freeing  every-     thing  passed to it, so if you need your images intact, make     a copy of them before calling this function.&nbsp;     The function tries to determine whether an FFT has been per-     formed on the passed images.  If not, the function will per-     form the FFT.  This is especially important to note for  the     power  images.   If  the  power  images  are  in the spatial     domain, they will have an FFT performed on them, before  the     squared  magnitude  is calculated.  If an FFT is detected in     the history of any  of  the  power  images,  that  image  is     assumed  to  be  representing  a power image, and no squared     magnitude is calculated.&nbsp;     The function will also extend the sizes of the passed images     as best it can when they are of unequal size.&nbsp;     Also note that the passed images must have the  same  number     of (color) bands.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Geometric_Mean","scr\\COM_HELP/Geometric_Mean.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T01:09:00Z  2004-06-04T01:09:00Z  1  49  284  SIUE  2  1  332  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rget_hist_real        \n\r\n\rGet the real part of the histogram        \n\r\n\rFunction Prototype        \n\r\n\rget_hist_real([in] long* image,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong*      \n\r\n\rthe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rDescription        \n\r\n\rGet the real part of the histogram        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","get_hist_real","scr\\COM_HELP/get_hist_real.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:47:00Z  2004-06-03T23:47:00Z  1  103  592  SIUE  4  1  694  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGet_Histogram_Image        \n\r\n\rgenerates a histogram Image from an image        \n\r\n\rFunction Prototype        \n\r\n\rGet_Histogram_Image([in] long* image,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the input Image pointer        \n\r\n\rDescription        \n\r\n\rget_histogram takes a pointer to  an Image structure and gen erates  a histogram from the input Image structure in the form of a pointer to a  pointer to a float. A separate histogram will be generated for each band in  the image.  \n\r\n\r get_histogram_Image is similar  to get_histogram, but it returns an Image * of the  input Image histogram, and is usually used for display purpose.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Get_Histogram_Image","scr\\COM_HELP/Get_Histogram_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T01:04:00Z  2004-06-04T01:05:00Z  1  50  287  SIUE  2  1  336  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGet_max_min_value        \n\r\n\rGet the max and min value of the image        \n\r\n\rFunction Prototype        \n\r\n\rGet_max_min_value([in] long* image,[in] double* Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rdouble*      \n\r\n\rThe return structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rDescription        \n\r\n\rGet the max and min value of the image        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","Get_max_min_value","scr\\COM_HELP/Get_max_min_value.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T01:05:00Z  2004-06-04T01:06:00Z  1  49  285  SIUE  2  1  333  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGetDataFormat_Image        \n\r\n\rGet the data format of the image        \n\r\n\rFunction Prototype        \n\r\n\rGetDataFormat_Image([in] long* image,[out,retval] long*  Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong*      \n\r\n\rThe return structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rDescription        \n\r\n\rGet the data format of the image        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","GetDataformat_Image","scr\\COM_HELP/GetDataformat_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:56:00Z  2004-06-03T23:56:00Z  1  48  279  SIUE  2  1  326  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGetDataType_Image        \n\r\n\rGet data type of the image        \n\r\n\rFunction Prototype        \n\r\n\rGetDataType_Image([in] long* image,[out,retval] long*  Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong *      \n\r\n\rdata types in integer returned        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rDescription        \n\r\n\rGet data type of the image        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","GetDataType_Image","scr\\COM_HELP/GetDataType_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T01:14:00Z  2004-06-04T01:14:00Z  1  49  284  SIUE  2  1  332  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGetImageInfo        \n\r\n\rGet the information from the image        \n\r\n\rFunction Prototype        \n\r\n\rGetImageInfo([in] long* orig_im, [out,retval] VARIANT *result_array);        \n\r\n\rReturn Value        \n\r\n\rresult_array      \n\r\n\rVARIANT*      \n\r\n\rThe return structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rorig_im      \n\r\n\rlong*      \n\r\n\rThe input image        \n\r\n\rDescription        \n\r\n\rGet the information from the image        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","GetImageInfo","scr\\COM_HELP/GetImageInfo.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:31:00Z  2003-11-04T17:40:00Z  1  60  342  Westar  2  1  401  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGetlast_Hist        \n\r\n\rGet the last operation history.        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Getlast_Hist([in] long* input_im,  [in] long * program,[in] int nprogs,  [out, retval] long* Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong *    Get the last operation       \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rDescription      This function gets the last operation from the history list.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Getlast_Hist","scr\\COM_HELP/Getlast_Hist.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:54:00Z  2004-06-03T23:54:00Z  1  50  289  SIUE  2  1  338  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGetNoOfBands_Image        \n\r\n\rGet number of bands of the image        \n\r\n\rFunction Prototype        \n\r\n\rGetNoOfBands_Image([in] long* image,[out,retval] long*  Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong *      \n\r\n\rNumber of the bands returned        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rDescription        \n\r\n\rGet number of bands of the image        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","GetNoOfBands_Image","scr\\COM_HELP/GetNoOfBands_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:55:00Z  2004-06-03T23:55:00Z  1  51  293  SIUE  2  1  343  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGetNoOfCols_Image        \n\r\n\rGet number of columns of the image        \n\r\n\rFunction Prototype        \n\r\n\rGetNoOfCols_Image([in] long* image,[out,retval] long*  Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong *      \n\r\n\rNumber of the columns returned        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rDescription        \n\r\n\rGet number of columns of the image        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","GetNoOfCols_Image","scr\\COM_HELP/GetNoOfCols_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:55:00Z  2004-06-03T23:55:00Z  1  50  287  SIUE  2  1  336  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGetNoOfRows_Image        \n\r\n\rGet number of bands of the image        \n\r\n\rFunction Prototype        \n\r\n\rGetNoOfRows_Image([in] long* image,[out,retval] long*  Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong *      \n\r\n\rNumber of the rows returned        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rDescription        \n\r\n\rGet number of rows of the image        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","GetNoOfRows_Image","scr\\COM_HELP/GetNoOfRows_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:14:00Z  2004-06-04T00:15:00Z  1  63  363  SIUE  3  1  425  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rgiftocvip        \n\r\n\rConvert GIF to CVIP        \n\r\n\rFunction Prototype        \n\r\n\rgiftocvip([ in ] BSTR *File_Name,[in] long*  cvip_Image, [in] long imageNumber,[in] long showmessage);        \n\r\n\rReturn Value        \n\r\n\rNone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR *      \n\r\n\rfile name of the image        \n\r\n\rcvip_Image      \n\r\n\rlong *      \n\r\n\rPointer to the image        \n\r\n\rimageNumber      \n\r\n\rlong      \n\r\n\rnumber of the image        \n\r\n\rshowmessage      \n\r\n\rlong      \n\r\n\rif show the message        \n\r\n\rDescription        \n\r\n\rConvert GIF to CVIP        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","giftocvip","scr\\COM_HELP/giftocvip.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:17:00Z  2004-06-03T23:17:00Z  1  170  970  SIUE  8  2  1138  10.3501    Clean  Clean                  MicrosoftInternetExplorer4    \n\r    \n\r\n\rName      \n\r\n\rGlr_Compress        \n\r\n\rPerforms grey level runlength  coding        \n\r\n\rFunction Prototype        \n\r\n\rGlr_Compress([ in ] BSTR *File_Name, [in] long* Input_image, [in]long win);        \n\r\n\rReturn Value        \n\r\n\rNone      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rwin      \n\r\n\rlong      \n\r\n\rsize of window (1-128)        \n\r\n\rDescription        \n\r\n\rglr_compress takes three  parameters, the pointer to the input image array of type byte, the file name  to which the compressed image is to be stored, and the window length. The  valid window length is (1-128). The user is suggested to use window length  from 1-75 as this range gives better results. The higher the window range the  higher the compression ratio and vice versa. At the end of the compression,  this routine automatically writes to the working window the following data:  the size of the original image, size of the compressed file, compression  ratio. Algorithmic details can be found in &quot;A Dynamic Window-Based Runlength Coding Algorithm Applied to Gray-Level  Images&quot;, M. Kumaran, S.E Umbaugh,  GRAPHICAL MODELS AND IMAGE PROCESSING Vol. 57, No. 4, July 1995, pp. 267-282.          \n\r\n\rBugs   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Glr_Compress","scr\\COM_HELP/Glr_Compress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:17:00Z  2004-06-03T23:18:00Z  1  96  551  SIUE  4  1  646  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGlr_Decompress        \n\r\n\ran uncompressed image pointer on success, a  NULL pointer on failure        \n\r\n\rFunction Prototype        \n\r\n\rGlr_Decompress([ in ] BSTR *File_Name, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rreturned pointer to the uncompressed image  structure, a valid Image pointer on success, a NULL pointer on failure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rDescription        \n\r\n\rglr_decompress takes pointer to  the character array and returns pointer to the image. The character array  represents the filename to be decoded. It returns a pointer to the decoded  image structure.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Glr_Decompress","scr\\COM_HELP/Glr_Decompress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:31:00Z  2004-06-03T23:31:00Z  1  103  589  SIUE  4  1  691  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGray_Binary        \n\r\n\ran uncompressed image pointer on success, a  NULL pointer on failure        \n\r\n\rFunction Prototype        \n\r\n\rGray_Binary([in] long* image,[in] int direction,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rreturned pointer to the uncompressed image  structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the input image        \n\r\n\rdirection      \n\r\n\rint      \n\r\n\rdirection (0=gray-&gt;binary  1=binary-&gt;gray)        \n\r\n\rDescription        \n\r\n\rPerforms binary code to gray code  conversion and the inverse conversion. The input image should be a real  image, of any data type (CVIP_BYTE, CVIP_SHORT, CVIP_INTEGER, CVIP_FLOAT or  CVIP_DOUBLE). Based on code in Numerical Recipes in C, second edition.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Gray_Binary","scr\\COM_HELP/Gray_Binary.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:47:00Z  2004-06-03T23:47:00Z  1  227  1297  SIUE  10  3  1521  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGray_Linear        \n\r\n\rperforms linear gray level modification        \n\r\n\rFunction Prototype        \n\r\n\rGray_Linear([in] long* image, [in] double start, [in] double end,[in] double s_gray, [in] double slope, [in] int  change, [in] int band,[out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an Image        \n\r\n\rstart      \n\r\n\rdouble      \n\r\n\rinitial gray level to modify        \n\r\n\rend      \n\r\n\rdouble      \n\r\n\rfinal gray level to modify        \n\r\n\rs_gray      \n\r\n\rdouble      \n\r\n\rnew initial gray level        \n\r\n\rslope      \n\r\n\rdouble      \n\r\n\rslope of modifying line        \n\r\n\rchange      \n\r\n\rint      \n\r\n\r0=change out-of-range pixels to black  \n\r\n\r1=don\'t modify out-of-range pixel values        \n\r\n\rband      \n\r\n\rint      \n\r\n\rthe band number to modify        \n\r\n\rDescription        \n\r\n\rPerforms linear gray level modification on  a range of values in an image. The user specifies a range of values to change  with &lt;start&gt; and &lt;end&gt;, the new gray level to apply at the  &lt;start&gt; value, and the function calculates a new value for each  subsequent gray value by applying &lt;slope&gt; to &lt;s_gray&gt;,  until &lt;end&gt; is reached. Slope can be positive, negative, or zero. Those  values not within the range &lt;start&gt;...&lt;end&gt; can be set to zero or  left unmodified.  \n\r\n\r The  parameter band specifies which band to modify, which can be a non-negative integeter (from 0 to no_of_bands  -1) for a specific band, or -1 representing all bands. If band is equal to or  greater than no_of_bands, the function will fail  and return a NULL pointer, since the required band doesn\'t exist. Usually,  the user is recommended to use -1 as the simplest way to use the function.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Gray_Linear","scr\\COM_HELP/Gray_Linear.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T01:12:00Z  2004-06-04T01:12:00Z  1  61  353  SIUE  2  1  413  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGray_Multiplication        \n\r\n\rTo multiply the images by a ratio        \n\r\n\rFunction Prototype        \n\r\n\rGray_Multiplication([in] long* image,[in] float ratio,[in] long  options, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong*      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong*      \n\r\n\rThe input image        \n\r\n\rratio      \n\r\n\rfloat      \n\r\n\rthe ratio        \n\r\n\roptions      \n\r\n\rlong      \n\r\n\rthe choice        \n\r\n\rDescription        \n\r\n\rTo multiply the images by a ratio        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Gray_Multiplication","scr\\COM_HELP/Gray_Multiplication.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:48:00Z  2004-06-03T23:48:00Z  1  71  409  SIUE  3  1  479  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGray_Multiply        \n\r\n\rmultiplies each pixel by a fixed ratio        \n\r\n\rFunction Prototype        \n\r\n\rGray_Multiply([in] long* image,[in] float ratio,[out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an Image        \n\r\n\rratio      \n\r\n\rfloat      \n\r\n\rmultiplier        \n\r\n\rDescription        \n\r\n\rThe function gray_multiply  multiplies each pixel in an image by a fixed value. The function clips to 0  and 255, and requires CVIP_BYTE type input.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Gray_Multiply","scr\\COM_HELP/Gray_Multiply.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:49:00Z  2004-06-03T23:49:00Z  1  75  434  SIUE  3  1  508  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGray_Multiply2        \n\r\n\rmultiplies each pixel by a fixed ratio        \n\r\n\rFunction Prototype        \n\r\n\rGray_Multiply2([in] long* image,[in] float  ratio,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an Image        \n\r\n\rration      \n\r\n\rfloat      \n\r\n\rmultiplier        \n\r\n\rDescription        \n\r\n\rgray_multiply2 first casts the input image to CVIP_FLOAT image, then multiplies each  pixel by a fixed value without clipping the image data, and returns a  CVIP_FLOAT image.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Gray_Multiply2","scr\\COM_HELP/Gray_Multiply2.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:27:00Z  2004-06-04T00:28:00Z  1  81  467  SIUE  3  1  547  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGray_Quant_Segment        \n\r\n\rremaps to desired number of gray levels        \n\r\n\rFunction Prototype        \n\r\n\rGray_Quant_Segment([in] long* image,[in]  long num_bits,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rnum_bits      \n\r\n\rlong      \n\r\n\rnumber of gray levels desired  (2,4,8,...128)        \n\r\n\rDescription        \n\r\n\rThis function remaps (quantizes) an image  to a user-specified number of gray levels. The number of gray levels used  must be a power of 2, to a maximum of 128 levels.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Gray_Quant_Segment","scr\\COM_HELP/Gray_Quant_Segment.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T01:02:00Z  2004-06-04T01:02:00Z  1  63  364  SIUE  3  1  426  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGraylevel_Quant        \n\r\n\rGray level quantization function        \n\r\n\rFunction Prototype        \n\r\n\rGraylevel_Quant([in] long* image,[in] long num_bits, [in] long choice,  [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rnum_bits      \n\r\n\rlong      \n\r\n\rThe number of bits        \n\r\n\rchoice      \n\r\n\rlong      \n\r\n\rchoice        \n\r\n\rDescription        \n\r\n\rGray level quantization function        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Graylevel_Quant","scr\\COM_HELP/Graylevel_Quant.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T01:12:00Z  2004-06-04T01:13:00Z  1  74  426  SIUE  3  1  499  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rGraylevel_Remap        \n\r\n\rTo remap the gray image to specific RGB values        \n\r\n\rFunction Prototype        \n\r\n\rGraylevel_Remap([in] long* inputImage,[in] long bandR, [in] long bandG, [in]  long bandB, [out,retval]  long *Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong*      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong*      \n\r\n\rThe input image        \n\r\n\rbandR      \n\r\n\rlong      \n\r\n\rThe value of the band R        \n\r\n\rbamdG      \n\r\n\rlong      \n\r\n\rThe value of the band G        \n\r\n\rbandB      \n\r\n\rlong      \n\r\n\rThe value of the band B        \n\r\n\rDescription        \n\r\n\rTo multiply the images by a ratio        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","Graylevel_Remap","scr\\COM_HELP/Graylevel_Remap.html","   ACADEMIC COMPUTING  Normal  P!Nk  3  8  2004-06-04T00:27:00Z  2009-12-08T16:55:00Z  1  197  1129  SIUE  9  2  1324  12.00    120  Clean  Clean  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                                     \n\r\n\rName      \n\r\n\rGVFSnake_Segment        \n\r\n\rCreates a boundary around a desired object.        \n\r\n\rFunction Prototype        \n\r\n\rGVFSnake_Segment([in] long* image, [in] long num_iter, [in]  long alpha, [in] long beta, [in] long kappa, [out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rnum_iter  \n\r\n\r&nbsp;  \n\r\n\ralpha  \n\r\n\r&nbsp;  \n\r\n\rbeta  \n\r\n\r&nbsp;  \n\r\n\rkappa      \n\r\n\rlong  \n\r\n\r&nbsp;  \n\r\n\rlong  \n\r\n\r&nbsp;  \n\r\n\rlong  \n\r\n\r&nbsp;  \n\r\n\rlong      \n\r\n\rnumber of iterations  \n\r\n\r&nbsp;  \n\r\n\rcoefficient of the second derivative of the function in  the energy equation  \n\r\n\rcoefficient of the fourth derivative of the function in  the energy equation  \n\r\n\rcoefficient of the external forces in the energy  equation        \n\r\n\rDescription        \n\r\n\rThe gvf snake method can be used for edge detection,  \n\r\n\rsegmentation, shape modeling and motion tracking.   \n\r\n\rA snake,  is a curve defined within an image domain that   \n\r\n\rcan move under the influence of internal forces within   \n\r\n\rthe curve itself and external forces derived from the   \n\r\n\rimage data. The internal and  external forces are defined   \n\r\n\rso that the snake will conform to an object boundary  or other desired features within an image. This functioncalculates the external forces by calculating the gradient vector flow fields in the image.The method works only on gray level images. Though thefunction itself converts the image even if the inputimage is a color image.       \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","GVFSnake_Segment","scr\\COM_HELP/GVFSnake_Segment.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:14:00Z  2003-11-04T17:40:00Z  1  136  781  Westar  6  1  916  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rH_image        \n\r\n\rcreate a mask image according to the size and type        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT H_image([in ] long type, [in ] long height, [in ] long  width,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rImage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rType      \n\r\n\rLong     mask type: 1-Constant                            2-Center weighted                            3-Gaussian&nbsp;      \n\r\n\rHeight      \n\r\n\rLong    height of the mask image&nbsp;      \n\r\n\rwidth      \n\r\n\rLong    width of the mask image&nbsp;      \n\r\n\rDescription      Creates a single band mask image of size (width x height). A     constant  mask image has all the pixel values as 1; a center     weighted mask image is  the same as a  constant  mask  image     except  the  central value is (width x height); the Gaussian     mask is normalized to (width x height) at the central value.     The return Image data type is CVIP_FLOAT.&nbsp;&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","H_image","scr\\COM_HELP/H_image.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:09:00Z  2003-11-04T17:40:00Z  1  84  480  Westar  4  1  563  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHaar_Transform      performs a fast Haar transform      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Haar_Transform([in] long* image,[in] long param1,[in]  long param2, [out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rparam1      \n\r\n\rlong     1 (forward transform) or 0 (inverse transform)      \n\r\n\rparam2      \n\r\n\rlong     block size (4,8,16,...largest_dimension/2)      \n\r\n\rDescription      This function performs a fast Haar transform. The image must     have dimensions that are a power of two.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Haar_Transform","scr\\COM_HELP/Haar_Transform.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:37:00Z  2004-06-04T00:38:00Z  1  100  572  SIUE  4  1  671  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHarmonic_Filter        \n\r\n\ra non-linear mean filter which is better at  removing gaussian type noise and preserving edge features than the mean  filter. Good at removing positive outliers.        \n\r\n\rFunction Prototype        \n\r\n\rHarmonic_Filter([in] long* image,[in] long  mask_size,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to Image structure        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rthe size of the filtering window (e.g.,  3-&gt;3x3).        \n\r\n\rDescription        \n\r\n\rReturns a value equal to N*N divided by the  inverse of the sum of the pixels in the filter window. The filter size should  be an odd integer limited from &lt; 3 31&gt;.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Harmonic_Filter","scr\\COM_HELP/Harmonic_Filter.html","   Mounika  Normal  jhansi  40  21  2003-11-04T17:29:00Z  2010-01-06T21:33:00Z  1  160  912  SIUE  7  2  1070  11.9999    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4             \n\r\n\rName      \n\r\n\rHarris_Filter      a spatial- an edge detecting filter      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Harris_Filter([in]  long* inputImage,[in] float alpha, int threshold,   \n\r\n\rint border, float dmin, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *    &nbsp; Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\ralpha      \n\r\n\rfloat    Sensitivity value      \n\r\n\rthreshold      \n\r\n\rint    Threshold value      \n\r\n\rborder      \n\r\n\r&nbsp;int    &nbsp;&nbsp;The number of rows and columns along image border      \n\r\n\rdmin      \n\r\n\rfloat    &nbsp; radius of the circle to check for the corner&nbsp; \n\r\n\r&nbsp;\n\r\n\r&nbsp;     \n\r\n\rDescription        \n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp; The  Harris filter is a spatial-domain method for for  corner   \n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp; detector  developed by Harris and Stephens in 1988.In this&nbsp;&nbsp;&nbsp;&nbsp;   \n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp; filter corner response function to find the corners.  \n\r\n\r&nbsp;  \n\r\n\r                                                                        \n\r\n\r&nbsp;  \n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp; Where  CRF(r,c) represents the corners&nbsp; of&nbsp; the  original&nbsp; image&nbsp;   \n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;And  G(P1*P1) is the Gaussian of the vertical gradient.  G(P2*P2)  \n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp; Is the  Gaussian of horizontal gradient.&nbsp;&nbsp;&nbsp;&nbsp;    &nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Harris_Filter","scr\\COM_HELP/harris_Filter.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:14:00Z  2003-11-04T17:40:00Z  1  212  1213  Westar  10  2  1423  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHigh_Freq_Emphasis      performs  high   frequency   emphasis     filtering      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT High_Freq_Emphasis([in] long* image,[in] long  block_size, [in]  long dc, [in] long Cutoff, [in] double alfa, [in]  long order,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rBlock_size      \n\r\n\rLong    desired block size&nbsp;      \n\r\n\rDc      \n\r\n\rLong    drop(0) or retain(1) dc component&nbsp;      \n\r\n\rCutoff      \n\r\n\rLong    cutoff frequency&nbsp;      \n\r\n\rAlpha      \n\r\n\rLong    a constant (typically 1.0 to 2.0)&nbsp;      \n\r\n\rOrder      \n\r\n\rLong    filter order&nbsp;      \n\r\n\rDescription      High_Freq_Emphasis() performs a  two-dimensional  high  fre-     quency  emphasis  filtering  in  transform  domain  on input     image.It is implemented by adding a constant  to  a  butter-     worth high pass filter transfer function. This preserves the     low frequency components of the image and at the same  time,     amplifies  the high-frequency components. The result of this     process is better tonality in the final image.  The  cut-off     frequency cutoff and filter order &lt;order&gt; is for the butter-     worth high pass filter used in this high frequency  emphasis     filter.  Experiment  revealed  that the constant alfa in the     range of 1.0 to 2.0 yields good result. If dc equals 1,  the     dc  component  will be retained, if it equals 0, the dc com-     penent will be dropped.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","High_Freq_Emphasis","scr\\COM_HELP/High_Freq_Emphasis.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:59:00Z  2004-06-04T00:59:00Z  1  113  649  SIUE  5  1  761  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHighboost        \n\r\n\rHighboost sharpening algorithm        \n\r\n\rFunction Prototype        \n\r\n\rHighboost([in] long *inputImage, [in] long MaskSize, [in] long CenterValue,  [in] long ifAdd2Origin, [out, retval] long * Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rMaskSize      \n\r\n\rlong      \n\r\n\rThe size of the mask        \n\r\n\rCenterValue      \n\r\n\rlong      \n\r\n\rThe value of the center        \n\r\n\rifAdd2Origin      \n\r\n\rlong      \n\r\n\rIf to add to original image        \n\r\n\rDescription        \n\r\n\rHighboost sharpening algorithm  \n\r\n\r1. If it is not Byte or short image convert it to byte  \n\r\n\r2. create a mask with masksize with all  element equals -1 except the center value is specified by centervalue  \n\r\n\r3. convolve_filter with that mask  \n\r\n\r4. if Add 2 original, add it and return        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","Highboost","scr\\COM_HELP/Highboost.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:59:00Z  2004-06-04T01:00:00Z  1  96  551  SIUE  4  1  646  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHighFreq_Emphasis        \n\r\n\rHigh frequency emphasis function        \n\r\n\rFunction Prototype        \n\r\n\rHighFreq_Emphasis([in] long * inputImage, [in] long TransformMethod, [in] long CutoffFreq,  [in] long FilterOrder, [in] double OffSet, [in] long KeepDC, [out,  retval] long * Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rTransformMethod      \n\r\n\rlong      \n\r\n\rThe Transform Method        \n\r\n\rCutoffFreq      \n\r\n\rlong      \n\r\n\rThe cutoff frequency        \n\r\n\rFilterOrder      \n\r\n\rlong      \n\r\n\rThe order of the filter        \n\r\n\rOffset      \n\r\n\rdouble      \n\r\n\rOff set value        \n\r\n\rKeepDC      \n\r\n\rlong      \n\r\n\rIf to keep DC term        \n\r\n\rDescription        \n\r\n\rHigh frequency emphasis function        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","HighFreq_Emphasis","scr\\COM_HELP/HighFreq_Emphasis.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:58:00Z  2004-06-04T00:59:00Z  1  103  591  SIUE  4  1  693  10.3501    Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHighpass_Spatial        \n\r\n\rHigh pass spatial filter        \n\r\n\rFunction Prototype        \n\r\n\rHighpass_Spatial([in] long *inputImage, [in] long ifAdd2Origin, [out,  retval] long * Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rifAdd2Origin      \n\r\n\rlong      \n\r\n\rIf to add to original image        \n\r\n\rDescription        \n\r\n\rHigh pass spatial filter  \n\r\n\r1. If it is not Byte or short image convert it to byte  \n\r\n\r2. create default 3x3 High pass spatial filter mask with  get_default_filter  \n\r\n\r3. convolve_filter with that mask  \n\r\n\r4. if Add 2 original, add it and return  \n\r\n\r&nbsp;        \n\r\n\rBugs        \n\r\n\rIn old version its default add to original  and if user choose to add then add it again.   \n\r\n\r&nbsp;","Highpass_Spatial","scr\\COM_HELP/Highpass_Spatial.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  0  2004-06-04T01:08:00Z  2005-12-02T04:45:00Z  1  142  814  SIUE  6  1  955  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHist_Feature        \n\r\n\rcalculates histogram features: mean, standard deviation, skew, energy  and entropy        \n\r\n\rFunction Prototype        \n\r\n\rHist_Feature([in] long* orig_im, [in] long* labeled_im, [in] long r, [in] long c ,[out,retval] VARIANT *result_array);        \n\r\n\rReturn Value        \n\r\n\rresult_array      \n\r\n\rVARIANT*      \n\r\n\rthe return structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rorig_im      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rlabel_im      \n\r\n\rlong*      \n\r\n\rPointer to the labeled image        \n\r\n\rr      \n\r\n\rlong      \n\r\n\rrow coordinate of a point on the labled  image        \n\r\n\rc      \n\r\n\rlong      \n\r\n\rcolumn coordinate of a point on the labled  image        \n\r\n\rDescription        \n\r\n\rThe program first calculates the histogram P(g) of the object of  interest in each band, then computes mean, standard deviation, skew, energy  and entropy.Those gray  level values whose P(g) equal to zero are  filtered out. Equations of these five measures are given in chapter 6 of the following  book:  \n\r\n\rComputer Imaging: Digital Image Analysis and Processing:  \n\r\n\rS.E.Umbaugh, A CRC Press Book, 2005        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","Hist_Feature","scr\\COM_HELP/Hist_Feature.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:50:00Z  2004-06-03T23:50:00Z  1  68  393  SIUE  3  1  460  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHist_Slide        \n\r\n\rperforms histogram slide        \n\r\n\rFunction Prototype        \n\r\n\rHist_Slide([in] long* image,[in] int slide,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an Image        \n\r\n\rslide      \n\r\n\rint      \n\r\n\ramount of slide        \n\r\n\rDescription        \n\r\n\rThis function slides a histogram up if  &lt;slide&gt; is positive or down if &lt;slide&gt; is negative. It requires  CVIP_BYTE type input, and clips at 0 or 255.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Hist_Slide","scr\\COM_HELP/Hist_Slide.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:20:00Z  2004-06-04T00:20:00Z  1  249  1421  SIUE  11  3  1667  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHist_Spec        \n\r\n\rperforms histogram specification on an  image        \n\r\n\rFunction Prototype        \n\r\n\rHist_Spec([in] long * InputImage, [in] BSTR *bandR, [in] BSTR *bandG, [in]  BSTR *bandB, [out, retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rInputImage      \n\r\n\rlong *      \n\r\n\rpointer to the input Image structure. The data type of the image must be  CVIP_BYTE or remapped to CVIP_BYTE;        \n\r\n\rbandR      \n\r\n\rBSTR *      \n\r\n\rfunctions to Red band        \n\r\n\rbandG      \n\r\n\rBSTR *      \n\r\n\rfunctions to Green band        \n\r\n\rbandB      \n\r\n\rBSTR *      \n\r\n\rfunctions to Blue band        \n\r\n\rDescription        \n\r\n\rThe histogram_spec() function performs a  histogram specification on an image pointer Image* using the histogram  specified in the pointer to pointer to float float**  passed to the function. The specified histogram is computed by calculating  the cumulative distrubution function of both the  original histogram and the desired histogram. The cdf  for the original histogram is then mapped to the desired histogram using the  inverse cdf. If Pr(x) is the original histogram,  and Pz(x) is the desired histogram, then the cdf[Pr(x)]  = T(r) = s, and cdf[Pz(x)]  = G(z) = v. The inverse of this is z = inv[G(v)].  Therefore z = inv[G(T(r))]. Where r is the original grey-level, and z is the new grey-level.  \n\r\n\r The histogram_spec can perform a different specification on  each color band in the image.  \n\r\n\r hist_spec()  is a higher level function above histogram_spec().  The difference is that hist_spec() will get a mathematical formula for each band to  specify the desired histogram, create the specified the histogram, and call histogram_spec(). Usually, the user calls hist_spec()  directly, and calls histogram_spec() indirectly.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Hist_Spec","scr\\COM_HELP/Hist_Spec.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:51:00Z  2004-06-03T23:51:00Z  1  127  726  SIUE  6  1  852  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHist_Stretch        \n\r\n\rstretches a histogram        \n\r\n\rFunction Prototype        \n\r\n\rHist_Stretch([in] long* image, [in] int  low_limit, [in] int high_limit,[in] float low_clip, [in] float  high_clip,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rlow_limit      \n\r\n\rint      \n\r\n\rlower limit for stretch        \n\r\n\rhigh_limit      \n\r\n\rint      \n\r\n\rhigh limit for stretch        \n\r\n\rlow_clip      \n\r\n\rfloat      \n\r\n\rpercentage of low values to clip before  stretching        \n\r\n\rhigh_clip      \n\r\n\rfloat      \n\r\n\rpercentage of high values to clip before  stretching        \n\r\n\rDescription        \n\r\n\rThis function increases contrast in an image  by stretching the histogram to span the range low_limit to high_limit. To  improve performance of the function when outliers are present, percentages  low_clip and high_clip pixel values can be removed before the stretch takes  place.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Hist_Stretch","scr\\COM_HELP/Hist_Stretch.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:28:00Z  2004-06-04T00:29:00Z  1  105  601  SIUE  5  1  705  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHist_Thresh_Segment        \n\r\n\ra thresholding-of-histogram  segmentation technique        \n\r\n\rFunction Prototype        \n\r\n\rHist_Thresh_Segment([in] long* image,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rDescription        \n\r\n\rhist_thresh_gray segments a  grayscale image using a thresholding-of-histogram  segmentation technique to split image regions recursively. hist_thresh_segment is a driver  of hist_thresh_gray. Especially, if the input image  is multi-band, hist_thresh_segment first uses the  Principal Components Transform (PCT) to map the maximum information into one  image plane, then calls hist_thresh_gray.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Hist_Thresh_Segment","scr\\COM_HELP/Hist_Thresh_Segment.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:49:00Z  2004-06-03T23:50:00Z  1  135  776  SIUE  6  1  910  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHisteq        \n\r\n\rperforms histogram equalization        \n\r\n\rFunction Prototype        \n\r\n\rHisteq([in] long* image,[in] int mb,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\ra pointer to an Image structure        \n\r\n\rmb      \n\r\n\rint      \n\r\n\rwhich band (0,1, or 2) to operate on; use 0  for gray        \n\r\n\rDescription        \n\r\n\rThis function performs a  histogram equalization (histeq) on an input  image. Histeq distributes the gray level values  within an image as evenly as possible. The goal of histeq  is a flat histogram.  \n\r\n\r The  function works with color or grayscale images. With a color image, the user  specifies band 0, 1, or 2 as the band to use for histogram calculations. For  a grayscale image, specify band \'0\'. The function automatically casts any  CVIP_INTEGER, CVIP_FLOAT or CVIP_DOUBLE image into CVIP_SHORT. It operates  directly on images of type CVIP_SHORT and CVIP_BYTE.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Histeq","scr\\COM_HELP/Histeq.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:21:00Z  2004-06-04T00:21:00Z  1  171  975  SIUE  8  2  1144  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHistogram_Spec        \n\r\n\rperforms histogram specification on an  image        \n\r\n\rFunction Prototype        \n\r\n\r([in] long * InputImage,  [in]double* sped_in,[out, retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rInputImage      \n\r\n\rlong *      \n\r\n\rPointer to the image        \n\r\n\rsped_in      \n\r\n\rdouble *      \n\r\n\rthe specified histogram        \n\r\n\rDescription        \n\r\n\rThe histogram_spec() function performs a  histogram specification on an image pointer Image* using the histogram  specified in the pointer to pointer to float float**  passed to the function. The specified histogram is computed by calculating  the cumulative distrubution function of both the  original histogram and the desired histogram. The cdf  for the original histogram is then mapped to the desired histogram using the  inverse cdf. If Pr(x) is the original histogram,  and Pz(x) is the desired histogram, then the cdf[Pr(x)]  = T(r) = s, and cdf[Pz(x)]  = G(z) = v. The inverse of this is z = inv[G(v)].  Therefore z = inv[G(T(r))]. Where r is the original grey-level, and z is the new grey-level. The histogram_spec can perform a different specification on  each color band in the image.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Histogram_Spec","scr\\COM_HELP/Histogram_Spec.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T17:30:00Z  2003-11-04T17:41:00Z  1  54  310  Westar  2  1  363  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHistory_Add        \n\r\n\rAdd history record to an image        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT History_Add([in] long* input_im,[in]  long* input_history);        \n\r\n\rReturn Value        \n\r\n\rN/A      \n\r\n\r&nbsp;    &nbsp;      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rInput_history      \n\r\n\rlong *    Pointer to the history to be added.       \n\r\n\rDescription      Add one history record into the image.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","History_Add","scr\\COM_HELP/History_Add.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:30:00Z  2003-11-04T17:41:00Z  1  63  360  Westar  3  1  422  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHistory_Check        \n\r\n\rCheck if specified operation has been performed in  the image.         \n\r\n\rFunction Prototype        \n\r\n\rHRESULT History_Check([in] long* image,[in] int  program, [out,retval] long* Result);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rProgram      \n\r\n\rInt    The operation type      \n\r\n\rDescription      Check if the operation has been performed.       \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","History_Check","scr\\COM_HELP/History_Check.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:31:00Z  2003-11-04T17:41:00Z  1  59  340  Westar  2  1  398  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHistory_Copy        \n\r\n\rCopy the operation history.        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT History_Copy([in] long* input_from,[in]  long* input_to);        \n\r\n\rReturn Value        \n\r\n\rN/A      \n\r\n\r&nbsp;    &nbsp;      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rInput_from      \n\r\n\rlong *    pointer to an Image structure copy from      \n\r\n\rInput_to      \n\r\n\rlong *    pointer to an Image structure the history copy to       \n\r\n\rDescription      Copy the operation history from one image to another.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","History_Copy","scr\\COM_HELP/History_Copy.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T17:31:00Z  2003-11-04T17:41:00Z  1  79  452  Westar  3  1  530  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rhistory_create        \n\r\n\rCreate a history structure and return it by using  the input parameter        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT history_create([in] long prog,  [in] long type, [in] float value, [out, retval]  long* Result);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rProg      \n\r\n\rLong    Operation name      \n\r\n\rType      \n\r\n\rLong    Operation type      \n\r\n\rValue      \n\r\n\rFloat    Extra space for other data      \n\r\n\rDescription      This function creates history record base on the input parameters.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","History_Create","scr\\COM_HELP/history_create.html","   Iris Cheng  Iris Cheng  2  2  2003-11-04T17:30:00Z  2003-11-04T17:42:00Z  1  50  290  Westar  2  1  339  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHistory_Get        \n\r\n\rGet the operation history        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT History_Get([in] long* image,[in] int  program,[out,retval] long* Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong *    Get the result      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rDescription      Get the operation history from the image      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","History_Get","scr\\COM_HELP/History_Get.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:43:00Z  2004-06-04T00:43:00Z  1  59  342  SIUE  2  1  400  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHistory_get_data        \n\r\n\rGet data from the history structure        \n\r\n\rFunction Prototype        \n\r\n\rHistory_get_data([in] long* history,[in] int program, [out,retval]  long* Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong *      \n\r\n\rAddress of the history structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rhistory      \n\r\n\rlong *      \n\r\n\rPointer to the history structure        \n\r\n\rprogram      \n\r\n\rint      \n\r\n\rPROGRAM enum        \n\r\n\rDescription        \n\r\n\rGet data out of the history structure        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","History_get_data","scr\\COM_HELP/History_get_data.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:14:00Z  2003-11-04T17:42:00Z  1  168  959  Westar  7  2  1125  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHomomorphic      performs homomorphic  filtering  on  an  input     image  \n\r\n\r&nbsp;        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Homomorphic([in] long* image,[in] double upper, [in]  double lower,[in] long cutoff, [in] long ifAdd2Origin, [out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rUpper      \n\r\n\rDouble    upper limit, &gt; 1&nbsp;      \n\r\n\rLower      \n\r\n\rDouble    lower limit, &lt; 1&nbsp;      \n\r\n\rCutoff      \n\r\n\rLong     cutoff frequency&nbsp;      \n\r\n\rDescription      Homomorphic filtering  is  used  to  reduce  the  effect  of     illumination  variations  in  a  scene while emphasizing the     reflectance components. This function has a  setup  routine,     called  by  CVIPtools,  to allow the user to input the upper     and lower limits and cutoff frequency  of  the  filter.  The     upper limit should be greater than 1; the lower limit should     be less than 1. Typical values range between 2.0 and 0.5.&nbsp;     There is another function, get_function, that will return  a     floating point array containing the distribution of a filter     mask created using a sine wave.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Homomorphic","scr\\COM_HELP/Homomorphic.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:27:00Z  2003-11-04T17:42:00Z  1  52  297  Westar  2  1  348  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHorizontal_Flip        \n\r\n\rFlip the image horizontally        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Horizontal_Flip([in] long* image,[out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rDescription      This function flips the image horizontally.       \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Horizontal_Flip","scr\\COM_HELP/Horizontal_Flip.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:38:00Z  2004-06-04T00:38:00Z  1  172  983  SIUE  8  2  1153  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHough_Filter        \n\r\n\rcalculates thinness ratio        \n\r\n\rFunction Prototype        \n\r\n\rHough_Filter([in] long *image, [in] BSTR * name_in, [in]  BSTR * degree_string_in,[in] long threshold, [in]  long connection, [in] long interactive, [in] long delta_length,  [in] long segment_length,[out, retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to a binary image structure        \n\r\n\rname_in      \n\r\n\rBSTR *      \n\r\n\rname of the input image        \n\r\n\rdegree_string_in      \n\r\n\rBSTR *      \n\r\n\ra string indicating angles of interest        \n\r\n\rthreshold      \n\r\n\rlong      \n\r\n\rminimum number of pixels to define a line        \n\r\n\rconnection      \n\r\n\rlong      \n\r\n\rmaximum distance to link on a line        \n\r\n\rinteractive      \n\r\n\rlong      \n\r\n\r0 = use above parameters 1 = read degree_string, threshold, and connection from standard  input        \n\r\n\rdelta_length      \n\r\n\rlong      \n\r\n\r&nbsp;        \n\r\n\rsegment_length      \n\r\n\rlong      \n\r\n\r&nbsp;        \n\r\n\rDescription        \n\r\n\rThe Hough transform is designed to find or  complete lines in an image. It uses an edge-detected image as input and links  those points that fit user-defined parameters of distance and orientation  angle.  \n\r\n\r For  a detailed explanation of the required inputs, see the header description in  the file $CVIPHOME/SPATIALFILTER/hough.c.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Hough_Filter","scr\\COM_HELP/Hough_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:18:00Z  2004-06-03T23:19:00Z  1  173  989  SIUE  8  2  1160  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHuf_Compress        \n\r\n\rperforms lossless Huffman coding        \n\r\n\rFunction Prototype        \n\r\n\rHuf_Compress([ in ] BSTR *File_Name, [in] long* Input_image);        \n\r\n\rReturn Value        \n\r\n\rNone      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rDescription        \n\r\n\rhuf_compress takes two  parameters, they are a pointer to the input image structure, and the file  name to which the compressed image is to be stored. The user doesn\'t have to  provide the filename extension &quot;huf&quot;.  Even if the user forgets to enter the extension or enters a wrong extension  the programme takes care of it by appending or  replacing with the correct extension(&quot;huf&quot;). At the end of the compression, this routine  automatically writes to the working window the compression ratio. Series of  steps are involved in huffman coding. First the  input image is read. Then the array table is built with the symbol(greylevel value) and  frequency of occurence. Then a binary tree is built  from the array table(probability array). Using the  binary tree that was built each symbol(greylevel value) is encoded and written to the user  defined binary file.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Huf_Compress","scr\\COM_HELP/Huf_Compress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:19:00Z  2004-06-03T23:19:00Z  1  147  839  SIUE  6  1  985  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rHuf_Decompress        \n\r\n\ran uncompressed image pointer on success, a  NULL pointer on failure        \n\r\n\rFunction Prototype        \n\r\n\rHuf_Decompress([ in ] BSTR *File_Name, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rreturned pointer to the uncompressed image  structure, a valid Image pointer on success, a NULL pointer on failure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rDescription        \n\r\n\rhuf_decompress takes a pointer to  the character array and returns a pointer to the image. The character array  represents the filename to be decoded with the extension &quot;huf&quot;. It returns a pointer to the decoded image.  During decompression process the encoded file is read. The encoded file size, symbol frequency, are extracted from the encoded  file. A binary tree is built from the probability table that was stored in  the encoded file. The original image is recovered without any loss in  information by parsing through the binary tree.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Huf_Decompress","scr\\COM_HELP/Huf_Decompress.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T17:06:00Z  2003-11-04T17:42:00Z  1  64  367  Westar  3  1  430  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rIdct_Transform      Perform inverse dct transform      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Idct_Transform([in] long* image,[in] long block_size,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rBlock_size      \n\r\n\rlong     block size      \n\r\n\rDescription      idct_transform   performs   the   inverse   2D-dct_transform     transform..      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Idct_Transform","scr\\COM_HELP/Idct_Transform.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T17:15:00Z  2003-11-04T17:43:00Z  1  152  868  Westar  7  2  1018  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rIdeal_Band_Pass        \n\r\n\rperform ideal bandpass  filtering        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Ideal_Band_Pass([in]  long* image,[in] long        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rBlock_size      \n\r\n\rlong     desired block size      \n\r\n\rDc      \n\r\n\rlong     drop(0) or retain(1) dc component&nbsp;      \n\r\n\rInner      \n\r\n\rLong    inner cutoff frequency&nbsp;      \n\r\n\rOuter      \n\r\n\rLong    outer cutoff frequency&nbsp;      \n\r\n\rDescription      Ideal_Band_Pass() performs  two-dimensional  ideal  bandpass     filtering in transform domain on input image.  All frequency     components that are in the band enclosed by the  circle  (or     1/4  circle if dc component is on the upper left-hand corner     of its transform plane) with radius  inner  and  the  circle     with  radius  outer  will be passed with no attenuation. All     frequencies outside the circular band (or 1/4 circular band)     are  completely attenuated. If dc equals 1, the dc component     will be retained, if dc equals 0, it will be dropped      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Ideal_Band_Pass","scr\\COM_HELP/Ideal_Band_Pass.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T17:15:00Z  2003-11-04T17:43:00Z  1  183  1044  Westar  8  2  1225  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rIdeal_Band_Reject        \n\r\n\rHRESULT Ideal_Band_Reject([in]  long* image,[in] long           block_size, [in] long      dc,  [in] long            inner, [in] long   outer, [out,retval]  long* Result_Image);        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Ideal_Band_Reject([in] long* image,[in] long           block_size,  [in] long      dc, [in] long            inner, [in] long   outer, [out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rBlock_size      \n\r\n\rlong     desired block size      \n\r\n\rDc      \n\r\n\rlong     drop(0) or retain(1) dc component&nbsp;      \n\r\n\rInner      \n\r\n\rLong    inner cutoff frequency&nbsp;      \n\r\n\rOuter      \n\r\n\rLong    outer cutoff frequency&nbsp;      \n\r\n\rDescription      Ideal_Band_Reject() performs two-dimensional  ideal  bandre-     ject filtering in transform domain on input image.  All fre-     quency components that are in the band enclosed by the  cir-     cle (or 1/4 circle if dc component is on the upper left-hand     corner of its transform plane) with  radius  inner  and  the     circle  with  radius outer will be filtered. All frequencies     outside the circular band (or 1/4 circular  band)  are  left     completely intact.  If dc equals 1, the dc component will be     retained, if dc equals 0, it will be dropped.&nbsp;&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Ideal_Band_Reject","scr\\COM_HELP/Ideal_Band_Reject.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:16:00Z  2003-11-04T17:43:00Z  1  143  817  Westar  6  1  959  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rIdeal_High        \n\r\n\rperform ideal highpass  filtering        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Ideal_High([in] long* image,[in] long           block_size,  [in] long      dc, [in] long cutoff,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rblock_size      \n\r\n\rlong     desired block size      \n\r\n\rDc      \n\r\n\rLong    drop(0) or retain(1) dc component      \n\r\n\rCutoff      \n\r\n\rLong    cutoff frequency      \n\r\n\rDescription      Ideal_High() performs two-dimensional ideal highpass filter-     ing  in transform domain on input image.  All frequency com-     ponents that are inside the circle (or 1/4 circle if dc com-     ponent  is  on  the  upper-left-hand corner of its transform     plane) of radius &quot;cutoff&quot; are filtered, while  all  frequen-     cies  outside the circle (or 1/4 circle) are left completely     intact. If dc equals 1, the dc component will  be  retained,     if it equals 0, it will be dropped.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Ideal_High","scr\\COM_HELP/Ideal_High.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:44:00Z  2004-06-04T00:45:00Z  1  69  397  SIUE  3  1  465  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rIdeal_Low        \n\r\n\rIdeal low pass filter        \n\r\n\rFunction Prototype        \n\r\n\rIdeal_Low([in] long* image,[in] long         block_size, [in] long      dc,  [in] long cutoff,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to the result image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rInput image        \n\r\n\rblock_size      \n\r\n\rlong      \n\r\n\rblock size of the filter        \n\r\n\rdc      \n\r\n\rlong      \n\r\n\rif keep the dc        \n\r\n\rcutoff      \n\r\n\rlong      \n\r\n\rcutoff frequency for the lowpass filter        \n\r\n\rDescription        \n\r\n\rIdeal low pass filter        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Ideal_Low","scr\\COM_HELP/Ideal_Low.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:08:00Z  2003-11-04T17:43:00Z  1  77  439  Westar  3  1  515  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rIfft_Transform        \n\r\n\rperforms an inverse fast Fourier transform        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Ifft_Transform([in] long* image,[in] long block_size,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rblock_size      \n\r\n\rLong    block size used for forward transform      \n\r\n\rDescription      This function performs an inverse fast Fourier transform  on     an image that has previously had a forward FFT performed.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Ifft_Transform","scr\\COM_HELP/Ifft_Transform.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:29:00Z  2004-06-04T00:29:00Z  1  100  574  SIUE  4  1  673  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rIgs_Segment        \n\r\n\rimproved gray-scale quantization        \n\r\n\rFunction Prototype        \n\r\n\rIgs_Segment([in] long* image,[in] long gray_level,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an Image        \n\r\n\rgray_level      \n\r\n\rlong      \n\r\n\rgray level of the output image        \n\r\n\rDescription        \n\r\n\rThis function remaps (quantizes) an image  to a user-specified number of gray levels to overcome the false contouring  present in uniform quantization. It uses improved gray-scale (igs_segment) quantization introduced on page 318 of the  following book: Digital Image Processing, R.C.Gonzalez  &amp; R.Woods, Addison-Wesley, 1992.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Igs_Segment","scr\\COM_HELP/Igs_Segment.html","   Hari   hari  26  14  2003-11-04T16:52:00Z  2010-03-19T19:59:00Z  1  144  821  SIUE  6  1  964  11.5606    120  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                                  \n\r\n\rName      \n\r\n\rImproved_Mmse_Filter        \n\r\n\rImproved Adaptive Minimum Mean  Squared Error Filter        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Improved_Mmse_Filter([in] long*  image,[in] float threshval,[in] long kernel_size,[in] float noise_var,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to the processed image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong*      \n\r\n\rpointer to an Image        \n\r\n\rDescription        \n\r\n\rThe Improved_Mmse_Filter  makes use of the local variance to determine  \n\r\n\r     if   a mean filter is to be applied to the local region of an  \n\r\n\r     image.  It works best for short tail additive type  noise.  \n\r\n\r&nbsp;  \n\r\n\r     The adaptive MMSE filter is based on the  following equation:  \n\r\n\r&nbsp;  \n\r\n\r                                    (sigma_n)^2                     \n\r\n\r     MMSE = d(r,c)  -     ------------         | d(r,c) -  ml(r,c) |  \n\r\n\r                                    (sigma_l)^2    \n\r\n\r&nbsp;  \n\r\n\r     where ml is the local mean, sigma_n is the   noise  variance,  \n\r\n\r     and sigma_l is the local variance.  \n\r\n\r&nbsp;        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Improved_Mmse_Filter","scr\\COM_HELP/improved_Mmse_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:18:00Z  2004-06-04T00:18:00Z  1  46  268  SIUE  2  1  313  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rInput_Mesh        \n\r\n\rGet the Mesh array to the image        \n\r\n\rFunction Prototype        \n\r\n\rInput_Mesh([in] long * mesh_array,[out,  retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rmesh_array      \n\r\n\rlong *      \n\r\n\rmesh array        \n\r\n\rDescription        \n\r\n\rGet the Mesh array to the image        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Input_Mesh","scr\\COM_HELP/Input_Mesh.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T01:13:00Z  2004-06-04T01:13:00Z  1  64  370  SIUE  3  1  433  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rIntensity_Slicing        \n\r\n\rIntensity Slicing        \n\r\n\rFunction Prototype        \n\r\n\rIntensity_Slicing([in] long *inputImage,[in] long *lookupTable, [in]  long options, [out,retval] long *Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong*      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong*      \n\r\n\rThe input image        \n\r\n\rlookupTable      \n\r\n\rlong*      \n\r\n\rThe pointer to the lookup table structure        \n\r\n\roptions      \n\r\n\rlong      \n\r\n\rthe options        \n\r\n\rDescription        \n\r\n\rIntensity Slicing        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Intensity_Slicing","scr\\COM_HELP/Intensity_Slicing.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:16:00Z  2003-11-04T17:43:00Z  1  141  808  Westar  6  1  948  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rInverse_Xformfilter        \n\r\n\rperforms inverse filtering        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Inverse_Xformfilter([in] long* image,[in] long*  image1,[in] long choice,[in] double cutoff,[out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rimage1      \n\r\n\rlong *    pointer to the numerator, the degraded image      \n\r\n\rchoice      \n\r\n\rlong     sets the maximum gain using the DC  value  as  a     baseline&nbsp;      \n\r\n\rcutoff      \n\r\n\rlong     cutoff frequency&nbsp;      \n\r\n\rDescription      This function performs an inverse filter, a frequency domain     filter defined:                                     G(u,v)                            F(u,v) = ------                                     H(u,v)     where F(u,v) is the Fourier transform of the restored image,     G(u,v)  is  the Fourier transform of the degraded image, and     H(u,v) is the Fourier transform of the degradation function.&nbsp;&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Inverse_Xformfilter","scr\\COM_HELP/Inverse_Xformfilter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:02:00Z  2004-06-04T00:02:00Z  1  89  511  SIUE  4  1  599  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rIpct        \n\r\n\rperforms the inverse principal components transform.        \n\r\n\rFunction Prototype        \n\r\n\rIpct([in] long* image,    [in] long is_mask, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to Image structure        \n\r\n\ris_mask      \n\r\n\rlong      \n\r\n\rwhether to ignore a background color  (CVIP_YES or CVIP_NO)        \n\r\n\rDescription        \n\r\n\rPerforms the prinicipal  components transform (PCT) on &lt;srcImage&gt;. The  resultant image contains a set of decorrelated data  bands in which the first band is the most discriminant,  then the second band, and so on.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Ipct","scr\\COM_HELP/Ipct.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:34:00Z  2004-06-03T23:34:00Z  1  102  588  SIUE  4  1  689  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rIrregular        \n\r\n\rcalculates irregularity ratio        \n\r\n\rFunction Prototype        \n\r\n\rIrregular([in] long* image,[in] int r, [in] int c, [out,retval] long* Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong *      \n\r\n\rA value of type double: aspect ratio        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rPointer to the labeled image        \n\r\n\rr      \n\r\n\rint      \n\r\n\rrow coordinate of a point on the labeled  image        \n\r\n\rc      \n\r\n\rint      \n\r\n\rcolumn coordinate of a point on the labeled  image        \n\r\n\rDescription        \n\r\n\rThis function calculates the irregularity  ratio of an object of interest on the labeled image. The formula used is:  \n\r\n\rirregularity ratio =  (perimeter^2)/4*PI*area  \n\r\n\rWhere area is area of the binary object,  and perimeter is the length of outer edge of the object.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Irregular","scr\\COM_HELP/Irregular.html","   ACADEMIC COMPUTING  Normal  P!Nk  7  6  2009-12-28T20:48:00Z  2009-12-28T20:54:00Z  2  165  942  SIUE  7  2  1105  12.00    120  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                                   \n\r\n\rName      \n\r\n\rJp2_Compress        \n\r\n\rJoint Photographic Experts Group(JPEG2000)  image compression scheme        \n\r\n\rFunction Prototype        \n\r\n\rJp2_Compress(/*[ in ]*/  BSTR *File_Name, /*[ in ]*/ long* Input_image, /*[in ]*/ int rate, /*[in]*/ int  quality, /*[in]*/ int numberoflayers, /*[in]*/ int block_size );        \n\r\n\rReturn Value        \n\r\n\rNone      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rrate      \n\r\n\rint      \n\r\n\rCompression ratio that is to be achieved at  the end of  \n\r\n\rcompression.        \n\r\n\rquality      \n\r\n\rint      \n\r\n\rQuality ratio that is to be achieved during  compression.        \n\r\n\rnumberoflayers      \n\r\n\rint      \n\r\n\rNumber of resolution or the number of  decomposition layers for the discrete wavelet transform.        \n\r\n\rblock_size      \n\r\n\rint      \n\r\n\rCode-block size that is to be used during  compression.        \n\r\n\rDescription      JPEG2000 is a wavelet-based image compression standard and coding system. It was created by the Joint Photographic Expert Group committee in the year 2000 with the intention of supersending their original discrete cosine transform-based JPEG standard. JPEG2000 can achieve both lossy and loseless image compression.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Jp2_Compress","scr\\COM_HELP/Jp2_Compress.html","   ACADEMIC COMPUTING  Normal  P!Nk  3  1  2009-12-28T20:54:00Z  2009-12-28T20:55:00Z  1  113  648  SIUE  5  1  760  12.00    120  Clean  Clean  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                                   \n\r\n\rName      \n\r\n\rJpg_Decompress        \n\r\n\rJoint Photographic Experts Group(JPEG)  image compression scheme        \n\r\n\rFunction Prototype        \n\r\n\rJpg_Decompress([ in ] BSTR *File_Name, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rreturned pointer to the uncompressed image  structure, a valid Image pointer on success, a NULL pointer on failure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rDescription        \n\r\n\rJPEG2000 is a wavelet-based image compression standard  and coding system. It was created by the Joint Photographic Expert Group  committee in the year 2000 with the intention of supersending  their original discrete cosine transform-based JPEG standard. JPEG2000 can  achieve both lossy and loseless  image compression.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Jp2_Decompress","scr\\COM_HELP/Jp2_Decompress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:20:00Z  2004-06-03T23:20:00Z  1  405  2312  SIUE  19  5  2712  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rJpg_Compress        \n\r\n\rJoint Photographic Experts Group(JPEG)  image compression scheme        \n\r\n\rFunction Prototype        \n\r\n\rJpg_Compress([ in ] BSTR *File_Name, [in] long* Input_image,[in ] int quality,  [in] long grayscale, [in] long optimize, [in] int  smooth, [in] long verbose, [in]BSTR *qtablesFile);        \n\r\n\rReturn Value        \n\r\n\rNone      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rquality      \n\r\n\rint      \n\r\n\rScale quantization tables to adjust image  quality. Quality is 0 (worst) to 100 (best); default is 75. (See below for  more info.)        \n\r\n\rgrayscale      \n\r\n\rlong      \n\r\n\rCreate monochrome JPEG file from color input.  Be sure to use this switch when compressing a grayscale GIF file, because cjpeg isn\'t bright enough to notice whether a GIF file  uses only shades of gray. By saying -grayscale, you\'ll get a smaller JPEG  file that takes less time to process.        \n\r\n\roptimize      \n\r\n\rlong      \n\r\n\rPerform optimization of entropy encoding  parameters. Without this, default encoding parameters are used. -optimize  usually makes the JPEG file a little smaller, but cjpeg  runs somewhat slower and needs much more memory. Image quality and speed of  decompression are unaffected by -optimize.        \n\r\n\rsmooth      \n\r\n\rint      \n\r\n\rSmooth the input image to eliminate  dithering noise. N, ranging from 1 to 100, indicates the strength of  smoothing. 0 (the default) means no smoothing.        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rEnable debug printout. More -v\'s give more printout. Also, version information is  printed at startup.        \n\r\n\rqtablesFile      \n\r\n\rBSTR      \n\r\n\rUse the quantization tables given in the  specified file. The file should contain one to four tables (64 values each)  as plain text. Comments preceded by \'#\' may be included in the file. The  tables are implicitly numbered 0,1,etc. If -quality  N is also specified, the values in the file are scaled accordingto  cjpeg\'s quality scaling curve.        \n\r\n\rDescription        \n\r\n\rJPEG (pronounced &quot;jay-peg&quot;) is a  standardized image compression mechanism. JPEG stands for Joint Photographic  Experts Group, the original name of the committee that wrote the standard.  JPEG is designed for compressing either full-color  or gray-scale images of natural, real-world scenes. JPEG is &quot;lossy&quot; meaning that the decompressed image isn\'t  quite the same as the one you started with. JPEG is designed to exploit known  limitations of the human eye, notably the fact that small color changes are  perceived less accurately than small changes in brightness. A useful property  of JPEG is that the degree of lossiness can be  varied by adjusting compression parameters. This means that the image maker  can trade off file size against output image quality. The function code is  based on BETA TEST release 6a of 7-Feb-96, the Independent JPEG Groups free JPEG software.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Jpg_Compress","scr\\COM_HELP/Jpg_Compress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:21:00Z  2004-06-03T23:21:00Z  1  382  2178  SIUE  18  5  2555  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rJpg_Decompress        \n\r\n\rJoint Photographic Experts Group(JPEG)  image compression scheme        \n\r\n\rFunction Prototype        \n\r\n\rJpg_Decompress([ in ] BSTR *File_Name, int  colors, [in] long blocksmooth, [in] long grayscale,  [in] long nodither, [in] long verbose, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rreturned pointer to the uncompressed image  structure, a valid Image pointer on success, a NULL pointer on failure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rcolors      \n\r\n\rint      \n\r\n\rReduce image to at most N colors. This  reduces the number of colors used in the output image, so that it can be displayed  on a colormapped display or stored in a colormapped file format. For example, if you have an  8-bit display, you\'d need to reduce to 256 or fewercolors.  (-colors is the recommended name, -quantize is provided only for backwards  compatibility.)        \n\r\n\rblocksmooth      \n\r\n\rlong      \n\r\n\rPerform cross-block smoothing. This is  slow, quite memory-intensive, and only seems to improve the image at very low  quality settings (-quality 10 to 20 or so). At normal quality settings it may  make things worse.        \n\r\n\rgrayscale      \n\r\n\rlong      \n\r\n\rForce gray-scale output even if JPEG file  is color. Useful for viewing on monochrome displays.        \n\r\n\rnodither      \n\r\n\rlong      \n\r\n\rDo not use dithering in color quantization.  By default, Floyd-Steinberg dithering is applied when quantizing colors, but  on some images dithering may result in objectionable &quot;graininess&quot;.  If that happens, you can turn off dithering with -nodither.  -nodither is ignored unless you also say -colors N.        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rEnable debug printout. More -v\'s give more printout. Also, version information is  printed at startup.        \n\r\n\rDescription        \n\r\n\rJPEG (pronounced &quot;jay-peg&quot;) is a  standardized image compres sion  mechanism. JPEG stands for Joint Photographic Experts Group, the original  name of the committee that wrote the standard. JPEG is designed for  compressing either full-color or gray-scale images  of natural, real-world scenes. JPEG is &quot;lossy,&quot;  meaning that the decompressed image isn\'t quite the same as the one you  started with. JPEG is designed to exploit known limitations of the human eye,  notably the fact that small color changes are perceived less accurately than  small changes in brightness. A useful property of JPEG is that the degree of lossiness can be varied by adjusting compression  parameters. This means that the image maker can trade off file size against  output image quality. The function code is based on BETA TEST release 6a of 7-Feb-96, the Independent JPEG Groups free JPEG software.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Jpg_Decompress","scr\\COM_HELP/Jpg_Decompress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:31:00Z  2004-06-03T23:32:00Z  1  99  565  SIUE  4  1  663  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rJpgtocvip        \n\r\n\rConvert Image format from JPEG to CVIP        \n\r\n\rFunction Prototype        \n\r\n\rJpgtocvip([ in ] BSTR *File_Name, [ in ] int colors, [ in ] long blocksmooth,  [ in ] long grayscale, [ in ] long nodither, [ in ]  long verbose,[out, retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to result image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rcolors      \n\r\n\rint      \n\r\n\r(reference JPEG help)        \n\r\n\rblocksmooth      \n\r\n\rlong      \n\r\n\r(reference JPEG help)        \n\r\n\rgrayscale      \n\r\n\rlong      \n\r\n\r(reference JPEG help)        \n\r\n\rnodither      \n\r\n\rlong      \n\r\n\r(reference JPEG help)        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\r(reference JPEG help)        \n\r\n\rDescription        \n\r\n\rConvert Image format from JPEG to CVIP        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Jpgtocvip","scr\\COM_HELP/Jpgtocvip.html","   ACADEMIC COMPUTING  Normal  akharba  21  10  2005-07-02T23:05:00Z  2006-08-11T22:33:00Z  1  347  1983  SIUE  16  4  2326  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4        \n\r\n\rName      \n\r\n\rK_Nearest_Neighbor      finds the kth nearest neighbor using a distance or similarity measure  \n\r\n\r&nbsp;        \n\r\n\rFunction Prototype        \n\r\n\r HRESULT K_Nearest_Neighbor([in]  BSTR* TestFile, [in] BSTR* TrainingFile,  [in] BSTR* OutputFile,   \n\r\n\r [in]  int normalize,   [in] int   distance_similarity,  [in] int k,  [in] float   s_min, [in]float s_max,  [in] float r_softmax,  \n\r\n\r [in]  float r_minkowski, [out,retval]  long *ErrorCode)        \n\r\n\rReturn Value        \n\r\n\rErrorCode      \n\r\n\rlong*      \n\r\n\rPointer to the error code        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rTestFile      \n\r\n\rBSTR*      \n\r\n\rPointer to test (text) file        \n\r\n\rTrainingFile      \n\r\n\rBSTR*      \n\r\n\rPointer to training (text) file        \n\r\n\rOutputFile      \n\r\n\rBSTR*      \n\r\n\rPointer to&nbsp;output (text) file        \n\r\n\rnormalize  \n\r\n\rdistance_similarity  \n\r\n\r         k   \n\r\n\r         s_min  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rs_max  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rr_softmax  \n\r\n\r&nbsp;  \n\r\n\rr_minkowski           \n\r\n\rint  \n\r\n\rint  \n\r\n\rint  \n\r\n\rfloat  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rfloat  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rfloat  \n\r\n\r&nbsp;  \n\r\n\rfloat      \n\r\n\rNormalization method used  \n\r\n\rDistance measure used  \n\r\n\r        K for kth nearest  neighbor  \n\r\n\r        Minimum value for the   \n\r\n\r       specified range (min-max norm.  \n\r\n\r     only);  else use  -1  \n\r\n\r     Maximum value for the  specified   \n\r\n\r     range (min-max norm. only);    \n\r\n\r     else use  -1  \n\r\n\r    Used with softmax scaling only;   \n\r\n\r    else use  -1  \n\r\n\r    Used with minkowski distance only; else use  -1  \n\r\n\r&nbsp;  &nbsp;      \n\r\n\rDescription       This function finds the \'K\' (\'K\' is an integer) closest matches using a given distance or similarity measure and then classifies the unknown with the class that appears most often in this set of K samples.&nbsp;     Values to be used for:              normalize:                 0 – No Normalization        1 – Range-normalize        2 – Unit Vector normalization        3 – Standard Normal Density normalization        4 – Min-max normalization        5 – Softmax scaling              distance_similarity:                 1 – Euclidean Distance        2 – City block or Absolute value metric        3 – Maximum value metric        4 – Minkowski distance        5 – Vector inner product        6 – Tanimoto metric&nbsp;     Error Codes:&nbsp;1: The headers in the training and test files don\'t match 2: K is greater than the number of entries in the training setor K&lt;=0 3: s_min is greater than or equal to s_max 4: Data range is 0 and so the data can\'t be normalized 5: Divisor is 0 in Tanimoto similarity measure 7: Can\'t open, read or create file 9: Memory allocation error 10: Every entry in training set should have a class name 12: r in minkowski should be a positive integer 13: There is more than one header in the training or test feature file  \n\r\n\r&nbsp;     \n\r\n\r&nbsp;        \n\r\n\rBugs                 \n\r\n\r&nbsp;\n\r\n\r&nbsp;","K_Nearest_Neighbor","scr\\COM_HELP/K_Nearest_Neighbor.htm","   ACADEMIC COMPUTING  jhansi  4  9  2009-09-17T22:40:00Z  2010-01-06T21:30:00Z  1  146  838  SIUE  6  1  983  11.9999    140  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                                  \n\r\n\rName      \n\r\n\rKirsch_Filter        \n\r\n\rperform kirsch edge detection        \n\r\n\rFunction Prototype        \n\r\n\rKirsch_Filter([in] long* image, [in] long* dirImage, [in]  long mask_choice, [in] long mask_size, [in] long keep_dc, [in] long threshold,[out,retval] long*  Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rdirImage      \n\r\n\rlong *      \n\r\n\rPointer to the direction image        \n\r\n\rmask_choice      \n\r\n\rlong      \n\r\n\rtype of smoothing filter        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rKernel Size        \n\r\n\rkeep_dc      \n\r\n\rlong      \n\r\n\r0 (no) or 1 (yes)        \n\r\n\rthreshold      \n\r\n\rlong      \n\r\n\rvalue for binary threshold        \n\r\n\r&nbsp;      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\r&nbsp;      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\r&nbsp;      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rDescription        \n\r\n\rThis function applies kirsch edge detection  algorithms to &lt;imageP&gt;.   \n\r\n\r If a  smoothing filter is desired as a preprocessing step, set &lt;mask_choice&gt; to:  \n\r\n\r 1 =  Gaussian blur  \n\r\n\r 2 =  generic lowpass 1  \n\r\n\r 3 =  generic lowpass 2  \n\r\n\r 4 =  neighborhood average  \n\r\n\r For  &lt;mask_size&gt;: set mask size to any desired kernel size  \n\r\n\r&nbsp;  \n\r\n\rNOTE: FOR ALL OF THE ABOVE PARAMETERS, USE  THE VALUE -1 FOR ANY PARAMETER NOT NEEDED.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","Kirsch_Filter","scr\\COM_HELP/kirsch_Filter.html","   ACADEMIC COMPUTING  jhansi  7  5  2004-06-04T00:39:00Z  2010-01-06T21:29:00Z  1  91  519  SIUE  4  1  609  11.9999    Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                                  \n\r\n\rName      \n\r\n\rKuwahara_Filter        \n\r\n\rAn edge preserving filter        \n\r\n\rFunction Prototype        \n\r\n\rKuwahara_Filter([in] long* image,[in] long  mask_size,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rsize of the filtering window (e.g., 3-&gt; 3x3).        \n\r\n\rDescription        \n\r\n\rKuwahara Filter works by partitioning the N  x N filter window in to four regions. In each of the four regions mean and  variance are measured. The center pixel value is replaced with the mean value  of the region that has the smallest variance.         \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Kuwahara_Filter","scr\\COM_HELP/kuwahara_Filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:35:00Z  2004-06-03T23:35:00Z  1  48  279  SIUE  2  1  326  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rLabel        \n\r\n\rlabels objects        \n\r\n\rFunction Prototype        \n\r\n\rLabel([in] long* image,[out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rA labeled image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rPointer to the input image        \n\r\n\rDescription        \n\r\n\rThis function calls the function label_Objects (from libobject).        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Label","scr\\COM_HELP/Label.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T17:17:00Z  2003-11-04T17:44:00Z  1  182  1041  Westar  8  2  1221  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rLeast_Squares      performs least_squares restoration filtering  \n\r\n\r&nbsp;        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Least_Squares([in] long* image,[in] long* image1,[in]  long* image2,[in] double gamma,[in] long choice,[in] long cutoff,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rImage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rImage1      \n\r\n\rlong *    pointer to the degradation function      \n\r\n\rImage2      \n\r\n\rlong *    pointer  to  smoothness  criterion  function     image, P(u,v)&nbsp;      \n\r\n\rGama      \n\r\n\rlong     gamma in least_squares equation.&nbsp;      \n\r\n\rChoice      \n\r\n\rlong     sets the maximum gain using the DC  value  as  a     baseline&nbsp;      \n\r\n\rCutoff      \n\r\n\rlong     cutoff frequency&nbsp;&nbsp;      \n\r\n\rDescription      This function performs an inverse filter, a frequency domain     filter defined:                                            G(u,v)               F(u,v) = --------------------------------                                        2                 H(u,v) + gamma*(Pfn)&nbsp;     where F(u,v) is the Fourier transform of the restored image,     G(u,v)  is  the Fourier transform of the degraded image, and     H(u,v) is the Fourier transform of the degradation function.     Pfn is an approximation of the noise-to-power ratio.&nbsp;&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Least_Squares","scr\\COM_HELP/Least_Squares.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  5  2006-02-11T17:48:00Z  2006-02-14T06:25:00Z  1  83  478  SIUE  3  1  560  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rLocal_Adaptive_Zoom        \n\r\n\rEnlarges the image to its double size        \n\r\n\rFunction Prototype        \n\r\n\rLocal_Adaptive_Zoom([in] long* image,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\ra pointer to an Image structure        \n\r\n\rDescription        \n\r\n\rThis will  allow you to double the size of an image. This function is an implementation  of the algorithm in “S. Battiato, G. Gallo, F. Stanco,  A locally adaptive zooming algorithm for digital images, Image and Vision  Computing 20 (2002) 805 – 812”.        \n\r\n\rBugs        \n\r\n\rNone   \n\r\n\r&nbsp;","Local_Adaptive_Zoom","scr\\COM_HELP/Local_Adaptive_Zoom.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:51:00Z  2004-06-03T23:51:00Z  1  127  724  SIUE  6  1  850  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rLocal_Histeq        \n\r\n\rperforms histogram equalization on  block-by-block basis        \n\r\n\rFunction Prototype        \n\r\n\rLocal_Histeq([in] long* image,[in] int  size, [in] int mb,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rsize      \n\r\n\rint      \n\r\n\rdesired blocksize        \n\r\n\rmb      \n\r\n\rint      \n\r\n\rRGB band on which to calculate histogram  (0,1,2)        \n\r\n\rDescription        \n\r\n\rThis function performs histogram equalization  on local areas of an image rather than on the image as a whole. The user may  specify the size of blocks to use. By performing local rather than global  histeq, detail can often be enhanced in large uniform areas of an image.  \n\r\n\rThe function will remap any CVIP_INTEGER,  CVIP_FLOAT or CVIP_DOUBLE image into CVIP_SHORT. It operates directly on  images of type CVIP_SHORT and CVIP_BYTE.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Local_Histeq","scr\\COM_HELP/Local_Histeq.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:29:00Z  2003-11-04T17:44:00Z  1  185  1055  Westar  8  2  1238  10.2625    Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rLog_Ace_Filter        \n\r\n\ran Adaptive Contrast Enhancement filter        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT  Log_Ace_Filter([in] long* image,[in] long wsize,[in]double alpha, [in] double  beta,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rSize      \n\r\n\rLong    mask size (3,5,7,9,...)      \n\r\n\rAlpha      \n\r\n\rDouble    local mean      \n\r\n\rBeta      \n\r\n\rDouble    Local gain factor      \n\r\n\rDescription      log_ACE\'s algorithms are able to enhance  the  contrast  and     dynamic  range of the image. log_ACE\'s algorithm uses linear     brightness stretching to modify  the  dynamic  range  of  an     image.  For  more  detail, see reference &quot;The Study of Loga-     rithmic Image Processing Model and Its Application to  Image     Enhancement&quot; by G.Deng, L.W. Cahill and G.R. Tobin.&nbsp;      output = k1*[ln(Ibar(r,c)-ln(m_lbar(r,c))] + k2*m_lbar(r,c)&nbsp;      where:      m_lbar = 1-m_l(r,c)/M, normalized complement of local mean      Ibar = 1 - I(r,c)/M, normalized complement of image      M = number of gray levels (255)      k1 = Local gain factor (multiplier), between 0 and 1      k2 = Local mean factor (multiplier), between 0 and 1      kernel size = size of local window&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Log_Ace_Filter","scr\\COM_HELP/Log_Ace_Filter.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:28:00Z  2003-11-04T17:44:00Z  1  56  321  Westar  2  1  376  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rLog_Remap        \n\r\n\rLog remap image        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Log_Remap([in] long* image,[in] long band, [out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rDescription      This function return the log remap image. It is useful for the FFT result image.       \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Log_Remap","scr\\COM_HELP/Log_Remap.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:58:00Z  2004-06-03T23:58:00Z  1  48  280  SIUE  2  1  327  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rLogMap_Image        \n\r\n\rlog remap the image        \n\r\n\rFunction Prototype        \n\r\n\rLogMap_Image ([in] long* image,        int         band,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an image        \n\r\n\rband      \n\r\n\rint      \n\r\n\rnumber of band        \n\r\n\rDescription        \n\r\n\rlog remap the image        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","LogMap_Image","scr\\COM_HELP/LogMap_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:06:00Z  2004-06-03T23:07:00Z  1  61  353  SIUE  2  1  413  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rLum_Average        \n\r\n\rcreates a grayscale from a multiband image        \n\r\n\rFunction Prototype        \n\r\n\rLum_Average([in] long* image,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to newly allocated Image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rDescription        \n\r\n\rPerforms a luminance transform according to  the formula  \n\r\n\r P =  (band_1 + band_2 + ... + band_n)/n        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Lum_Average","scr\\COM_HELP/Lum_Average.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:05:00Z  2004-06-03T23:06:00Z  1  65  372  SIUE  3  1  436  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rLuminance_Image        \n\r\n\rcreates a grayscale image from a color  image        \n\r\n\rFunction Prototype        \n\r\n\rLuminance_Image([in] long* image,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to newly allocated Image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rPointer to grayscale image        \n\r\n\rDescription        \n\r\n\r Performs an RGB to luminance transform  according to the formula  \n\r\n\r P =  0.299 r + 0.587 g + 0.114 b.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Luminance_Image","scr\\COM_HELP/Luminance_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:22:00Z  2004-06-04T00:22:00Z  1  109  624  SIUE  5  1  732  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMake_Histogram        \n\r\n\rcreates an image from a histogram        \n\r\n\rFunction Prototype        \n\r\n\rMake_Histogram([in]double* sped_in,[in]long  image_format, [in] long color_format, [in] long bands,[out, retval] long*  Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rsped_in      \n\r\n\rdouble *      \n\r\n\ra 2-D float array of the histogram data;        \n\r\n\rimage_format      \n\r\n\rlong      \n\r\n\rthe Image format of the resulting image;        \n\r\n\rcolor_format      \n\r\n\rlong      \n\r\n\rthe Color format of the resulting image        \n\r\n\rDescription        \n\r\n\rmake_histogram generates an image of a  histogram. The image type and color space is defined by image_format and  image_format. The Image* returned is that of a histogram, which is passwd to  the function in a variable of type float**.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Make_Histogram","scr\\COM_HELP/Make_Histogram.html","   ACADEMIC COMPUTING  Normal  jhansi  21  26  2004-07-05T20:18:00Z  2010-01-06T21:29:00Z  1  87  501  SIUE  4  1  587  11.9999    BestFit  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                                  \n\r\n\rName      \n\r\n\rMarr_Hildreth_Filter      performs a Marr Hildreth edge detection on the image      \n\r\n\rFunction Prototype        \n\r\n\rMarr_Hildreth_Filter([in]  long* image, [in] float sigma, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an input Image structure      \n\r\n\rsigma      \n\r\n\rfloat    Sigma value      \n\r\n\rDescription        \n\r\n\rMarr-Hildreth  Filter works by performing three steps:  \n\r\n\r1. Convolve the  image with a Gaussian smoothing filter  \n\r\n\r2. Convolve the  image with a Laplacian mask  \n\r\n\r3. Find the zero  crossings of the image from Step 2.  &nbsp;      \n\r\n\rBugs        \n\r\n\rNone.               \n\r\n\r&nbsp;","Marr_Hildreth_Filter","scr\\COM_HELP/marr_Hildreth_Filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:39:00Z  2004-06-04T00:39:00Z  1  104  595  SIUE  4  1  698  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMaximum_Filter        \n\r\n\rTypically applied to an image to remove  negative outlier noise.        \n\r\n\rFunction Prototype        \n\r\n\rMaximum_Filter([in] long* image,[in] long mask_size,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rNxN is the size of the filtering window.        \n\r\n\rDescription        \n\r\n\rReturns the maximum value of the set of pixels  contained in the N x N filter window. Size of filter should be an odd integer  limited from &lt; 3 31 &gt;.  \n\r\n\rWorks best on images containing negative  outlier noise. This filter will brighten the appearance of the image. Keep  mask size small to minimize blurring.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Maximum_Filter","scr\\COM_HELP/Maximum_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:39:00Z  2004-06-04T00:39:00Z  1  87  496  SIUE  4  1  582  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMean_Filter        \n\r\n\rfiltering operation used on an image to  remove short tailed noise such as uniform and gaussian noises.        \n\r\n\rFunction Prototype        \n\r\n\rMean_Filter([in] long* image,[in] long  mask_size,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rsize of the filtering window (e.g., 3-&gt;  3x3).        \n\r\n\rDescription        \n\r\n\rReturns the average value of the set of  pixels contained in the N x N filter window. The filter size should be an odd  integer limited from &lt; 3 31&gt;.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Mean_Filter","scr\\COM_HELP/Mean_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:30:00Z  2004-06-04T00:30:00Z  1  158  903  SIUE  7  2  1059  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMedian_Cut_Segment        \n\r\n\rfunction to map 24-bits-per-pixel images to  2-bits-per-pixel        \n\r\n\rFunction Prototype        \n\r\n\rMedian_Cut_Segment([in] long* image,[in] long newcolors, [in]  long is_bg, [in] long r_bg,  [in] long g_bg, [in] long b_bg,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rnewcolors      \n\r\n\rlong      \n\r\n\rdesired number of colors        \n\r\n\ris_bg      \n\r\n\rlong      \n\r\n\ris background color?        \n\r\n\rr_bg      \n\r\n\rlong      \n\r\n\rRed background color        \n\r\n\rg_bg      \n\r\n\rlong      \n\r\n\rGreen background color        \n\r\n\rb_bg      \n\r\n\rlong      \n\r\n\rblue background color        \n\r\n\rDescription        \n\r\n\rThis function is usually used in conjunction  with the Principal Components Transform (PCT) in segmenting color images. It  performs data compression from 24 bits-per-pixel to an average of 2  bits-per-pixel. Median cut attempts to make a histogram of the original image  without clustering. New colormaps are generated  iteratively until at most 15 colors have been chosen. When is_bg is CVIP_YES, the background color specified in  &quot;bg&quot; is not considered in the median_cut process.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Median_Cut_Segment","scr\\COM_HELP/Median_Cut_Segment.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:40:00Z  2004-06-04T00:40:00Z  1  90  517  SIUE  4  1  606  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMedian_Filter        \n\r\n\rA fast median filter using the histogram  method.        \n\r\n\rFunction Prototype        \n\r\n\rMedian_Filter([in] long* image,[in] long  mask_size,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rmask size (3,5,7,9,...)        \n\r\n\rDescription        \n\r\n\rThe function median_filter uses a histogram  method to perform a fast median filter on an input image, using a square mask  of user-determined dimension. The filter operates on the histogram of the  masked area, rather than on the image directly.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Median_Filter","scr\\COM_HELP/Median_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:19:00Z  2004-06-04T00:19:00Z  1  91  523  SIUE  4  1  613  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMesh_To_File        \n\r\n\rsave a mesh structure to a file        \n\r\n\rFunction Prototype        \n\r\n\rMesh_To_File([ in ] BSTR *File_Name, [in] long* pmesh);        \n\r\n\rReturn Value        \n\r\n\rNone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR *      \n\r\n\rFile name to store mesh        \n\r\n\rpmesh      \n\r\n\rlong *      \n\r\n\rmesh pointer        \n\r\n\rDescription        \n\r\n\rThe mesh_to_file() saves a mesh  structure to a file. The first 2 integers saved are the numbers of columns  and rows of the mesh. And then the coordinates of each node in the mesh is  saved node by node from the left to the right and row by row from the top to  the bottom. The character string &quot;mesh_file&quot;  holds the mesh file name.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Mesh_To_File","scr\\COM_HELP/Mesh_To_File.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:19:00Z  2004-06-04T00:20:00Z  1  402  2292  SIUE  19  5  2689  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMesh_Warping        \n\r\n\rcalculates thinness ratio        \n\r\n\rFunction Prototype        \n\r\n\rMesh_Warping([in] long* image,[in] long* pmesh, [in]  long method,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rpmesh      \n\r\n\rlong *      \n\r\n\rMesh pointer        \n\r\n\rmethod      \n\r\n\rlong      \n\r\n\rmethod to use        \n\r\n\rDescription        \n\r\n\rThe mesh_warping() performs: 1. a spatial  transformation. The function takes the usually (not necessarily) irregular  input mesh structure and creates a regular mesh. The regular mesh consists of  the same number of columns and same number of rows as the input mesh, and all  the cells of the regular mesh are rectangulars. The  regular mesh covers the whole output image. The function goes through the  rectangular regions one by one. For each of the rectangular region, the  function gets the corresponding quadrilateral region in the input image. The  4 corners of the current rectangular region and the 4 corners of the  corresponding quadrilateral region are tiepoints.  The geometric distortion process within the quadrilateral regions is modeled  by a pair of bilinear equations:   \n\r\n\rr(x,y) = c1*x +  c2*y + c3*x*y + c4 s(x,y) = c5*x + c6*y + c7*x*y +  c8  \n\r\n\r If (x,y) is a pixel in the output  image, (r,s) is (x,y)\'s  corresponding pixel in the input image. Using the 8 tiepoints,  the equations can be solved for the 8 coefficients ci,  i = 1,2, ...,8 for the  current set of tiepoints. Using the set of 8  coefficients, for each (x,y)  in the current rectangular region, the function can computes its  corresponding pixel (r,s) in the input image. If  both &quot;r&quot;, &quot;s&quot; are integers, then (r,s)\'s gray value is given to (x,y)  in the output image. If any one of &quot;r&quot;, &quot;s&quot; is not an  integer, (x,y)\'s gray  value is determined with a gray-level interpolation method.  \n\r\n\r 2. a gray-level interpolation: The integer &quot;method&quot;  specifies 1 of 3 gray value interpolation methods: 1. nearest neighbor 2. bilinear    \n\r\n\r3. average of  neighbors The input mesh structure is pointed to by &quot;inmesh&quot;.  The mesh_warping_ri() is similar to the mesh_warping(),  but the mesh for the output image can be a irregular one and from this  irregular mesh a regular mesh is generated for the input image. The function  finds out if each pixel is in a certain quadilateral  region in the output image or not. Spatial transformations and gray-level  interpolations are performed between each quadrilateral region in the output  image and its corresponding region in the input image. In the output image,  if one pixel can\'t find a corresponding pixel from the input image, zero_out determines whether the output pixel will use  zero or just copy the same row/column pixel from the input image.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Mesh_Warping","scr\\COM_HELP/Mesh_Warping.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:44:00Z  2003-11-04T17:44:00Z  1  468  2672  Westar  22  6  3134  10.2625    Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMesh_WarpingIR      mesh_warp an image, with regular or irregular input and out-     put mesh.  \n\r\n\r&nbsp;        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT  Mesh_WarpingRI([in] long* image,[in] long* pmesh, [in] long method, [in] long  zero_out,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rPmesh      \n\r\n\rlong *    Pointer to the mesh      \n\r\n\rMethod      \n\r\n\rLong    Mesh direction      \n\r\n\rDescription      The mesh_warping() performs: 1. a spatial transformation.        The function takes the usually (not necessarily)  irregu-     lar  input  mesh  structure and creates a regular mesh.  The     regular mesh consists of the same number of columns and same     number  of  rows as the input mesh, and all the cells of the     regular mesh are rectangulars.  The regular mesh covers  the     whole output image.        The function goes through the rectangular regions one  by     one.  For  each of the rectangular region, the function gets     the corresponding quadrilateral region in the  input  image.     The  4  corners  of the current rectangular region and the 4     corners  of  the  corresponding  quadrilateral  region   are     tiepoints.  The geometric distortion process within the qua-     drilateral regions is modeled by a pair  of  bilinear  equa-     tions:  r(x,y)  =  c1*x + c2*y + c3*x*y + c4 s(x,y) = c5*x +     c6*y + c7*x*y + c8        If (x,y) is a pixel in the output image, (r,s) is (x,y)\'s     corresponding   pixel  in  the  input  image.  Using  the  8     tiepoints, the equations can be solved  for  the  8  coeffi-     cients ci, i = 1,2, ...,8 for the current set of tiepoints.        Using the set of 8 coefficients, for each  (x,y)  in  the     current  rectangular  region,  the function can computes its     corresponding pixel (r,s) in the input image.  If both  &quot;r&quot;,     &quot;s&quot;  are integers, then (r,s)\'s gray value is given to (x,y)     in the output image.  If any one  of  &quot;r&quot;,  &quot;s&quot;  is  not  an     integer,  (x,y)\'s gray value is determined with a gray-level     interpolation method.&nbsp;     2. a gray-level interpolation:        The integer &quot;method&quot; specifies 1 of 3 gray value interpo-     lation methods:        1. nearest neighbor        2. bilinear        3. average of neighbors&nbsp;        The input mesh structure is pointed to by &quot;inmesh&quot;.&nbsp;     The mesh_warping_ri() is similar to the mesh_warping(),  but     the  mesh  for  the  output image can be a irregular one and     from this irregular mesh a regular mesh is generated for the     input  image.   The function finds out if each pixel is in a     certain quadilateral region in  the  output  image  or  not.     Spatial  transformations  and  gray-level interpolations are     performed between each quadrilateral region  in  the  output     image and its corresponding region in the input image.&nbsp;     In the output image, if one pixel can\'t find a corresponding     pixel  from the input image, zero_out determines whether the     output pixel will use zero or just copy the same  row/column     pixel from the input image.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Mesh_WarpingIR","scr\\COM_HELP/Mesh_WarpingIR.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:40:00Z  2004-06-04T00:40:00Z  1  122  702  SIUE  5  1  823  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMidpoint_Filter        \n\r\n\rtypically used to filter images containing  short tailed noise such as Gaussian and uniform noises.        \n\r\n\rFunction Prototype        \n\r\n\rMidpoint_Filter([in] long* image, [in] long  mask_size, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rsize of the filtering window (e.g.,  3-&gt;3x3).        \n\r\n\rDescription        \n\r\n\rReturns the midpoint value of the set of  pixels contained in the N x N filter window. The filter calculates the  maximum and minimum values in the window and returns their sum divided by 2.  Size of filter should be an odd integer limited from &lt; 3-31 &gt;.  \n\r\n\rWorks best on images containing short  tailed noise such as uniform and Gaussian noise. Keep filter mask small to  minimize blurring.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Midpoint_Filter","scr\\COM_HELP/Midpoint_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:41:00Z  2004-06-04T00:41:00Z  1  95  543  SIUE  4  1  637  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMinimum_Filter        \n\r\n\rtypically applied to an image to remove positive outlier noise.        \n\r\n\rFunction Prototype        \n\r\n\rMinimum_Filter([in] long* image,[in] long mask_size,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rsize of the filtering window (e.g., 3-&gt; 3x3).        \n\r\n\rDescription        \n\r\n\rReturns the minimum value of the set of pixels  contained in the N x N filter window.  \n\r\n\rWorks best on images containing positive  outlier noise. This filter will darken the appearance of the image. Keep mask  size small to minimize blurring.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Minimum_Filter","scr\\COM_HELP/Minimum_Filter.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T16:52:00Z  2003-11-04T17:44:00Z  1  133  761  Westar  6  1  893  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMmse_Filter        \n\r\n\rAdaptive Minimum Mean Squared Error Filter        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Mmse_Filter([in] long* image,[in] double noise_var, [in] long kernel_size,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to the processed image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong*    pointer to an Image      \n\r\n\rDescription      The mmse_filter makes use of the local variance to determine     if  a mean filter is to be applied to the local region of an     image.  It works best for short tail additive type noise.&nbsp;     The adaptive MMSE filter is based on the following equation:&nbsp;                      (sigma_n)^2  /                  \\     MMSE = d(r,c) -  ------------ | d(r,c) - ml(r,c) |                      (sigma_l)^2  \\                  /&nbsp;     where ml is the local mean, sigma_n is the  noise  variance,     and sigma_l is the local variance.  \n\r\n\r&nbsp;        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Mmse_Filter","scr\\COM_HELP/Mmse_Filter.html","   Mounika  Normal  jhansi  19  10  2003-11-04T17:29:00Z  2010-01-06T21:34:00Z  1  110  630  SIUE  5  1  739  11.9999    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4             \n\r\n\rName      \n\r\n\rMoravec_Filter      a spatial- an edge detecting filter      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Moravec_Filter([in] long*  inputImage,[in] float threshval, [out,retval] long*  Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rthreshval      \n\r\n\rfloat    Threshold value    &nbsp;      \n\r\n\rDescription           The Moravec Filter is the simplest corner detector. This is used      to find the points of maximum contrast, which corresponds to potential     corners and sharp edges. This is defined as&nbsp;  \n\r\n\r                                                                                           It finds the average difference between a pixel and its neighbors in all      directions.Then the threshold operation is applied on the image.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Moravec_Filter","scr\\COM_HELP/moravec_Filter.html","   Mounika  Normal  jhansi  36  135  2003-11-04T17:29:00Z  2010-01-06T21:34:00Z  1  156  893  SIUE  7  2  1047  11.9999    125  Clean  Clean    false  false  false                  MicrosoftInternetExplorer4             \n\r\n\rName      \n\r\n\rMorph_Hitmiss      a morphological operation      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT  Morph_Hitmiss([in] long* inputImage, [in] long MaskSize, char* HitmissFilter,  [out, retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rLong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rLong *    pointer to an Image structure      \n\r\n\rMaskSize      \n\r\n\rLong    mask size (3,5,7,9,...)      \n\r\n\rHitmissFilter      \n\r\n\rchar*    Filter Values      \n\r\n\rDescription  \n\r\n\r&nbsp;      The Morph_Hitmiss transform is a morphological operation used for shape detection orpattern recognition. The Hit or Miss operation is performed by translating the center of the structuring element to all points in the image, and then comparing the pixels of the structuring element with the underlying image pixels. If the pixels in the structuring element is set to foreground color, indicating a ‘hit’ otherwise ‘miss’.&nbsp;The structuring element contains 0’s, 1’s and x’s or “don’t care”. Don’t care elements inthe structuring element match with either 0s or 1s. Morph_Hitmiss transform works onlyon binary images.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Morph_Hitmiss","scr\\COM_HELP/morph_hitmiss.html","   Mounika  Normal  Mounika  36  1768  2003-11-04T17:29:00Z  2010-02-05T18:08:00Z  1  225  1286  SIUE  10  3  1508  11.5606    125  Clean  Clean    false  false  false                  MicrosoftInternetExplorer4             \n\r\n\rName      \n\r\n\rMorph_Skeleton      Morphological Operation      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Morph_Skeleton([in] Long* inputImage, [in] Long  FilterDimension, [in] char* SkeletonMatrix, [in] Long Iterations,[in] Long four_eight_mask,  ,[in] Long Method , [out,retval] Long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rLong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rLong *    pointer to an Image structure      \n\r\n\rFilterDimension      \n\r\n\rLong    filter size (3,5,7,9,...)      \n\r\n\rSkeletonMatrix      \n\r\n\rChar*    Filter values      \n\r\n\rIterations      \n\r\n\rLong    Number iterations to be performed      \n\r\n\rFour_eight_mask  \n\r\n\r&nbsp;      \n\r\n\rLong    0-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for four directional mask       1- for eight directional mask      \n\r\n\rMethod  \n\r\n\r&nbsp;      \n\r\n\rLong    0-&nbsp;&nbsp;&nbsp;&nbsp; for AND method       1- for Sequential method      \n\r\n\rDescription  \n\r\n\r&nbsp;      Sleletonization is nothing but repeated thinning. One of the most common uses ofskeletonization is to reduce the thresholded output of an edge detector such as the Sobeloperator to lines of a single pixel thickness.&nbsp;Skeletonization is implemented in two steps. The first step is normal thinning. In this thepixels are marked to remove. In the second step the pixels are removed with outdestroying the connectivity. Skeletonization preserves the topology. The skeletonshould be 8 connected. The skeleton is use ful because it provides a simple andcompact representation of the shape of an object.&nbsp;The structuring element contains 0’s, 1’s and x’s or “don’t care”. Don’t care elements inthe structuring element match with either 0s or 1s. Morph_Skeleton transform works only on binary images.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Morph_Skeleton","scr\\COM_HELP/morph_skeleton.html","   Mounika  Normal  jhansi  30  402  2003-11-04T17:29:00Z  2010-01-06T21:42:00Z  1  150  856  SIUE  7  2  1004  11.9999    125  Clean  Clean    false  false  false                  MicrosoftInternetExplorer4             \n\r\n\rName      \n\r\n\rMorph_Thinning      A morphological operation      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Morph_Thinning([in] Long* inputImage,[in] Long  MaskSize,[in] char* ThinningFilter, [out,retval] Long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rLong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rLong *    pointer to an Image structure      \n\r\n\rMaskSize      \n\r\n\rLong    mask size (3,5,7,9,...)      \n\r\n\rThinningFilter      \n\r\n\rChar*    Filter values      \n\r\n\rDescription  \n\r\n\r&nbsp;      Thinning is a morphological operation. This successfully erodes away foreground &nbsp;pixels from the boundary images, while preserving the end points of the line segment. &nbsp;Thinning is related to hit or miss transform and can be expressed as&nbsp;Thinning(I,J)=I-HitMiss(I,J)&nbsp;I-Original Image&nbsp;HitMiss(I,J) –hit and miss transform of the original image with structuring element J&nbsp;The structuring element contains 0’s, 1’s and x’s or “don’t care”. Don’t care elements in the structuring element match with either 0s or 1s. Morph_Thinning transform works only on binary images.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Morph_Thinning","scr\\COM_HELP/morph_thinning.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:59:00Z  2004-06-03T23:59:00Z  1  86  492  SIUE  4  1  577  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMorphClose        \n\r\n\rperforms morphological closing        \n\r\n\rFunction Prototype        \n\r\n\rMorphClose([in] long* image,int k_type,  int ksize, int height,int width,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\ra pointer to an Image structure        \n\r\n\rk_type      \n\r\n\rint      \n\r\n\rkernel type        \n\r\n\rksize      \n\r\n\rint      \n\r\n\rkernel size        \n\r\n\rheight      \n\r\n\rint      \n\r\n\rheight        \n\r\n\rwidth      \n\r\n\rint      \n\r\n\rwidth        \n\r\n\rDescription        \n\r\n\rMorphologic closing consists of morphological  dilation followed by morphological erosion of an image. It is often used to  fill in small gaps or holes in objects.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","MorphClose","scr\\COM_HELP/MorphClose.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:00:00Z  2004-06-04T00:00:00Z  1  110  632  SIUE  5  1  741  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMorphDilate        \n\r\n\rperforms morphological dilation        \n\r\n\rFunction Prototype        \n\r\n\rMorphDilate([in] long* image, int k_type,  int ksize, int height,int width,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\ra pointer to an Image structure        \n\r\n\rk_type      \n\r\n\rint      \n\r\n\rkernel type        \n\r\n\rksize      \n\r\n\rint      \n\r\n\rkernel size        \n\r\n\rheight      \n\r\n\rint      \n\r\n\rheight        \n\r\n\rwidth      \n\r\n\rint      \n\r\n\rwidth        \n\r\n\rDescription        \n\r\n\rMorphologic dilation is a process in which  objects within an image are expanded. The degree of object expansion is  controlled through the use of a structuring element that is convolved with  the original image to yield a desired image. Dilation is used to fill in  small holes in an object, or to connect disjoint objects.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","MorphDilate","scr\\COM_HELP/MorphDilate.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:00:00Z  2004-06-04T00:01:00Z  1  106  607  SIUE  5  1  712  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMorphErode        \n\r\n\rperforms morphological erosion        \n\r\n\rFunction Prototype        \n\r\n\rMorphErode([in] long* image,int k_type,  int ksize, int height,int width,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\ra pointer to an Image structure        \n\r\n\rk_type      \n\r\n\rint      \n\r\n\rkernel type        \n\r\n\rksize      \n\r\n\rint      \n\r\n\rkernel size        \n\r\n\rheight      \n\r\n\rint      \n\r\n\rheight        \n\r\n\rwidth      \n\r\n\rint      \n\r\n\rwidth        \n\r\n\rDescription        \n\r\n\rMorphologic erosion is a process in which  an image is shrunk by etching away its borders. The degree of image reduction  is controlled through the use of a structuring element that is convolved with  the original image to yield a desired image. Erosion is used disconnect  loosely-attached objects.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","MorphErode","scr\\COM_HELP/MorphErode.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:22:00Z  2004-06-04T00:23:00Z  1  155  889  SIUE  7  2  1042  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMorpho        \n\r\n\rhigher level function performing iterative  morphological modification based on morphIterMod_Image        \n\r\n\rFunction Prototype        \n\r\n\rMorpho([in] long* input_im1, [ in ] BSTR *File_Name,  [in] long rotate,[in] long boolFUNC,[in] long  connectedness, [in] long no_of_iter, [in] long  fields, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im1      \n\r\n\rlong *      \n\r\n\rpointer to Image structure (binary image)        \n\r\n\rFile_Name      \n\r\n\rBSTR *      \n\r\n\rpointer to a string holding the set of surrounds, such as &quot;1, 7,  8&quot;.        \n\r\n\rrotate      \n\r\n\rlong      \n\r\n\rrotate or not (CVIP_YES, CVIP_NO)        \n\r\n\rboolFUNC      \n\r\n\rlong      \n\r\n\rinteger number for the Boolean function  (16): 1: 0 2: !a 3: ab  \n\r\n\r 4: a+b 5: a^b 6: (!a)b        \n\r\n\rconnectedness      \n\r\n\rlong      \n\r\n\rthe connectivity scheme being used  (FOUR,EIGHT,SIX_NWSE,SIX_NESW)        \n\r\n\rno_of_iter      \n\r\n\rlong      \n\r\n\rnumber of iterations to perform        \n\r\n\rfields      \n\r\n\rlong      \n\r\n\rnumber of subfields into which the image tesselation will be divided        \n\r\n\rDescription        \n\r\n\rThis is a wrapper function for morphIterMod_Image, for more information, see morphIterMod_Image.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Morpho","scr\\COM_HELP/Morpho.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T01:03:00Z  2004-06-04T01:04:00Z  1  75  431  SIUE  3  1  505  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMorpho_com        \n\r\n\rInstantiate Morphological functions        \n\r\n\rFunction Prototype        \n\r\n\rMorpho_com([in] long* image, [ in ] BSTR *sur_set,  [in] long p1,[in] long p2, [in] long  p3,[in] long p4, [in] long p5, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rsur_set      \n\r\n\rBSTR*      \n\r\n\rsur_set        \n\r\n\rp1      \n\r\n\rlong      \n\r\n\rp1        \n\r\n\rp2      \n\r\n\rlong      \n\r\n\rp2        \n\r\n\rp3      \n\r\n\rlong      \n\r\n\rp3        \n\r\n\rp4      \n\r\n\rlong      \n\r\n\rp4        \n\r\n\rp5      \n\r\n\rlong      \n\r\n\rp5        \n\r\n\rDescription        \n\r\n\rInstantiate Morphological functions        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Morpho_com","scr\\COM_HELP/Morpho_com.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:01:00Z  2004-06-04T00:01:00Z  1  85  491  SIUE  4  1  575  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMorphOpen        \n\r\n\rperforms morphological opening        \n\r\n\rFunction Prototype        \n\r\n\rMorphOpen([in] long* image,int k_type,  int ksize, int height,int width,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\ra pointer to an Image structure        \n\r\n\rk_type      \n\r\n\rint      \n\r\n\rkernel type        \n\r\n\rksize      \n\r\n\rint      \n\r\n\rkernel size        \n\r\n\rheight      \n\r\n\rint      \n\r\n\rheight        \n\r\n\rwidth      \n\r\n\rint      \n\r\n\rwidth        \n\r\n\rDescription        \n\r\n\rMorphologic opening consists of morphological  erosion followed by morphological dilation of an image. It is often used to  eliminate small objects from an image.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","MorphOpen","scr\\COM_HELP/MorphOpen.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T17:26:00Z  2003-11-04T17:45:00Z  1  87  499  Westar  4  1  585  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMulti_Resolution_Segment        \n\r\n\rMulti resolution segment        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Multi_Resolution_Segment([in] long* image,[in] long  choice, [in] double param1, [in] double param2, [in] long run_PCT,  [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rChoice      \n\r\n\rLong    Choice of the segment      \n\r\n\rParam1      \n\r\n\rDouble    Parameter 1      \n\r\n\rParam2      \n\r\n\rDouble    Parameter 2      \n\r\n\rRun_PTC      \n\r\n\rLong    Run PTC(1) or not(0)      \n\r\n\rDescription      This function generate the result of the multi_resolution_segment      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Multi_Resolution_Segment","scr\\COM_HELP/Multi_Resolution_Segment.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  2  0  2004-06-03T23:01:00Z  2004-06-03T23:01:00Z  1  78  450  SIUE  3  1  527  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rMultiply_Image        \n\r\n\rmultiplies two images        \n\r\n\rFunction Prototype        \n\r\n\rMultiply_Image([in] long* input_im1,[in] long* input_im2, [out,retval]  long* result_im);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to newly allocated Image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im1      \n\r\n\rLong *      \n\r\n\rpointer to an Image structure        \n\r\n\rinput_im2      \n\r\n\rLong *      \n\r\n\rpointer to an Image structure        \n\r\n\rDescription        \n\r\n\rThis function uses the CVIP function \'multPWise_Matrix\' to perform bitwise multiplication of  two images. Complex matrices are supported.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Multiply_Image","scr\\COM_HELP/Multiply_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  2  2  2005-07-02T23:09:00Z  2005-07-02T23:11:00Z  1  267  1524  SIUE  12  3  1788  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rNearest_Centroid      finds the nearest centroid using a distance or similarity measure  \n\r\n\r&nbsp;        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Nearest_Centroid([in]  BSTR* TestFile, [in] BSTR* TrainingFile,  [in] BSTR* OutputFile,&nbsp; [in] int  normalize,&nbsp; [in] int&nbsp; distance_similarity,&nbsp; [in] float&nbsp;  s_min, [in]float s_max,  [in] float r_softmax, [in] float r_minkowski, [out,retval] long  *ErrorCode);        \n\r\n\rReturn Value        \n\r\n\rErrorCode      \n\r\n\rlong*      \n\r\n\rPointer to the error code        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rTestFile      \n\r\n\rBSTR*      \n\r\n\rPointer to test (text) file        \n\r\n\rTrainingFile      \n\r\n\rBSTR*      \n\r\n\rPointer to training (text) file        \n\r\n\rOutputFile      \n\r\n\rBSTR*      \n\r\n\rPointer to&nbsp;output (text) file        \n\r\n\rnormalize  \n\r\n\rdistance_similarity  \n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  s_min  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rs_max  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rr_softmax  \n\r\n\r&nbsp;  \n\r\n\rr_minkowski&nbsp; &nbsp;&nbsp;&nbsp;      \n\r\n\rint  \n\r\n\rint  \n\r\n\rfloat  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rfloat  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rfloat  \n\r\n\r&nbsp;  \n\r\n\rfloat      \n\r\n\rNormalization method used  \n\r\n\rDistance measure used  \n\r\n\rMinimum value for the specified range (min-max  norm. only); else use &nbsp;-1  \n\r\n\rMaximum value for the specified range (min-max norm. only); else use &nbsp;-1  \n\r\n\r&nbsp;  \n\r\n\rUsed with softmax scaling only; else use &nbsp;-1  \n\r\n\rUsed with minkowski distance only; else use &nbsp;-1  \n\r\n\r&nbsp;  &nbsp;      \n\r\n\rDescription       &nbsp;&nbsp;&nbsp;&nbsp; This function uses the selected distance or similarity measure&nbsp;&nbsp;&nbsp;&nbsp; to find the closest match in the training set to every entry in &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the test set. It uses the training set to generate the centroid &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for all the classes in the training file and then uses this &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new training file as the main training file.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Values to be used for:&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normalize: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 – No Normalization&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 – Range-normalize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 – Unit Vector normalization&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 – Standard Normal Density normalization&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 – Min-max normalization&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 – Softmax scaling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_similarity: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 – Euclidean Distance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 – City block or Absolute value metric&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 – Maximum value metric&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 – Minkowski distance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 – Vector inner product&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6 – Tanimoto metric	  Error Codes:&nbsp;&nbsp;1: The headers in the training and test files don\'t match &nbsp;2: K is greater than the number of entries in the training setor K&lt;=0 &nbsp;3: s_min is greater than or equal to s_max &nbsp;4: Data range is 0 and so the data can\'t be normalized &nbsp;5: Divisor is 0 in Tanimoto similarity measure &nbsp;7: Can\'t open, read or create file &nbsp;9: Memory allocation error &nbsp;10: Every entry in training set should have a class name &nbsp;12: r in minkowski should be a positive integer &nbsp;13: There is more than one header in the training or test feature file        \n\r\n\rBugs        \n\r\n\rN/A             \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Nearest_Centroid","scr\\COM_HELP/Nearest_Centroid.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  2  14  2005-07-02T22:48:00Z  2005-07-02T23:04:00Z  1  242  1380  SIUE  11  3  1619  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rNearest_Neighbor      finds the nearest neighbor using a distance or similarity measure  \n\r\n\r&nbsp;        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Nearest_Neighbor([in]  BSTR* TestFile, [in] BSTR* TrainingFile,  [in] BSTR* OutputFile,&nbsp; [in] int  normalize,&nbsp; [in] int&nbsp; distance_similarity,&nbsp; [in] float&nbsp;  s_min, [in]float s_max,  [in] float r_softmax, [in] float r_minkowski, [out,retval] long  *ErrorCode)        \n\r\n\rReturn Value        \n\r\n\rErrorCode      \n\r\n\rlong*      \n\r\n\rPointer to the error code        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rTestFile      \n\r\n\rBSTR*      \n\r\n\rPointer to test (text) file        \n\r\n\rTrainingFile      \n\r\n\rBSTR*      \n\r\n\rPointer to training (text) file        \n\r\n\rOutputFile      \n\r\n\rBSTR*      \n\r\n\rPointer to&nbsp;output (text) file        \n\r\n\rnormalize  \n\r\n\rdistance_similarity  \n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  s_min  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rs_max  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rr_softmax  \n\r\n\r&nbsp;  \n\r\n\rr_minkowski&nbsp; &nbsp;&nbsp;&nbsp;      \n\r\n\rint  \n\r\n\rint  \n\r\n\rfloat  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rfloat  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rfloat  \n\r\n\r&nbsp;  \n\r\n\rfloat      \n\r\n\rNormalization method used  \n\r\n\rDistance measure used  \n\r\n\rMinimum value for the specified range (min-max  norm. only); else use &nbsp;-1  \n\r\n\rMaximum value for the specified range (min-max norm. only); else use &nbsp;-1  \n\r\n\r&nbsp;  \n\r\n\rUsed with softmax scaling only; else use &nbsp;-1  \n\r\n\rUsed with minkowski distance only; else use &nbsp;-1  \n\r\n\r&nbsp;  &nbsp;      \n\r\n\rDescription       &nbsp;&nbsp;&nbsp;&nbsp; This function uses the selected distance or similarity measure&nbsp;&nbsp;&nbsp;&nbsp; to find the closest match in the training set to every entry in &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the test set.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Values to be used for:&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normalize: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 – No Normalization&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 – Range-normalize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 – Unit Vector normalization&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 – Standard Normal Density normalization&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 – Min-max normalization&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 – Softmax scaling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_similarity: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 – Euclidean Distance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 – City block or Absolute value metric&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 – Maximum value metric&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 – Minkowski distance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 – Vector inner product&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6 – Tanimoto metric       Error Codes:&nbsp;&nbsp;1: The headers in the training and test files don\'t match &nbsp;2: K is greater than the number of entries in the training setor K&lt;=0 &nbsp;3: s_min is greater than or equal to s_max &nbsp;4: Data range is 0 and so the data can\'t be normalized &nbsp;5: Divisor is 0 in Tanimoto similarity measure &nbsp;7: Can\'t open, read or create file &nbsp;9: Memory allocation error &nbsp;10: Every entry in training set should have a class name &nbsp;12: r in minkowski should be a positive integer &nbsp;13: There is more than one header in the training or test feature file        \n\r\n\rBugs        \n\r\n\rN/A             \n\r\n\r&nbsp;","Nearest_Neighbor","scr\\COM_HELP/Nearest_Neighbor.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:24:00Z  2004-06-04T00:25:00Z  1  101  578  SIUE  4  1  678  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rNeg_Exp_Noise        \n\r\n\rAdd Negative Exponential noise to an image        \n\r\n\rFunction Prototype        \n\r\n\rNeg_Exp_Noise([in] long* image,[in] double var, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rvar      \n\r\n\rdouble      \n\r\n\rvariance of noise distribution        \n\r\n\rDescription        \n\r\n\rNegative Exponential type noise is the result  of acquiring an image illuminated with a coherent laser. The optics community  refers to this type of noise as laser speckle. It has a histogram as  indicated by the following equation:  \n\r\n\r hi =  exp(-Gi/a) / a  \n\r\n\rWhere Gi is the  grey-level value of the ith pixel, a*a is the variance.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Neg_Exp_Noise","scr\\COM_HELP/Neg_Exp_Noise.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:57:00Z  2004-06-03T23:57:00Z  1  83  478  SIUE  3  1  560  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rNew_Image        \n\r\n\rcreate a new image structure        \n\r\n\rFunction Prototype        \n\r\n\rNew_Image(long image_format, long  color_space, int bands, int heigth, int width, long data_type, long  data_format,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage_format      \n\r\n\rlong      \n\r\n\rimage format        \n\r\n\rcolor_space      \n\r\n\rlong      \n\r\n\rcolor space        \n\r\n\rbands      \n\r\n\rint      \n\r\n\rnumber of bands        \n\r\n\rheight      \n\r\n\rint      \n\r\n\rimage height        \n\r\n\rwidth      \n\r\n\rint      \n\r\n\rimage width        \n\r\n\rdata_type      \n\r\n\rlong      \n\r\n\rdata type of the image        \n\r\n\rdata_format      \n\r\n\rlong      \n\r\n\rdata format        \n\r\n\rDescription        \n\r\n\rcreate a new image structure        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","New_Image","scr\\COM_HELP/New_Image.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:17:00Z  2003-11-04T17:45:00Z  1  273  1560  Westar  13  3  1830  10.2625    Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rNonfft_Xformfilter      arrange frequency filter for  use  with     various transforms      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Nonfft_Xformfilter([in]  long* image,[in] long block_size, [in] long dc, [in] long filtertype, [in]  long p1, [in] double p2, [in] long order,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rImage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rblock_size      \n\r\n\rlong     block size used in transform&nbsp;      \n\r\n\rDc      \n\r\n\rlong     1 = keep DC, 2 = discard DC&nbsp;      \n\r\n\rFiltertype      \n\r\n\rlong     one of:                 IDEAL_LOW                 BUTTER_LOW                 IDEAL_HIGH                 BUTTER_HIGH                 IDEAL_BAND                 BUTTER_BAND                 IDEAL_REJECT                 BUTTER_REJECT                 HIGH_FREQ_EMPHASIS&nbsp;      \n\r\n\rp1      \n\r\n\rlong     for IDEAL_LOW, BUTTER_LOW, IDEAL_HIGH,             BUTTER_HIGH: cutoff frequency           - for IDEAL_BAND, BUTTER_BAND, IDEAL_REJECT,             BUTTER_REJECT: inner cutoff frequency&nbsp;      \n\r\n\rp2      \n\r\n\rlong     for IDEAL_LOW, BUTTER_LOW, IDEAL_HIGH,             BUTTER_HIGH: set to -1           - for IDEAL_BAND, BUTTER_BAND, IDEAL_REJECT,             BUTTER_REJECT: outer cutoff frequency           - for HIGH_FREQ_EMPHASIS: emphasis offset&nbsp;      \n\r\n\rOrder      \n\r\n\rlong     Butterworth filter order, otherwise -1&nbsp;      \n\r\n\rDescription      This function is an internal function called  by  frequency-     domain  filters  to  arrange frequency filter values for use     with various transforms. For example, the dc  value  of  the     FFT  transform  is  placed in the center of the image, while     the dc value of the DCT transform is placed  in  the  upper-     left  corner  of  the image. The nonfft_xformfilter function     places the center of the filter in the appropriate location.&nbsp;     Not normally called directly by a user.&nbsp;&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Nonfft_Xformfilter","scr\\COM_HELP/Nonfft_Xformfilter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T22:51:00Z  2004-06-03T22:51:00Z  1  62  359  SIUE  2  1  420  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rNot_Image        \n\r\n\rperforms logical NOT on an image        \n\r\n\rFunction Prototype        \n\r\n\rNot_Image([in] long* image,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to newly allocated Image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rImage      \n\r\n\rLong*      \n\r\n\rThe input image        \n\r\n\rDescription        \n\r\n\rThis function performs a logical NOT on an image. Complex data is NOT  supported. Also known as complementing an image.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Not_Image","scr\\COM_HELP/Not_Image.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:18:00Z  2003-11-04T17:45:00Z  1  123  705  Westar  5  1  827  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rNotch      performs a selective notch filter  \n\r\n\r&nbsp;        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT  Notch([ in ] BSTR *File_Name, [in] long  x, [in] long  y, [in] long  radius,[in] long* image,[in] long  number,   [in] long  interactive,  [out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rName      \n\r\n\rBSTR*    Image name      \n\r\n\rX      \n\r\n\rLong    X of the notch point      \n\r\n\rY      \n\r\n\rLong    Y of the notch point      \n\r\n\rRadius      \n\r\n\rLong    Radius of the point      \n\r\n\rNumber      \n\r\n\rLong    Number of the notch point      \n\r\n\rInteractive      \n\r\n\rLong    Interactive from keyboard.      \n\r\n\rDescription      Notch is a function to  perform  selective  filtering  on  a     user-defined  area  of  an  image  or  spectrum. It is often     applied to frequency  domain  images  to  eliminate  regular     sinusoidal interference.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Notch","scr\\COM_HELP/Notch.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T17:28:00Z  2003-11-04T17:45:00Z  1  126  721  Westar  6  1  846  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rObject_Crop      Crops an object defind by a list of  surround-     ing coordinates.      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Object_Crop([in] long* image, [in] long * coordinates  ,[in] long format, [in] long R, [in] long G,[in] long B,[out, retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rCoordinates      \n\r\n\rlong *    Point array for the surroundings      \n\r\n\rFormat      \n\r\n\rLong    Format of the surrounds      \n\r\n\rR      \n\r\n\rLong    Red band      \n\r\n\rG      \n\r\n\rLong    Green band      \n\r\n\rB      \n\r\n\rLong    Blue band      \n\r\n\rDescription      This function was developed to take a coordinate  list  gen-     erated from the TclViewer by drawing objects on the image to     be cropped. To use this function out of  that  context  will     require an array of row then col positions to be stored in a     consecutive array.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Object_Crop","scr\\COM_HELP/Object_Crop.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T01:10:00Z  2004-06-04T01:11:00Z  1  58  336  SIUE  2  1  393  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rOpen_Consol_Redirect_Output        \n\r\n\rTo enable console redirection        \n\r\n\rFunction Prototype        \n\r\n\rOpen_Consol_Redirect_Output()        \n\r\n\rReturn Value        \n\r\n\rN/A      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rN/A      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rDescription        \n\r\n\rConsole Redirection allow user to see the CVIPtools  function standard output information thru the memo box at the bottom of the  GUI  \n\r\n\rTo enable console redirection (detail see Chen\'s thesis)        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","Open_Consol_Redirect_Output","scr\\COM_HELP/Open_Consol_Redirect_Output.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:02:00Z  2004-06-03T23:02:00Z  1  70  403  SIUE  3  1  472  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rOr_Image        \n\r\n\rperforms logical Or of two images        \n\r\n\rFunction Prototype        \n\r\n\rOr_Image([in] long* input_im1,[in] long* input_im2, [out,retval]  long* result_im);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to newly allocated Image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im1      \n\r\n\rLong *      \n\r\n\rpointer to an Image structure        \n\r\n\rinput_im2      \n\r\n\rLong *      \n\r\n\rpointer to an Image structure        \n\r\n\rDescription        \n\r\n\rThis function performs a bitwise OR of two  images. Complex data is NOT supported.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Or_Image","scr\\COM_HELP/Or_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  2  0  2004-06-03T23:35:00Z  2004-10-20T00:25:00Z  1  103  592  SIUE  4  1  694  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rOrientation        \n\r\n\rcalculates axis of least second moment        \n\r\n\rFunction Prototype        \n\r\n\rOrientation([in] long* image,[in] int r, [in] int c, [out,retval] long* Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong *      \n\r\n\rA value of type double: axis of least  second moment represented by a radian angle        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rr      \n\r\n\rint      \n\r\n\rrow coordinate of a point on the labled image        \n\r\n\rc      \n\r\n\rint      \n\r\n\rcolumn coordinate of a point on the labled image        \n\r\n\rDescription        \n\r\n\rThe function calculates the axis of least  second moment of an object of interest on a labeled image. The origin is the center  of area of that object and the angle is measured from the r-axis  counterclockwise.         \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Orientation","scr\\COM_HELP/Orientation.html","   ACADEMIC COMPUTING  jhansi  9  4  2004-06-04T00:28:00Z  2010-01-06T21:30:00Z  1  80  459  SIUE  3  1  538  11.9999    BestFit  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                                  \n\r\n\rName      \n\r\n\rOtsu_Segment        \n\r\n\ra histogram shape based segmentation  technique        \n\r\n\rFunction Prototype        \n\r\n\rOtsu_Segment([in] long* image,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rDescription      Otsu method is used to automatically perform histogram shape basedthresholding. Otsu method works best with bimodal histogram, ahistogram with two major peaks. It assumes each peak has a Gaussianshape and the peaks are fairly separated.  \n\r\n\r&nbsp;        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Otsu_Segment","scr\\COM_HELP/otsu_Segment.html","   ACADEMIC COMPUTING  Normal  P!Nk  12  17  2009-12-04T17:00:00Z  2009-12-04T17:04:00Z  2  167  957  SIUE  7  2  1122  12.00    140  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                                   \n\r\n\rName      \n\r\n\rParam_AD_Filter        \n\r\n\rPerforms parametric anisotropic diffusion.  filter        \n\r\n\rFunction Prototype        \n\r\n\rParam_AD_Filter([in] long* image, [in]  long* iteration_num, [in] long speed, [in] long edge_height, [in] block_size,  [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\riteration_num      \n\r\n\rlong      \n\r\n\rmaximum number of complete iterations        \n\r\n\rspeed  \n\r\n\r&nbsp;  \n\r\n\redge_height      \n\r\n\rlong  \n\r\n\r&nbsp;  \n\r\n\rlong      \n\r\n\rnumber of diffusion that is to be applied  at each iteration  \n\r\n\rnumber of diffusion that is to be applied  at each iteration        \n\r\n\rblock_size      \n\r\n\rlong      \n\r\n\rsize of blocks that is to be used during  the calculation of variance                                \n\r\n\rDescription        \n\r\n\rImproved  version of anisotropic diffusion filter. Parametric anisotropic diffusion  filter also iteratively removes noise from the &lt;image&gt;, while  calculating diffusion coefficient, in other words amount of diffusion, during  run-time, at each iteration. Using the blocks whose size is specified by  &lt;block_size&gt;, variance is calculated, and from there, the most  homogeneous region is selected to calculate the diffusion coefficient.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","Param_AD_Filter","scr\\COM_HELP/param_ad_filter.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:18:00Z  2003-11-04T17:45:00Z  1  279  1595  Westar  13  3  1871  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rParametric_Wiener      performs a parametric wiener filter  \n\r\n\r&nbsp;        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Parametric_Wiener([in] long* image,[in] long* image1,[in]  long* image2,[in] long* image3,[in] double gamma,[in] long choice,[in] long  cutoff,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rImage1      \n\r\n\rlong *    pointer to the degradation function&nbsp;      \n\r\n\rImage2      \n\r\n\rlong *    pointer to the noise power spectral density&nbsp;      \n\r\n\rImage3      \n\r\n\rlong *    pointer to the original  image  power  spectral     density&nbsp;      \n\r\n\rGama      \n\r\n\rDouble    \'gamma\' in the parametric wiener  filter  equa-     tion&nbsp;      \n\r\n\rChoice      \n\r\n\rLong    sets the maximum gain using the DC value  as  a     baseline&nbsp;      \n\r\n\rCutoff      \n\r\n\rLong    cutoff frequency for filtering      \n\r\n\rDescription      This function performs a parametric wiener filter.  See  any     image processing textbook for info on Wiener Filters.&nbsp;     The function does its own memory management, freeing  every-     thing  passed to it, so if you need your images intact, make     a copy of them before calling this function.&nbsp;     The function tries to determine whether an FFT has been per-     formed on the passed images.  If not, the function will per-     form the FFT.  This is especially important to note for  the     power  images.   If  the  power  images  are  in the spatial     domain, they will have an FFT performed on them, before  the     squared  magnitude  is calculated.  If an FFT is detected in     the history of any  of  the  power  images,  that  image  is     assumed  to  be  representing  a power image, and no squared     magnitude is calculated.&nbsp;     The function will also extend the sizes of the passed images     as best it can when they are of unequal size.&nbsp;     Also note that the passed images must have the  same  number     of (color) bands.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Parametric_Wiener","scr\\COM_HELP/Parametric_Wiener.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:02:00Z  2004-06-04T00:03:00Z  1  96  552  SIUE  4  1  647  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rPct        \n\r\n\rperforms the principal components transform.        \n\r\n\rFunction Prototype        \n\r\n\rPct([in] long* image,[in] long is_mask,[in] double *maskP,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to Image structure        \n\r\n\ris_mask      \n\r\n\rlong      \n\r\n\rwhether to ignore a background color  (CVIP_YES or CVIP_NO)        \n\r\n\rmaskP      \n\r\n\rdouble *      \n\r\n\rbackground color to ignore        \n\r\n\rDescription        \n\r\n\rPerforms the prinicipal  components transform (PCT) on &lt;srcImage&gt;. The  resultant image contains a set of decorrelated data  bands in which the first band is the most discriminant,  then the second band, and so on.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Pct","scr\\COM_HELP/Pct.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:03:00Z  2004-06-04T00:03:00Z  1  109  627  SIUE  5  1  735  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rPct_Color        \n\r\n\rperforms the principal components transform on color image.        \n\r\n\rFunction Prototype        \n\r\n\rPct_Color([in] long* image,[in] long is_mask,[in]  double *maskP,[in] long choice, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to Image structure        \n\r\n\ris_mask      \n\r\n\rlong      \n\r\n\rwhether to ignore a background color  (CVIP_YES or CVIP_NO)        \n\r\n\rmaskP      \n\r\n\rdouble *      \n\r\n\rbackground color to ignore        \n\r\n\rchoice      \n\r\n\rlong      \n\r\n\r1=perform PCT, 2=perform IPCT        \n\r\n\rDescription        \n\r\n\rPerforms the prinicipal  components transform (PCT) on &lt;srcImage&gt;. The  resultant image contains a set of decorrelated data  bands in which the first band is the most discriminant,  then the second band, and so on.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Pct_Color","scr\\COM_HELP/Pct_Color.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  2  3  2004-06-04T00:30:00Z  2004-06-04T01:23:00Z  1  294  1678  SIUE  13  3  1969  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rPct_Median_Segment        \n\r\n\ra segmentation algorithm for color images  based on PCT and median_cut        \n\r\n\rFunction Prototype        \n\r\n\rPct_Median_Segment([in] long* image,[in] long colors,[out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to Image structure        \n\r\n\rcolors      \n\r\n\rlong      \n\r\n\rdesired number of colors        \n\r\n\rDescription             \n\r\n\rName            \n\r\n\rPct_Median_Segment                  \n\r\n\ra segmentation algorithm    for color images based on PCT and median_cut                  \n\r\n\rFunction Prototype                  \n\r\n\rPct_Median_Segment([in] long* image,[in] long colors,[out,retval]    long* Result_Image);                  \n\r\n\rReturn Value                  \n\r\n\rResult_Image            \n\r\n\rlong *            \n\r\n\rresult image                  \n\r\n\rParameters                  \n\r\n\rName            \n\r\n\rType            \n\r\n\rDescription                  \n\r\n\rimage            \n\r\n\rlong *            \n\r\n\rpointer to Image    structure                  \n\r\n\rcolors            \n\r\n\rlong            \n\r\n\rdesired number of colors                  \n\r\n\rDescription                  \n\r\n\rThis function is based    on the Principal Components Transform (PCT) and median_cut    algorithms. The PCT aligns the main axis along the maximum variance path in    the data set, so that most of the color information lies along a principal    axis. Following that, the median split part of the algorithm divides the    image into the desired number of colors. Finally, the inverse PCT will    transform the resulting image back to the RGB color space.    \n\r\n\r This algorithm applies to color image    only. However, it can also be used on grayscale images through the extract_band()    and assemble_bands() functions.                  \n\r\n\rBugs                  \n\r\n\rNone.           \n\r\n\r&nbsp;  \n\r    \n\r\n\r&nbsp;  \n\r\n\r&nbsp;        \n\r\n\rThis function is based on the Principal Components  Transform (PCT) and median_cut algorithms. The PCT  aligns the main axis along the maximum variance path in the data set, so that  most of the color information lies along a principal axis. Following that,  the median split part of the algorithm divides the image into the desired  number of colors. Finally, the inverse PCT will transform the resulting image  back to the RGB color space.  \n\r\n\r This  algorithm applies to color image only. However, it can also be used on  grayscale images through the extract_band() and assemble_bands()  functions.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","Pct_Median_Segment","scr\\COM_HELP/Pct_Median_Segment.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:36:00Z  2004-06-03T23:36:00Z  1  175  1001  SIUE  8  2  1174  10.3501    Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rPerimeter        \n\r\n\rcalculates a binary object\'s perimeter        \n\r\n\rFunction Prototype        \n\r\n\rPerimeter([in] long* image,[in] int r, [in]  int c, [out,retval] long* Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong *      \n\r\n\rA value of type int: perimeter of the  object        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rr      \n\r\n\rint      \n\r\n\rrow coordinate of a point on the labeled  image        \n\r\n\rc      \n\r\n\rint      \n\r\n\rcolumn coordinate of a point on the labeled  image        \n\r\n\rDescription        \n\r\n\rWe define the perimeter of an object to be  the length of the outer edge of the object. This function first finds the  maximum and minimum values of the object of interest\'s row and column. The  length of the outer edge is then found by building chain code for that object  using function build_ChainCode(). Chain code is a  representation of a boundary as a connected sequence of straight-line  segments of specified length and direction. In build_ChainCode(),  8connectivity of the segments is used, and the length of the straight-line  segments is the distance between two neighboring pixels. By building chain  code for the object, the number of pixels on the outer edge of the object is  found and that is the perimeter of the object.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Perimeter","scr\\COM_HELP/Perimeter.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:25:00Z  2003-11-04T17:46:00Z  1  254  1448  Westar  12  3  1699  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rPower_Spect_Eq      performs wiener filtering      \n\r\n\rFunction Prototype        \n\r\n\rPower_Spect_Eq([in] long* image,[in] long* image1,[in] long* image2,[in] long*  image3,[in] long choice,[in] long cutoff,[out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rImage1      \n\r\n\rlong *    pointer to the degradation function      \n\r\n\rImage2      \n\r\n\rlong *    pointer to the noise power spectral density&nbsp;      \n\r\n\rImage3      \n\r\n\rlong *    pointer to the original  image  power  spectral     density&nbsp;      \n\r\n\rChoice      \n\r\n\rlong *    sets the maximum gain using the DC value  as  a     baseline&nbsp;      \n\r\n\rCutoff      \n\r\n\rLong    cutoff frequency for filtering      \n\r\n\rDescription      This function performs a power spectrum equalization filter.     The  function does its own memory management, freeing every-     thing passed to it, so if you need your images intact,  make     a copy of them before calling this function.&nbsp;     The function tries to determine whether an FFT has been per-     formed on the passed images.  If not, the function will per-     form the FFT.  This is especially important to note for  the     power  images.   If  the  power  images  are  in the spatial     domain, they will have an FFT performed on them, before  the     squared  magnitude  is calculated.  If an FFT is detected in     the history of any  of  the  power  images,  that  image  is     assumed  to  be  representing  a power image, and no squared     magnitude is calculated.&nbsp;     The function will also extend the sizes of the passed images     as best it can when they are of unequal size.&nbsp;     Also note that the passed images must have the  same  number     of (color) bands.&nbsp;&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Power_Spect_Eq","scr\\COM_HELP/Power_Spect_Eq.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  6  20  2004-07-06T18:09:00Z  2004-07-22T18:58:00Z  1  157  898  SIUE  7  2  1053  10.3501    Clean  Clean                  MicrosoftInternetExplorer4           \n\r\n\rName      \n\r\n\rPratt_Merit      Calculates Pratt’s Figure of Merit      \n\r\n\rFunction Prototype        \n\r\n\rPratt_Merit([in]  long* image1,[in] long* image2,[in]double scale_factor,  [out,retval] double   *Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rdouble*      Pratt’s figure of merit       \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage1      \n\r\n\rlong*    pointer to the ideal edge image structure      \n\r\n\rimage2      \n\r\n\rlong*    pointer to the output edge image structure from edge detection operation      \n\r\n\rscale_factor      \n\r\n\rdouble    Scaling constant that can be adjusted to adjust the penalty for offset edges.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;    &nbsp;      \n\r\n\rDescription        \n\r\n\rThe Pratt Figure Of Merit will be 1 for a perfect edge. Normalizing  to the maximum of the ideal and found edge points guarantees a penalty for  smeared edges or missing edge points. In general, this metric assigns a  better rating to smeared edges than to offset or missing edges. This is done  because techniques exist to thin smeared edges, but it is difficult to  determine when an edge is missed. The distance, d, can be defined in more than one way and typically depends on  the connectivity definition used.  &nbsp;      \n\r\n\rBugs        \n\r\n\rNone.               \n\r\n\r&nbsp;","Pratt_Merit","scr\\COM_HELP/Pratt_Merit.htm","   ACADEMIC COMPUTING  jhansi  8  7  2009-09-17T22:38:00Z  2009-09-17T22:39:00Z  2  147  841  SIUE  7  1  987  12.00    140  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                                   \n\r\n\rName      \n\r\n\rPrewitt_Filter        \n\r\n\rperform prewitt edge detection        \n\r\n\rFunction Prototype        \n\r\n\rPrewitt_Filter([in] long* image, [in] long*  dirImage, [in] long mask_choice, [in] long mask_size, [in] long keep_dc, [in]  long threshold,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rdirImage      \n\r\n\rlong *      \n\r\n\rPointer to the direction image        \n\r\n\rmask_choice      \n\r\n\rlong      \n\r\n\rtype of smoothing filter        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rKernel Size        \n\r\n\rkeep_dc      \n\r\n\rlong      \n\r\n\r0 (no) or 1 (yes)        \n\r\n\rthreshold      \n\r\n\rlong      \n\r\n\rvalue for binary threshold                                \n\r\n\rDescription        \n\r\n\rThis function applies prewitt edge  detection algorithms to &lt;imageP&gt;.   \n\r\n\r If a  smoothing filter is desired as a preprocessing step, set &lt;mask_choice&gt;  to:  \n\r\n\r 1 =  Gaussian blur  \n\r\n\r 2 =  generic lowpass 1  \n\r\n\r 3 =  generic lowpass 2  \n\r\n\r 4 =  neighborhood average  \n\r\n\r For  &lt;mask_size&gt;: set mask size to any desired kernel size  \n\r\n\r&nbsp;  \n\r\n\rNOTE: FOR ALL OF THE ABOVE PARAMETERS, USE  THE VALUE -1 FOR ANY PARAMETER NOT NEEDED.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","Prewitt_Filter","scr\\COM_HELP/Prewitt_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  2  1  2004-06-04T00:16:00Z  2004-10-20T00:26:00Z  1  207  1186  SIUE  9  2  1391  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rProjection        \n\r\n\rcalculates horizontal and vertical  projections of a size_normalized object of interest        \n\r\n\rFunction Prototype        \n\r\n\rProjection([in] long* input_im1, [in] long  r, [in] long c ,[in] long height, [in] long width,[out,retval]  VARIANT *result_array);        \n\r\n\rReturn Value        \n\r\n\rresult_array      \n\r\n\rVARIANT      \n\r\n\rA pointer to int,  first &lt;height&gt; values are for horizontal projections, following  &lt;width&gt; data are for vertical projections. Zero values are not filtered  out.        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im1      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rr      \n\r\n\rlong      \n\r\n\rrow coordinate of a point on the labeled  image        \n\r\n\rc      \n\r\n\rlong      \n\r\n\rcolumn coordinate of a point on the labeled  image        \n\r\n\rheight      \n\r\n\rlong      \n\r\n\rimage height after the object of interest is  normalized        \n\r\n\rwidth      \n\r\n\rlong      \n\r\n\rimage width after the object of interest is  normalized        \n\r\n\rDescription        \n\r\n\rThis function calculates the horizontal and  vertical projections of a binary object. The object is first grown or shrunk  (as required) to fit in the box of &lt;height&gt; height and &lt;width&gt;  width. Zero-order hold is used to grow; deleting every other line  (decimation) is used to shrink. The object is grown (or shrunk), until it  just fits within the box. The growing or shrinking is the same in both  dimensions. The function then calculates horizontal and vertical projections  on this size_normalized object according to  equations given in chapter 3 of Computer Imaging, by Scott Umbaugh.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Projection","scr\\COM_HELP/Projection.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:51:00Z  2004-06-04T00:51:00Z  1  58  337  SIUE  2  1  394  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rPseudo_Remap        \n\r\n\rPseudo color remap function        \n\r\n\rFunction Prototype        \n\r\n\rPseudo_Remap([in] long* image,[in] long * lookupTable,[out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to the result image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rInput image        \n\r\n\rlookupTable      \n\r\n\rlong*      \n\r\n\rPointer to the Pesudo color remap table        \n\r\n\rDescription        \n\r\n\rPseudo color remap function        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Pseudo_Remap","scr\\COM_HELP/Pseudo_Remap.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:08:00Z  2004-06-03T23:08:00Z  1  143  817  SIUE  6  1  959  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rPseudocol_Freq        \n\r\n\rcreates pseudo-color image        \n\r\n\rFunction Prototype        \n\r\n\rPseudocol_Freq([in] long* image, [in] int inner, [in] int outer, [in] int blow,[in] int bband, [in] int bhigh, [out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to newly allocated Image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rinner      \n\r\n\rint      \n\r\n\rlow cutoff frequency        \n\r\n\router      \n\r\n\rint      \n\r\n\rhigh cutoff frequency        \n\r\n\rblow      \n\r\n\rint      \n\r\n\rmap lowpass  results to band # (R=0,G=1,B=2)        \n\r\n\rbband      \n\r\n\rint      \n\r\n\rmap bandpass  results to band # (R=0,G=1,B=2)        \n\r\n\rbhigh      \n\r\n\rint      \n\r\n\rmap highpass  results to band # (R=0,G=1,B=2)        \n\r\n\rDescription        \n\r\n\rThis function creates a pseudocolor  image from a gray image by frequency domain mapping. The low and high  frequency cut-offs define three zones on an FFT of the input image: low, bandpass, and high zone. Each zone must be mapped to one  band of an RGB image; no overlap is allowed.        \n\r\n\rBugs        \n\r\n\rBand of Lowpass, bandpass and highpass can not  be the same color.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Pseudocol_Freq","scr\\COM_HELP/Pseudocol_Freq.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T16:52:00Z  2003-11-04T17:46:00Z  1  75  430  Westar  3  1  504  10.2625    Clean  Clean                     MicrosoftInternetExplorer4    \n\r    \n\r\n\rName      \n\r\n\rRaster_Deblur_Filter        \n\r\n\rcorrects raster-scan error        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Raster_Deblur_Filter([in] long* image,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rDescription      This function corrects some raster-scan error.  It  operates     by replacing the value of every other pixel with the average     of its two adjacent pixels, first by rows, then by columns.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Raster_Deblur_Filter","scr\\COM_HELP/Raster_Deblur_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:25:00Z  2004-06-04T00:25:00Z  1  98  563  SIUE  4  1  660  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rRayleigh_Noise    \n\r\n\r&nbsp;      \n\r\n\rAdd Rayleigh noise to an image        \n\r\n\rFunction Prototype        \n\r\n\rRayleigh_Noise([in] long* image,[in] double  var, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rvar      \n\r\n\rdouble      \n\r\n\rvariance of noise distribution        \n\r\n\rDescription        \n\r\n\rRayleigh type noise appears typically in  radar range and velocity images and is derivable from uniform noise. The Rayleigh  noise histogram is defined as:  \n\r\n\r Gi  \n\r\n\r hi =  --------exp(-Gi^2/(2a^2) 0&lt;=Gi&lt;infinity  \n\r\n\r a^2  \n\r\n\r where Gi is the grey-level value of the ith  pixel, and the mean can be defined as follows: mean=sqrt(pi/2a).        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Rayleigh_noise","scr\\COM_HELP/Rayleigh_noise.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  2  2004-06-03T22:46:00Z  2004-06-03T22:48:00Z  1  85  485  SIUE  4  1  569  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rRead_Image        \n\r\n\rloads an Image structure with data from the  specified image file        \n\r\n\rFunction Prototype        \n\r\n\rRead_Image([ in ] BSTR *File_Name, [out, retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to newly allocated Image structure  loaded with data from &lt;File_Name&gt;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR *      \n\r\n\rThe file name of the image        \n\r\n\rDescription        \n\r\n\rLoads an Image structure with data from the  specified image file &lt;File_Name&gt;. All data  members of the structure are initialized to the specifications of the image  file read in.        \n\r\n\rBugs        \n\r\n\rNone   \n\r\n\r&nbsp;","Read_Image","scr\\COM_HELP/Read_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:58:00Z  2004-06-03T23:59:00Z  1  64  365  SIUE  3  1  428  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rRemap_Image        \n\r\n\rRemap image to specific range        \n\r\n\rFunction Prototype        \n\r\n\rRemap_Image([in] long* image,long dtype,  long            dmin,  long dmax,[out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an image        \n\r\n\rdtype      \n\r\n\rlong      \n\r\n\rdata type to convert to        \n\r\n\rdmin      \n\r\n\rlong      \n\r\n\rminimum range        \n\r\n\rdmax      \n\r\n\rlong      \n\r\n\rmaximum range        \n\r\n\rDescription        \n\r\n\rRemap image to specific range        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Remap_Image","scr\\COM_HELP/Remap_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T01:11:00Z  2004-06-04T01:12:00Z  1  55  319  SIUE  2  1  373  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rREMAPP        \n\r\n\rTo remap the image        \n\r\n\rFunction Prototype        \n\r\n\rREMAPP([in] long* image,long dtype, long          dmin, long dmax,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong*      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong*      \n\r\n\rThe input image        \n\r\n\rdtype      \n\r\n\rlong      \n\r\n\rThe type        \n\r\n\rdmin      \n\r\n\rlong      \n\r\n\rminimum value        \n\r\n\rdmax      \n\r\n\rlong      \n\r\n\rmax value        \n\r\n\rDescription        \n\r\n\rTo remap the image        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","REMAPP","scr\\COM_HELP/REMAPP.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:03:00Z  2004-06-04T00:04:00Z  1  107  616  SIUE  5  1  722  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rRms_Error        \n\r\n\rcomputes the rms  error between two images        \n\r\n\rFunction Prototype        \n\r\n\rRms_Error([in] long* input_im1,[in] long* input_im2, [out,retval]  VARIANT *result_array);        \n\r\n\rReturn Value        \n\r\n\rresult_arrray      \n\r\n\rVARIANT *      \n\r\n\rPointer to rms  values (float)        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im1      \n\r\n\rlong *      \n\r\n\rPointer to Image        \n\r\n\rinput_im2      \n\r\n\rlong *      \n\r\n\rPointer to Image        \n\r\n\rDescription        \n\r\n\rrms_error() calculates the Root-Mean_squared  error between two images.  \n\r\n\r The  number of values contained in the return value of rms_error() is equal to  bands+1. Thus, for a color image (RGB), rms_error() will return float  *fptr; where fptr[0]=error  in Red Band; fptr[1]=error in Green band; fptr[2]=error in Blue band; and fptr[3]  is overall rms error.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Rms_Error","scr\\COM_HELP/Rms_Error.html","   ACADEMIC COMPUTING  jhansi  4  11  2009-09-17T22:42:00Z  2009-09-17T22:43:00Z  2  148  844  SIUE  7  1  991  12.00    140  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                                   \n\r\n\rName      \n\r\n\rRobinson_Filter        \n\r\n\rperform robinson edge detection        \n\r\n\rFunction Prototype        \n\r\n\rRobinson_Filter([in] long* image, [in]  long* dirImage, [in] long mask_choice, [in] long mask_size, [in] long  keep_dc, [in] long threshold,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rdirImage      \n\r\n\rlong *      \n\r\n\rPointer to the direction image        \n\r\n\rmask_choice      \n\r\n\rlong      \n\r\n\rtype of smoothing filter        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rKernel Size        \n\r\n\rkeep_dc      \n\r\n\rlong      \n\r\n\r0 (no) or 1 (yes)        \n\r\n\rthreshold      \n\r\n\rlong      \n\r\n\rvalue for binary threshold                                \n\r\n\rDescription        \n\r\n\rThis function applies robinson edge  detection algorithms to &lt;imageP&gt;.   \n\r\n\r If a  smoothing filter is desired as a preprocessing step, set &lt;mask_choice&gt;  to:  \n\r\n\r 1 =  Gaussian blur  \n\r\n\r 2 =  generic lowpass 1  \n\r\n\r 3 =  generic lowpass 2  \n\r\n\r 4 =  neighborhood average  \n\r\n\r For  &lt;mask_size&gt;: set mask size to any desired kernel size  \n\r\n\r&nbsp;  \n\r\n\rNOTE: FOR ALL OF THE ABOVE PARAMETERS, USE  THE VALUE -1 FOR ANY PARAMETER NOT NEEDED.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","Robinson_Filter","scr\\COM_HELP/Robinson_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:44:00Z  2004-06-03T23:44:00Z  1  137  786  SIUE  6  1  922  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rRotate        \n\r\n\rrotates an image        \n\r\n\rFunction Prototype        \n\r\n\rRotate([in] long* image,[in] float  degrees,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\ra pointer to an Image structure        \n\r\n\rdegree      \n\r\n\rfloat      \n\r\n\ramount to rotate image (1 360)        \n\r\n\rDescription        \n\r\n\rThis function rotates the image by the  degree specified. The transformation equation used are X=xcos(rads)+ysin(rads);  Y=-xsin(rads)+ycos(rads); where X=shifted x  co-ordinate Y=shifted y coordinate rads=number of  radians to be rotated For the 4 corners of the image,the  shifted co-ordinates are found out and from that the new image size can be  calculated .For each co-ordinate in the new image the corresponding  co-ordinate in the old image is calculated, if it falls with in the range of  the old image size, the corresponding pixel value is copied,otherwise  the pixel value is set to zero.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Rotate","scr\\COM_HELP/Rotate.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:16:00Z  2004-06-04T00:17:00Z  1  111  638  SIUE  5  1  748  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rRst_invariant        \n\r\n\rcalculates seven rst-invariant features        \n\r\n\rFunction Prototype        \n\r\n\rRst_invariant([in] long* input_im1, [in]  long r, [in] long c ,[out,retval] VARIANT *result_array);        \n\r\n\rReturn Value        \n\r\n\rresult_array      \n\r\n\rVARIANT      \n\r\n\rAn array of seven feature values        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rr      \n\r\n\rint      \n\r\n\rrow coordinate of a point on the labeled  image        \n\r\n\rc      \n\r\n\rint      \n\r\n\rcolumn coordinate of a point on the labeled  image        \n\r\n\rDescription        \n\r\n\rThis function calculates seven moment-based  rotation-scale-ranslation (rst)-invariant features for an object selected by  the user. In order to get the rst features, the function first calculates and  normalizes central moments. This algorithm is designed to work on the binary  image.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Rst_invariant","scr\\COM_HELP/Rst_invariant.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T01:16:00Z  2004-06-04T01:16:00Z  1  48  279  SIUE  2  1  326  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSave_Compressed_Data        \n\r\n\rSave the compressed image to file        \n\r\n\rFunction Prototype        \n\r\n\rSave_Compressed_Data([in] long* input_im, [in ] BSTR*File_Name);        \n\r\n\rReturn Value        \n\r\n\rN/A      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im      \n\r\n\rlong*      \n\r\n\rThe input image        \n\r\n\rFile_Name      \n\r\n\rBSTR*      \n\r\n\rthe file name        \n\r\n\rDescription        \n\r\n\rSave the compressed image to file        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","Save_Compressed_Data","scr\\COM_HELP/Save_Compressed_Data.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:31:00Z  2004-06-04T00:31:00Z  1  131  749  SIUE  6  1  879  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSct_Split_Segment        \n\r\n\rperforms Spherical Coordinate Transform  segmentation        \n\r\n\rFunction Prototype        \n\r\n\rSct_Split_Segment([in] long* image,[in]  long A_split, [in] long B_split,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rA_split      \n\r\n\rlong      \n\r\n\rnumber of colors to divide along angle A        \n\r\n\rB_split      \n\r\n\rlong      \n\r\n\rnumber of colors to divide along angle B        \n\r\n\rDescription        \n\r\n\rThe Spherical Coordinate Transform  segmentation algorithm (SCT/Center split) was developed for use in the  identification of variegated coloring in skin tumor images. The algorithm  maps RGB data into a space defined by two angles and an intensity measure.  Then the subspace, defined by the minimums and maximums on the two angles, is  equally divided along each axis, using the two input parameters, A_split and  B_split.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Sct_Split_Segment","scr\\COM_HELP/Sct_Split_Segment.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T01:17:00Z  2004-06-04T01:17:00Z  1  48  280  SIUE  2  1  327  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSet_Console        \n\r\n\rRedirect the console output to the specific handle of the window        \n\r\n\rFunction Prototype        \n\r\n\rSet_Console([in] long Handle);        \n\r\n\rReturn Value        \n\r\n\rN/A      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rHandle      \n\r\n\rlong      \n\r\n\rThe handle of the output window        \n\r\n\rDescription        \n\r\n\rRedirect the console output to the specific handle of the window        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","Set_Console","scr\\COM_HELP/Set_Console.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:57:00Z  2004-06-04T00:57:00Z  1  128  735  SIUE  6  1  862  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSharpen_I        \n\r\n\rSharpening algorithm I        \n\r\n\rFunction Prototype        \n\r\n\rSharpen_I([in] long *inputImage, [in] long ifRemap, [in] long MaskChoice,  [in] long MaskSize, [in] float LowClip,  [in] float HighClip, [in] long ifAdd2Origin, [out, retval] long * Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong*      \n\r\n\rThe Pointer to the input image        \n\r\n\rifRemap      \n\r\n\rlong      \n\r\n\rIf to remap the image        \n\r\n\rMaskChoice      \n\r\n\rlong      \n\r\n\rType of the mask        \n\r\n\rMaskSize      \n\r\n\rlong      \n\r\n\rThe size of the mask        \n\r\n\rLowClip      \n\r\n\rlong      \n\r\n\rLower clip        \n\r\n\rHighClip      \n\r\n\rlong      \n\r\n\rHigher clip        \n\r\n\rifAdd2Origin      \n\r\n\rlong      \n\r\n\rIf to add original image to the result image        \n\r\n\rDescription        \n\r\n\rSharpening algorithm I  \n\r\n\r1. Laplacian filter with maskchoice  input  \n\r\n\r2. Sobel filter with masksize  input  \n\r\n\r3. multiply the two result  \n\r\n\r4. remap it to byte if specified  \n\r\n\r5. if Add 2 original, add it  \n\r\n\r6. histogram stretch and return        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Sharpen_I","scr\\COM_HELP/Sharpen_I.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:58:00Z  2004-06-04T00:58:00Z  1  79  452  SIUE  3  1  530  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSharpen_II        \n\r\n\rSharpening Algorithm II        \n\r\n\rFunction Prototype        \n\r\n\rSharpen_II([in] long *inputImage, [in] long  ifAdd2Origin, [out, retval] long * Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rifAdd2Origin      \n\r\n\rlong      \n\r\n\rIf to add to original image        \n\r\n\rDescription        \n\r\n\rSharpening Algorithm II  \n\r\n\r1. remap to Byte image within 10 - 100  \n\r\n\r2. image_sharp  \n\r\n\r3. histogram equalization on value (if color)  \n\r\n\r4. if Add 2 original, add it and return        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Sharpen_II","scr\\COM_HELP/Sharpen_II.html","   ACADEMIC COMPUTING  Normal  akharba  4  21  2004-07-05T20:35:00Z  2006-07-08T22:48:00Z  1  136  778  SIUE  6  1  913  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4        \n\r\n\rName      \n\r\n\rShen_Castan_Filter      performs a Shen_Castan edge detection on the image      \n\r\n\rFunction Prototype        \n\r\n\rShen_Castan__Filter([in] long* image,[in] double b,[in] long window_size,  [in] double low_threshold,[in] double high_threshold, [in] long thin_factor,  [out,retval] long *ZeroInterImage,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image  \n\r\n\r   \n\r\n\rZeroInterImage      \n\r\n\rlong *  \n\r\n\r&nbsp;  \n\r\n\rlong *      Result image  Pointer to an intermediate image structure      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an input Image structure      \n\r\n\rb      \n\r\n\rdouble    Smoothing factor for the ISEF function (0&lt;b&lt;1)      \n\r\n\rwindow_size      \n\r\n\rlong    &nbsp;      \n\r\n\rlow_threshold  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rhigh_threshold  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rthin_factor  \n\r\n\r&nbsp;      \n\r\n\rdouble  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\r&nbsp;  \n\r\n\rdouble  \n\r\n\r&nbsp;  \n\r\n\r   \n\r\n\rlong    Low threshold scale factor for the hysteresis threshold value estimated from the image&nbsp;&nbsp;High threshold scale factor for the hysteresis threshold value estimated from the image&nbsp;Distance between final line points      \n\r\n\rDescription      &nbsp;&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Shen_Castan_Filter","scr\\COM_HELP/Shen_Castan_Filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T22:49:00Z  2004-06-03T22:50:00Z  1  67  382  SIUE  3  1  448  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rShow_Image        \n\r\n\rDisplay image to specific Device Context  Handle        \n\r\n\rFunction Prototype        \n\r\n\rShow_Image([ in ] int dc, [ in ] int  x, [ in ]int y, [ in ] long* image);        \n\r\n\rReturn Value        \n\r\n\rNone.      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rdc      \n\r\n\rint      \n\r\n\rDevice context handle        \n\r\n\rx      \n\r\n\rint      \n\r\n\r&nbsp;        \n\r\n\ry      \n\r\n\rint      \n\r\n\r&nbsp;        \n\r\n\rimage      \n\r\n\rlong*      \n\r\n\rImage to display        \n\r\n\rDescription        \n\r\n\rDisplay an Image from the specified image  structure &lt;image&gt; according to the device context handle (dc) and x, y  coordinates.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Show_Image","scr\\COM_HELP/Show_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T01:09:00Z  2004-06-04T01:10:00Z  1  74  428  SIUE  3  1  501  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rShow_Image_Ex        \n\r\n\rEnhance method to show image thru COM function        \n\r\n\rFunction Prototype        \n\r\n\rShow_Image_Ex([ in ] int dc,[in] long* mem_dc, [ in ] int x, [ in ]int  y, [ in ] long* image);        \n\r\n\rReturn Value        \n\r\n\rN/A      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rdc      \n\r\n\rint      \n\r\n\rDC of the form to show upon        \n\r\n\rmem_dc      \n\r\n\rlong*      \n\r\n\rDC in the Memory if applicable        \n\r\n\rx      \n\r\n\rlong      \n\r\n\roffset in x coordinate        \n\r\n\ry      \n\r\n\rlong      \n\r\n\roffset in y coordinate        \n\r\n\rimage      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rDescription        \n\r\n\rEnhance method to show image thru COM function        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Show_Image_Ex","scr\\COM_HELP/Show_Image_Ex.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:44:00Z  2004-06-03T23:44:00Z  1  302  1727  SIUE  14  4  2025  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rShrink        \n\r\n\rreduces the image size        \n\r\n\rFunction Prototype        \n\r\n\rShrink([in] long* image,[in] float factor  ,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an Image structure        \n\r\n\rfactor      \n\r\n\rfloat      \n\r\n\rscaling factor (0.1 1.0)        \n\r\n\rDescription        \n\r\n\rA pointer to the Image structure is passed  to the function shrink so that the original image can be accessed, along with  the scaling factor which should be in the range 0.1 to 1 (1 is the maximum  scaling factor). The function uses the first order scaling algorithm where,  depending upon the scaling factor the pixels from the original image are  simple copied to the new image. The scaling factor is tested first to  determine the size of the new resultant image as well as the pixels to be  removed in the original image. If the inverse of the scaling factor is an  integer (example scaling factor = 0.25, ==&gt; 1/0.25 = 4), then every  occurrence of that pixel is COPIED to the new image who image size is  determined by the scaling factor (In the above case, every 4nd pixel is copied to the new image).  \n\r\n\r If  the scaling factor is less than 0.5, then the scaling factor is apparently  modified so that the number of pixels COPIED to the new image is uniform thus  avoiding quantization in the resultant image. For example, for a scaling  factor 0.4 (0.4 ==&gt; 1/0.4 = 2.5), every alternate 2nd and 3rd pixels are  copied to the new image.  \n\r\n\r If  the scaling factor is greater than 0.5, then depending upon the scaling  factor, those many pixels are SKIPPED while rest of the pixels are copied to  the new image. For example, for a scaling factor 0.6, every alternate 2nd and  3rd pixels are skipped while the rest is written to  the new image. For a scaling factor of 0.8, every 5th pixel is skipped, for  0.9 every 9th pixel is skipped and so on.  \n\r\n\r After the scaling operation is performed,  the pointer to the new resultant image of type Image is returned to the  calling function so that the new image can be displayed.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Shrink","scr\\COM_HELP/Shrink.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:26:00Z  2003-11-04T17:46:00Z  1  210  1201  Westar  10  2  1409  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSimple_Wiener        \n\r\n\rperforms a practical wiener filter        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Simple_Wiener([in] long* image,[in] long* image1,[in]  double k,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rImage1      \n\r\n\rlong *    pointer to the degradation function      \n\r\n\rK      \n\r\n\rDouble    a constant&nbsp;      \n\r\n\rDescription      Performs the operations needed to  perform  a  simple     Wiener Filter.            Denoting the degraded image by G(u,v), and using            H(u,v) for the degradation function Image, this func-     tion calculates                                                  2                                          |H(u,v)|              F(u,v) = G(u,v)    *     --------------                                               2                                       |H(u,v)|   + k&nbsp;       Variables Passed:            Image *degr - Contains the degraded image.            Image *degr - Contains the degradation function.            float k - constant.&nbsp;     This function performs a wiener filter, (a frequency  domain     filter).   See  any  image  processing  textbook for info on     Wiener Filters.  The function does its  own  memory  manage-     ment,  freeing  everything passed to it, so if you need your     images intact, make a copy of them before calling this func-     tion.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Simple_Wiener","scr\\COM_HELP/Simple_Wiener.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T16:54:00Z  2003-11-04T17:46:00Z  1  210  1198  Westar  9  2  1406  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSingle_Filter      performs single filter      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Single_Filter([in] long* image, [in] double sx, [in] double sy, [in] long xcen, [in] long ycen,[in]  double rot, [in] double beta, [in] long N, [in] double *h, [in] long choice,  [out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rsx,      \n\r\n\rDouble    horizontal sizing factor, 1 for no change      \n\r\n\rSy      \n\r\n\rDouble    vertical sizing factor, 1 for no change      \n\r\n\rXcen      \n\r\n\rDouble    row coordinate for new center, 0 for no change      \n\r\n\rYcen      \n\r\n\rDouble    column coordinate for new center, 0 for no change      \n\r\n\rRot      \n\r\n\rDouble    angle of rotation, 0 for no change      \n\r\n\rBeta      \n\r\n\rDouble    value for beta, typically 0.3 - 0.8      \n\r\n\rN      \n\r\n\rLong    kernel size (3,5,7,...)      \n\r\n\rH      \n\r\n\rDouble    kernel array (of size N*N)      \n\r\n\rChoice      \n\r\n\rLong    operation of filter (see DESCRIPTION, below):                     1 = -,-                     2 = +,+                     3 = +,-                     4 = -,+&nbsp;      \n\r\n\rDescription      Performs manipulation and enhancement of an image in a  sin-     gle  filter, after C.B. Chittineni. This implementation of a     single filter is based on the following equation:&nbsp;         f(x,y)=[(1+/-alpha)g(x,y)]-/+[(alpha)g(x,y)*h(x,y)]&nbsp;     The parameter \'&lt;choice&gt; - operation of filter\' refers to the     selection  of  arithmetic  signs  for the +/- and -/+ in the     equation above.&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Single_Filter","scr\\COM_HELP/Single_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:04:00Z  2004-06-04T00:04:00Z  1  143  821  SIUE  6  1  963  10.3501    Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSnr        \n\r\n\rcomputes the rms error between two images        \n\r\n\rFunction Prototype        \n\r\n\rSnr([in] long* input_im1,[in] long*  input_im2, [out,retval] VARIANT *result_array);        \n\r\n\rReturn Value        \n\r\n\rresult_array      \n\r\n\rVARIANT      \n\r\n\rPointer to rms values (float)        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im1      \n\r\n\rlong *      \n\r\n\rPointer to Image        \n\r\n\rinput_im2      \n\r\n\rlong *      \n\r\n\rPointer to Image        \n\r\n\rDescription        \n\r\n\rsnr() calculates the Peak Signal-to-Noise ratio between two images,  assuming a maximum value of 255 (BYTE). The number of values contained in the  return value of snr() is equal to bands+1. Thus, for  a color image (RGB), snr() will return float *fptr;  where fptr[0]=snr in Red Band; fptr[1]=snr in Green band; fptr[2]=snr in Blue  band; and fptr[3] is overall SNR.  \n\r\n\r If  case if there is no error between two images for a band, the return value for  that band is set to -1.0 as an indication.  \n\r\n\r The  input images may be any data type, but for the result to be meaningful the  maximum value should be around 255.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","Snr","scr\\COM_HELP/Snr.html","   ACADEMIC COMPUTING  jhansi  9  5  2009-09-17T22:33:00Z  2009-09-17T22:37:00Z  2  143  819  SIUE  6  1  961  12.00    140  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                                   \n\r\n\rName      \n\r\n\rSobel_Filter        \n\r\n\rperform sobel edge detection        \n\r\n\rFunction Prototype        \n\r\n\rSobel_Filter([in] long* image, [in] long* dirImage,  [in] long mask_choice, [in] long mask_size, [in] long keep_dc, [in] long  threshold,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rdirImage      \n\r\n\rlong *      \n\r\n\rPointer to the direction image        \n\r\n\rmask_choice      \n\r\n\rlong      \n\r\n\rtype of smoothing filter        \n\r\n\rmask_size      \n\r\n\rlong      \n\r\n\rKernel Size        \n\r\n\rkeep_dc      \n\r\n\rlong      \n\r\n\r0 (no) or 1 (yes)        \n\r\n\rthreshold      \n\r\n\rlong      \n\r\n\rvalue for binary threshold                                \n\r\n\rDescription        \n\r\n\rThis function applies sobel edge detection  algorithms to &lt;imageP&gt;.   \n\r\n\r If a  smoothing filter is desired as a preprocessing step, set &lt;mask_choice&gt;  to:  \n\r\n\r 1 =  Gaussian blur  \n\r\n\r 2 =  generic lowpass 1  \n\r\n\r 3 =  generic lowpass 2  \n\r\n\r 4 =  neighborhood average  \n\r\n\r For  &lt;mask_size&gt;: kernel size (3,5,or 7)  \n\r\n\r&nbsp;  \n\r\n\rNOTE: FOR ALL OF THE ABOVE PARAMETERS, USE  THE VALUE -1 FOR ANY PARAMETER NOT NEEDED.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","Sobel_Filter","scr\\COM_HELP/Sobel_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:45:00Z  2004-06-03T23:45:00Z  1  204  1165  SIUE  9  2  1367  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSpatial_Quant        \n\r\n\rreduces the image size by one of three  methods        \n\r\n\rFunction Prototype        \n\r\n\rSpatial_Quant([in] long* image,[in] int row,[in] int col,[in] int method,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rReturns a reduced image upon successful  completion; returns NULL upon error in size specification.        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an Image structure        \n\r\n\rrow      \n\r\n\rint      \n\r\n\rnumber of rows for reduced image        \n\r\n\rcolumn      \n\r\n\rint      \n\r\n\rnumber of columns for reduced image        \n\r\n\rDescription        \n\r\n\rspatial_quant allows the user to  specify the number of rows and columns in the resultant image, corresponding  to the height and width of the new image. The integers specified for row and  column sizes must be equal to or less than the input image sizes or an error  results.  \n\r\n\r Three methods are available for image  reduction:  \n\r\n\r 1)  AVERAGE each pixel in the new image represents an average of the original  image pixels it replaces  \n\r\n\r 2)  MEDIAN each pixel in the new image represents the median value of the  original image pixels it replaces  \n\r\n\r 3)  DECIMATION each pixel in the new image has the same value as a corresponding  pixel in the original image; other original-image pixels are discarded  \n\r\n\r Because the user may enter different values  for height and width, spatial_quant may be used to  geometrically distort the image in a rubber-sheet fashion.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Spatial_Quant","scr\\COM_HELP/Spatial_Quant.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T01:15:00Z  2004-06-04T01:15:00Z  1  73  421  SIUE  3  1  493  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSpec_Hist_Image        \n\r\n\rSpecify the histogram image        \n\r\n\rFunction Prototype        \n\r\n\rSpec_Hist_Image([in] long *InputImage, [in] BSTR * bandR, [in] BSTR *  bandG, [in] BSTR * bandB, [out,retval] long *Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rlong*      \n\r\n\rThe return structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong*      \n\r\n\rThe input image        \n\r\n\rbandR      \n\r\n\rBSTR*      \n\r\n\rThe structure for Red band        \n\r\n\rbandG      \n\r\n\rBSTR*      \n\r\n\rThe structure for Green band        \n\r\n\rbandB      \n\r\n\rBSTR*      \n\r\n\rThe structure for Blue band        \n\r\n\rDescription        \n\r\n\rSpecify the histogram image        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Spec_Hist_Image","scr\\COM_HELP/Spec_Hist_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T01:08:00Z  2004-06-04T01:09:00Z  1  94  541  SIUE  4  1  634  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSpecify_Filter        \n\r\n\rcalculates histogram features: mean, standard deviation, skew, energy  and entropy        \n\r\n\rFunction Prototype        \n\r\n\rSpecify_Filter([in] long* image,[in] long mask_height,[in]  long mask_width,[in] double *maskP,  [in] int normalization, [out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong*      \n\r\n\rthe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rmask_height      \n\r\n\rlong      \n\r\n\rThe height of the mask        \n\r\n\rmask_width      \n\r\n\rlong      \n\r\n\rThe width of the mask        \n\r\n\rmaskP      \n\r\n\rdouble*      \n\r\n\rThe pointer to the mask        \n\r\n\rnormalization      \n\r\n\rint      \n\r\n\rIf to normalize         \n\r\n\rDescription        \n\r\n\rdo the specific convolution mask to the image        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","Specify_Filter","scr\\COM_HELP/Specify_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:26:00Z  2004-06-04T00:26:00Z  1  136  778  SIUE  6  1  913  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSpeckle_Noise        \n\r\n\rAdd speckle noise to an image        \n\r\n\rFunction Prototype        \n\r\n\rSpeckle_Noise([in] long* image,[in] double  psalt, [in] double ppepper,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rpsalt      \n\r\n\rdouble      \n\r\n\rprobability of salt noise (high gray level  = 255)        \n\r\n\rppepper      \n\r\n\rdouble      \n\r\n\rprobability of pepper noise (low gray level  = 0)        \n\r\n\rDescription        \n\r\n\rSpeckle noise, also called &quot;salt and  pepper&quot; type noise, typically occurs in images that are acquired by  cameras containing malfunctioning pixels. Salt and Pepper noise is named  after the white and black appearance it adds to images.  \n\r\n\r The  float pblack represents the probability of a pixel being &quot;black&quot;,  or 0 in grey-level, while the float pwhite represents the probability of a  pixel being &quot;white&quot;, or 255. Note: the sum of pblack and pwhite  cannot exceed 1.0.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Speckle_Noise","scr\\COM_HELP/Speckle_Noise.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:17:00Z  2004-06-04T00:17:00Z  1  232  1326  SIUE  11  3  1555  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSpectral_Feature        \n\r\n\rcalculates total power spectrum in each  ring and sector over half image        \n\r\n\rFunction Prototype        \n\r\n\rSpectral_Feature(long *input_im1, long *input_im2, [in] long no_of_bands,  [in] long no_of_sectors,[in] long r,[in] long c,[out,retval] VARIANT *result_array);        \n\r\n\rReturn Value        \n\r\n\rresult_array      \n\r\n\rVARIANT      \n\r\n\rA pointer to a structure named POWER  containing spectral features data        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im1      \n\r\n\rlong *      \n\r\n\rpointer to the original image        \n\r\n\rinput_im2      \n\r\n\rlong *      \n\r\n\rPointer to the labeled image        \n\r\n\rno_of_bands      \n\r\n\rlong      \n\r\n\rnumber of rings        \n\r\n\rno_of_sectors      \n\r\n\rlong      \n\r\n\rnumber of sectors        \n\r\n\rr      \n\r\n\rint      \n\r\n\rrow coordinate of a point on the labeled  image        \n\r\n\rc      \n\r\n\rint      \n\r\n\rcolumn coordinate of a point on the labeled  image        \n\r\n\rDescription        \n\r\n\rHalf of the frequency domain of the object  of interest is divided into &lt;no_of_rings&gt;  rings and &lt;no_of_sectors&gt; sectors, that is to  say, all sectors have equal angles, distances  between neighboring rings are equal. The frequency domain is got by  performing forward FFT on image of the object of interest. The object of  interest is selected by the point of coordinates &lt;r,c&gt; on the labeled image. power_fft() returns dc_normalized values of total power spectrum in each ring  and sector. \'dc_normalized\' means all total power  spectrums are divided by the value of dc component (the value before divided  by N*N). For dc component, it is divided by pow(N, 4) before returned  to make it to be the power spectrum of the average value of all pixels in the  object image. N is equal to the image size of the object of interest(an N*N image).        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Spectral_Feature","scr\\COM_HELP/Spectral_Feature.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:32:00Z  2004-06-04T00:32:00Z  1  626  3572  SIUE  29  8  4190  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSplit_Merge_Segment        \n\r\n\rSetup for Split and Merge  Segmentation        \n\r\n\rFunction Prototype        \n\r\n\rSplit_Merge_Segment([in] long* image,[in] long level, [in] long choice,[in] double  parameter0,[in] double parameter1,[in] long Run_PCT,  [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rlevel      \n\r\n\rlong      \n\r\n\rthe level to begin procedure        \n\r\n\rchoice      \n\r\n\rlong      \n\r\n\rPredicate test chosen  \n\r\n\r (1)  pure uniformity  \n\r\n\r (2)  local mean vs. global  \n\r\n\r (3)  local std. deviation vs. global mean  \n\r\n\r (4)  Number of pixels within 2 x standard deviation  \n\r\n\r (5)  Weighted gray level distance test  \n\r\n\r (6)  Texture Homogeneity Test        \n\r\n\rparameter0      \n\r\n\rdouble      \n\r\n\rParameters used determined by predicate  test        \n\r\n\rparameter1      \n\r\n\rdouble      \n\r\n\rParameters used determined by predicate  test        \n\r\n\rRun_PCT      \n\r\n\rlong      \n\r\n\rChoice to run PCT on color images        \n\r\n\rDescription        \n\r\n\rsplit_merge_generic is the basic function  for the split_and_merge algorithm. A homogeneity  test is used to determine if the Region of Interest is homogeneous, if it is  then all the pixels in that region are replaced with their average (in the  segmented image).  \n\r\n\r The  level to begin the split and merge is related to the size of the beginning  region, specifically, the smaller the number the larger the beginning region.  \n\r\n\r The  chosen homogeneity test is the test that is to be used throughout the split  and merge segmentation process.  \n\r\n\r split_merge_segment is the most  frequently used one among the three functions, which provides six homgeneity tests. Some of the tests require additional  parameters, The 6 tests (and their additional parameter descriptions)  available are: (1) Pure Uniformity: Region is considered homogeneous if the  region is completely uniform, i.e. all the pixels have the same gray value.  (Additional Parameters None). (2) Local Mean vs. Global Mean: Region is  considered homogeneous if the local mean is greater than the global mean. (Additional  Parameters None). (3) Local Standard Deviation vs. Global Mean: Region is  considered homogeneous if the local standard deviation is less than 10% of  the global mean. (Additional Parameters None). (4) Variance Test: Region is  considered homogeneous if at least X% of the pixels are within 2 sigma of the  local mean, unless the standard deviation exceeds a maximum threshold.  (Additional Parameters \'X\' percentage (float *) e.g. X = .80 for 80%,  Threshold (float *) e.g. 80) (5) Weighted Gray Level Distance Test: A total  weighted gray level value is computed based on the mode and the gray level  distance from the mode weighted by the gray level distribution. If this value  is less than a threshold, then they region is considered homogeneous.  (Additional Parameters Threshold (float *) e.g. 30) (6) Texture Homogeneity  test: Compares the four quadrants of the Region, using 5 of the textural  features (See GUI_Texture_SetUp(...)), if the quadrants are similar to each other then  the region is considered homogenous. (Additional Parameters Similarity  measure (float *) e.g. .40, Pixel distance (float *) e.g. 3)  \n\r\n\r To  choose the homogeneity test, pass the number of the test. &lt;parameters&gt; refer to the parameters as illustrated in  the test descriptions above. &lt;RUN_PCT&gt;: if the image is a multi-band  image and RUN_PCT is CVIP_YES, a PCT_Image(...) will be done on the image to transform it down to a  single band image, prior to doing the split and merge segmentation. If  RUN_PCT is CVIP_NO then the split and merge segmentation will be performed on  each band, all bands must pass the homogeneity test in order to be considered  homogeneous.  \n\r\n\r multi_resolution_segment is  exactly the same as split_merge_segment, except  that the level is fixed to 0 in multi_resolution_segment.        \n\r\n\rBugs        \n\r\n\rRuns somewhat slowly dependent on the  homogeneity test chosen. The weighted Gray level distance test is noticeably  slower than the first 4 tests.  \n\r\n\r The  Texture Test runs extremely slow compared to the other 5 tests, the more  non-homogeneous the image the slower it runs.  \n\r\n\r The  Texture Test also does a very poor job of memory management. Will consume a  large amount of memory and then not release it until the entire program is  exited. The more non-homogeneous the image the more memory is consumed.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Split_Merge_Segment","scr\\COM_HELP/Split_Merge_Segment.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:02:00Z  2004-06-03T23:03:00Z  1  77  443  SIUE  3  1  519  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rSubtract_Image        \n\r\n\rsubtracts two images        \n\r\n\rFunction Prototype        \n\r\n\rSubtract_Image([in] long* input_im1,[in] long* input_im2, [out,retval]  long* result_im);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to newly allocated Image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im1      \n\r\n\rLong *      \n\r\n\rpointer to an Image structure        \n\r\n\rinput_im2      \n\r\n\rLong *      \n\r\n\rpointer to an Image structure        \n\r\n\rDescription        \n\r\n\rThis function uses the CVIP function \'sub_Matrix\' to perform bitwise subtractition  of two images. Complex matrices are supported.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Subtract_Image","scr\\COM_HELP/Subtract_Image.html","   ACADEMIC COMPUTING  hari  12  14  2004-06-04T01:02:00Z  2010-07-05T11:58:00Z  1  251  1435  SIUE  11  3  1683  11.5606    150  Clean  Clean    false  false  false                  MicrosoftInternetExplorer4        \n\r\n\rName      \n\r\n\rTextureFeature2        \n\r\n\rExtract the Texture and Feature        \n\r\n\rFunction Prototype        \n\r\n\rTextureFeature2([in]  long* inputImage, [in] long*  labeledImage, [in] long band, [in] long r, [in] long c, [in] long distance, [in]  long energy, [in] long inertia, [in] long correlation, [in] long invDiff, [in]  long entropy, [in] long zero_rc, [out,retval] VARIANT* result);        \n\r\n\rReturn Value        \n\r\n\rresult      \n\r\n\rVARIANT*      \n\r\n\rThe return array        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rorig_im      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rlabeled_im      \n\r\n\rlong*      \n\r\n\rThe pointer to the labeled image        \n\r\n\rband      \n\r\n\rlong      \n\r\n\rthe band of the source image to be worked on        \n\r\n\rr      \n\r\n\rlong      \n\r\n\rthe row co-ordinate of the object        \n\r\n\rc      \n\r\n\rlong      \n\r\n\rthe column co-ordinate of the object        \n\r\n\rdistance      \n\r\n\rlong      \n\r\n\rthe  pixel  distance   to  calculate  the   co-occurrence matrix        \n\r\n\renergy      \n\r\n\rlong      \n\r\n\rflag for  calculating energy, 0 (no) or 1 (yes)        \n\r\n\rinertia      \n\r\n\rlong      \n\r\n\rflag for  calculating inertia, 0 (no) or 1 (yes)        \n\r\n\rcorrelation      \n\r\n\rlong      \n\r\n\rflag for  calculating correlation, 0 (no) or 1 (yes)        \n\r\n\rinvDiff      \n\r\n\rlong      \n\r\n\rflag for  calculating invDiff, 0 (no) or 1 (yes)        \n\r\n\rentropy      \n\r\n\rlong      \n\r\n\rflag for  calculating entropy, 0 (no) or 1 (yes)        \n\r\n\rzero_rc      \n\r\n\rlong    flag to include pixels pairs with zeros, 0 (no – used for masked image objects) or 1 (yes)      \n\r\n\rDescription      Calculates  the  5  textural  features  based  on  the  co-occurrence  matrices  at 0, 45, 90, and 135 degrees. See the structure &quot;TEXTURE&quot; for the 5 features.  The input  parameter  &lt;distance&gt;  is  used  in  calculating  the co-occurence matrices.  The average and range of the four  directions  is also calculated and returned for each feature.The function will only do one band of the image, the input parameter &lt;band&gt;  is  used  to select which band to extract the features from.  \n\r\n\r&nbsp;        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","TextureFeature2","scr\\COM_HELP/Texture2.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T01:02:00Z  2004-06-04T01:03:00Z  1  311  1777  SIUE  14  4  2084  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rTextureFeature        \n\r\n\rExtract the Texture and Feature        \n\r\n\rFunction Prototype        \n\r\n\rTextureFeature([in] long* orig_im, [in] long* labeled_im, [in] long r, [in] long c , [in] long distance  , [in] long hex_equiv ,[out,retval]  VARIANT *result_array);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rorig_im      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rlabeled_im      \n\r\n\rlong*      \n\r\n\rThe pointer to the labeled image        \n\r\n\rband      \n\r\n\rlong      \n\r\n\rthe band of the source image to be worked on        \n\r\n\rr      \n\r\n\rlong      \n\r\n\rthe row co-ordinate of the object        \n\r\n\rc      \n\r\n\rlong      \n\r\n\rthe column co-ordinate of the object        \n\r\n\rdistance      \n\r\n\rlong      \n\r\n\rthe  pixel  distance   to  calculate  the   co-occurrence matrix        \n\r\n\rhex_equiv      \n\r\n\rlong      \n\r\n\rthe hex equivalent of the Texture feature map        \n\r\n\rDescription        \n\r\n\rCalculates  the  14   textural  features  based   on  the  co-occurrence  matrices   at 0, 45, 90, and 135 degrees. See the structure &quot;TEXTURE&quot;  for the 14 features.  The input  parameter  &lt;distance&gt;  is   used  in  calculating   the co-occurence matrices.  The average and range of the four  directions  is also calculated and returned for each  feature. The algorithms for calculating the 14 textural features are taken  from R.M. Haralick, K. Shanmugam,  and I. Dinstein. 1973. Textural features for image  classification. &quot;IEEE Transactions on Systems, Man, and Cybertinetics, SMC-3 (6) :  610-621.  \n\r\n\rThe input parameter &lt;hex_equiv&gt; is  used to signal which of the 14 features to find. See the struct  &quot;TEXTURE_FEATURE_MAP&quot; for each features hex value. To calculate  more than one feature at a time simply add the hex  values together. Features that are not selected to be calculated will be set  to zero. The function will only do one band of the image,  the input parameter &lt;band&gt; is used to select which band to extract the  features from.  \n\r\n\r Gray level values of zero will  be ignored, they will not be used in the features  calculations. The code for implementing the algrorithm  was taken from another program written by James Darrell McCauley, Texas  Agricultural Experiment Station, Texas A&amp;M University The algorithms were used as coded with some minor modifications.        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","TextureFeature","scr\\COM_HELP/TextureFeature.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:36:00Z  2004-06-03T23:37:00Z  1  108  621  SIUE  5  1  728  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rThinness        \n\r\n\rcalculates thinness ratio        \n\r\n\rFunction Prototype        \n\r\n\rThinness([in] long* image,[in] int r, [in] int c, [out,retval] double* Result);        \n\r\n\rReturn Value        \n\r\n\rResult      \n\r\n\rdouble *      \n\r\n\rA value of type double: thinness ratio        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to a labeled image        \n\r\n\rr      \n\r\n\rint      \n\r\n\rrow coordinate of a point on the labeled  image        \n\r\n\rc      \n\r\n\rint      \n\r\n\rcolumn coordinate of a point on the labeled  image        \n\r\n\rDescription        \n\r\n\rThis function calculates the thinness ratio  of an object of interest on the labeled image. The formula used is:  \n\r\n\rthinness ratio = 4*PI*area/(perimeter^2)  \n\r\n\rWhere area is area of the binary object,  and perimeter is the length of outer edge of the object. The inverse of  thinness is known as irregularity.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Thinness","scr\\COM_HELP/Thinness.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:32:00Z  2004-06-04T00:33:00Z  1  203  1159  SIUE  9  2  1360  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rThreshold_Segment        \n\r\n\rperforms a binary threshold on an image        \n\r\n\rFunction Prototype        \n\r\n\rThreshold_Segment([in] long* image,[in] long threshval, [in]  long thresh_inbyte, [out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rthreshval      \n\r\n\rlong      \n\r\n\rthreshold value        \n\r\n\rthresh_inbyte      \n\r\n\rlong      \n\r\n\rCVIP_NO apply threshval  directly to image data;  \n\r\n\rCVIP_YES threshval  is CVIP_BYTE range; remap to image        \n\r\n\rDescription        \n\r\n\rThis function performs a binary threshold  on an input image. It sets pixels of value greater than &lt;threshval&gt; to 255; those less than or equal to &lt;threshval&gt; are set to zero. Each band of a multi-band images is thresholded  separately. If &lt;thresh_inbyte&gt; is 0, &lt;threshval&gt; is applied directly to the image data. If  &lt;thresh_inbyte&gt; equals 1, &lt;threshval&gt; is remapped to its corresponding CVIP_BYTE  value before thresholding according to the formula:  \n\r\n\r &lt;threshval&gt; x (max_val min_val)  \n\r\n\r &lt;new_thresh&gt; = --------------------------------+ min_val  \n\r\n\r 255  \n\r\n\r where max_val and min_val are the maximum and minimum values found in the  image. This option is provided for consistancy with  the method used to display histograms in CVIPtools  -histograms are remapped to CVIP_BYTE range, 0 to 255. With this option the  user can select a threshold value directly from the histogram.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Threshold_Segment","scr\\COM_HELP/Threshold_Segment.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:32:00Z  2004-06-03T23:32:00Z  1  64  371  SIUE  3  1  434  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rTifftocvip        \n\r\n\rConvert Image format from TIFF to CVIP        \n\r\n\rFunction Prototype        \n\r\n\rTifftocvip([in] BSTR *File_Name, [in ] int verbose, [out, retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to result image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rverbose      \n\r\n\rlong      \n\r\n\rwhether echo debug information        \n\r\n\rDescription        \n\r\n\rConvert Image format from TIFF to CVIP        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Tifftocvip","scr\\COM_HELP/Tifftocvip.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T01:07:00Z  2004-06-04T01:07:00Z  1  32  187  SIUE  1  1  218  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rTile_by_name        \n\r\n\rTile by name        \n\r\n\rFunction Prototype        \n\r\n\rTile_by_name([ in ] BSTR *File_Name);        \n\r\n\rReturn Value        \n\r\n\rN/a      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR*      \n\r\n\rThe file name        \n\r\n\rDescription        \n\r\n\rTile by name        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Tile_by_name","scr\\COM_HELP/Tile_by_name.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T00:52:00Z  2004-06-04T00:53:00Z  1  149  850  SIUE  7  1  998  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rTransform_Compression        \n\r\n\rTransform compression function        \n\r\n\rFunction Prototype        \n\r\n\rTransform_Compression([in] long *image, [in] BSTR * filename, [in] long color_space,  [in] long xform, [in] long WaveletBasis,  [in] long subimage_size, [in] long quant, [in] long  JPEG_Q_Table, [in] long coding, [in] long data_type, [in] long remap_type,  [in] long KeepDC, [out, retval]  long *Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to the result image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rInput image        \n\r\n\rfile_name      \n\r\n\rBSTR*      \n\r\n\rfile name        \n\r\n\rcolor_space      \n\r\n\rlong      \n\r\n\rtype of the color space        \n\r\n\rxform      \n\r\n\rlong      \n\r\n\rtype of the transform        \n\r\n\rwaveletBasis      \n\r\n\rlong      \n\r\n\rType of the basis of the wavelet transform        \n\r\n\rsubimage_size      \n\r\n\rlong      \n\r\n\rSize of the subimage        \n\r\n\rquant      \n\r\n\rlong      \n\r\n\rIf to quantize the image        \n\r\n\rJPEG_Q_Table      \n\r\n\rlong      \n\r\n\rIf to use the JPEG quantization table        \n\r\n\rcoding      \n\r\n\rlong      \n\r\n\rType of the coding        \n\r\n\rdata_type      \n\r\n\rlong      \n\r\n\rdata type        \n\r\n\rremap_type      \n\r\n\rlong      \n\r\n\rType of the remap        \n\r\n\rKeepDC      \n\r\n\rlong      \n\r\n\rif to keep the dc term        \n\r\n\rDescription        \n\r\n\rTransform compression function        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Transform_Compression","scr\\COM_HELP/Transform_Compression.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T01:00:00Z  2004-06-04T01:01:00Z  1  105  603  SIUE  5  1  707  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rTransform_Sharpen        \n\r\n\rTransform sharpening algorithm        \n\r\n\rFunction Prototype        \n\r\n\rTransform_Sharpen([in] long * inputImage, [in] long TransformMethod, [in] long CutoffFreq,  [in] long FilterOrder, [in] long Offset, [in] long KeepDC, [in] long Add2Origin, [out, retval]  long * Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rTransformMethod      \n\r\n\rlong      \n\r\n\rThe Transform Method        \n\r\n\rCutoffFreq      \n\r\n\rlong      \n\r\n\rThe cutoff frequency        \n\r\n\rFilterOrder      \n\r\n\rlong      \n\r\n\rThe order of the filter        \n\r\n\rOffset      \n\r\n\rdouble      \n\r\n\rOff set value        \n\r\n\rKeepDC      \n\r\n\rlong      \n\r\n\rIf to keep DC term        \n\r\n\rAdd2Origin      \n\r\n\rlong      \n\r\n\rIf to add to original image        \n\r\n\rDescription        \n\r\n\rTransform sharpening algorithm        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Transform_Sharpen","scr\\COM_HELP/Transform_Sharpen.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-04T01:01:00Z  2004-06-04T01:02:00Z  1  102  587  SIUE  4  1  688  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rTransform_Smoothing        \n\r\n\rTransform sharpening algorithm        \n\r\n\rFunction Prototype        \n\r\n\rTransform_Smoothing([in] long * inputImage, [in] long TransformMethod,  [in] long CutoffFreq, [in] long FilterOrder, [in] long Offset, [in] long  KeepDC, [out, retval] long * Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong*      \n\r\n\rThe pointer to the input image        \n\r\n\rTransformMethod      \n\r\n\rlong      \n\r\n\rThe Transform Method        \n\r\n\rCutoffFreq      \n\r\n\rlong      \n\r\n\rThe cutoff frequency        \n\r\n\rFilterOrder      \n\r\n\rlong      \n\r\n\rThe order of the filter        \n\r\n\rOffset      \n\r\n\rdouble      \n\r\n\rOff set value        \n\r\n\rKeepDC      \n\r\n\rlong      \n\r\n\rIf to keep DC term        \n\r\n\rAdd2Origin      \n\r\n\rlong      \n\r\n\rIf to add to original image        \n\r\n\rDescription        \n\r\n\rTransform sharpening algorithm        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","Transform_Smoothing","scr\\COM_HELP/Transform_Smoothing.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:45:00Z  2004-06-03T23:46:00Z  1  179  1023  SIUE  8  2  1200  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rTranslate        \n\r\n\rmoves the entire image or a part of the  image        \n\r\n\rFunction Prototype        \n\r\n\rTranslate([in] long* image, [in] long do_wrap, [in] int y_off, [in] int x_off,[in] int y_mount,[in] int x_mount,[in] int y_slide, [in] int x_slide, [in] float fill_out,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an Image structure        \n\r\n\rdo_wrap      \n\r\n\rlong      \n\r\n\rwrap image during translation if CVIP_YES        \n\r\n\ry_off      \n\r\n\rint      \n\r\n\rrow # of upper-left pixel in area to move        \n\r\n\rx_off      \n\r\n\rint      \n\r\n\rcolumn # of upper-left pixel in area to  move        \n\r\n\ry_mount      \n\r\n\rint      \n\r\n\rheight of area to move        \n\r\n\rx_mount      \n\r\n\rint      \n\r\n\rwidth of area to move        \n\r\n\ry_slide      \n\r\n\rint      \n\r\n\rdistance to slide vertically        \n\r\n\rx_slide      \n\r\n\rint      \n\r\n\rdistance to slide horizontally        \n\r\n\rfill_out      \n\r\n\rfloat      \n\r\n\rvalue to fill vacated area in cut-and-paste        \n\r\n\rDescription        \n\r\n\rTranslate can perform two different operations,  horizontal and vertical translation of an image, or cut-and-paste of a part  of an image. Translation moves the image as a whole; it can either wrap the  image around the \'edges\' or fill vacated areas with a constant value.  Cut-and-paste moves a userdefined part of the  image, and fills the vacated area with a user-provided value.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Translate","scr\\COM_HELP/Translate.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-04T00:26:00Z  2004-06-04T00:26:00Z  1  94  542  SIUE  4  1  635  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rUniform_Noise        \n\r\n\rAdd uniform noise to an image        \n\r\n\rFunction Prototype        \n\r\n\rUniform_Noise([in] long* image,[in] double  var, [in] double mean,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to the image        \n\r\n\rvar      \n\r\n\rdouble      \n\r\n\rvariance of noise distribution        \n\r\n\rmean      \n\r\n\rdouble      \n\r\n\rmean or average value of noise distribution        \n\r\n\rDescription        \n\r\n\rUniform type noise is simply generated according  to:  \n\r\n\r 1/a-b for a&lt;=Gi&lt;=b  \n\r\n\r hi =  \n\r\n\r 0  elsewhere  \n\r\n\r where Gi is the grey-level value of the ith  pixel, \'a\' is the minimum and \'b\' is the maximum gray level value of the  noise.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Uniform_Noise","scr\\COM_HELP/Uniform_Noise.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:04:00Z  2003-11-04T17:47:00Z  1  143  819  Westar  6  1  961  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rUnsharp_Filter      performs unsharp masking      \n\r\n\rFunction Prototype        \n\r\n\rUnsharp_Filter([in] long* image, [in] long lower, [in] long upper,[in] double low_clip, [in] double high_clip,[out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rlower      \n\r\n\rlong     lower limit for histogram shrink (0-254)      \n\r\n\rUpper      \n\r\n\rlong     upper limit for histogram shrink (1-255)      \n\r\n\rlow_clip      \n\r\n\rDouble    percentage of low values to clip                   during hist_stretch      \n\r\n\rhigh_clip      \n\r\n\rDouble    percentage of high values to clip                    during hist_stretch      \n\r\n\rDescription      Unsharp masking is a technique that combines  filtering  and     histogram modification. The input image is lowpass filtered;     a histogram shrink is then performed on the filtered  image.     The  resultant  image is subtracted from the original, and a     histogram stretch completes the process.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Unsharp_Filter","scr\\COM_HELP/Unsharp_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  7  2004-06-04T00:45:00Z  2004-09-18T01:25:00Z  1  128  734  SIUE  6  1  861  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rVq_Compress        \n\r\n\rVector Quantization Compression function        \n\r\n\rFunction Prototype        \n\r\n\rVq_compress([in] long *inputImage,[in] BSTR*File_Name,[in] long cdbook_in_file,[in]  long fixed_codebook,   [in] double in_error_thres,[in]  BSTR* cdbook_file,[in] long in_no_of_entries,[in]  long in_row_vector,[in] long in_col_vector,  [out, retval] long * result);        \n\r\n\rReturn Value        \n\r\n\rresult      \n\r\n\rlong *      \n\r\n\rsuccess 1/fail 0        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong *      \n\r\n\rInput image        \n\r\n\rFile_Name      \n\r\n\rBSTR*      \n\r\n\rtemporary store file name        \n\r\n\rcdbook_in_file      \n\r\n\rlong      \n\r\n\rif cdbook is in the file        \n\r\n\rfixed_codebook      \n\r\n\rlong      \n\r\n\rif to use fixed_codebook        \n\r\n\rin_error_thres      \n\r\n\rdouble      \n\r\n\rIn error Threshold        \n\r\n\rcdbook_file      \n\r\n\rBSTR*      \n\r\n\rcd book file name        \n\r\n\rin_no_of_entries      \n\r\n\rlong      \n\r\n\rNumber of the entries        \n\r\n\rin_row_vector      \n\r\n\rlong      \n\r\n\rinput row vector        \n\r\n\rin_col_vector      \n\r\n\rlong      \n\r\n\rinput column vector        \n\r\n\rDescription        \n\r\n\rVector Quantization Compression function        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","Vq_Compress","scr\\COM_HELP/Vq_Compress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  2  1  2004-06-04T00:53:00Z  2004-09-17T23:58:00Z  1  54  308  SIUE  2  1  361  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rVq_Decompress        \n\r\n\rVector Quantization Decompression function        \n\r\n\rFunction Prototype        \n\r\n\rVq_Decompress([in] BSTR* File_Name, [out, retval] long *Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to the result image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR*      \n\r\n\rinput compressed file        \n\r\n\rDescription        \n\r\n\rVector Quantization Decompression function        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","Vq_Decompress","scr\\COM_HELP/Vq_Decompress.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:11:00Z  2003-11-04T17:47:00Z  1  130  742  Westar  6  1  871  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rWalhad_Transform      performs Walsh or Hadamard transform      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Walhad_Transform([in] long* image,[in] long param1,[in]  long param2, [out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rParam1      \n\r\n\rlong     0=inverse Walsh transform, 1=Walsh transform               2=inverse Hadamard transform, 3=Hadamard transform      \n\r\n\rParam2      \n\r\n\rLong    block size (4,8,16,...largest_dimension/2)      \n\r\n\rDescription      This  function   performs  a  fast  Hadamard-ordered  Walsh-     Hadamard  Transform  on  an image.  The result is then reor-     dered for display in sequency order.  The routine  works  on     any  image  with  dimensions that are powers of 2.  Optional     zero-padding may be performed if input image  has  different     dimensions.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Walhad_Transform","scr\\COM_HELP/Walhad_Transform.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  6  13  2004-06-04T01:19:00Z  2004-09-25T22:49:00Z  1  150  857  SIUE  7  2  1005  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rWatershed_Segment        \n\r\n\rWatershed segmentation algorithm        \n\r\n\rFunction Prototype        \n\r\n\rWatershed_Segment([in] long * inputImage, [in] int choice, [in] float threshold, [out,retval]  long * Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong*      \n\r\n\rThe return image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinputImage      \n\r\n\rlong*      \n\r\n\rThe input image        \n\r\n\rchoice      \n\r\n\rint      \n\r\n\rThe choice to merge result or not        \n\r\n\rthreshold      \n\r\n\rfloat      \n\r\n\rThe threshold to segment image        \n\r\n\rDescription        \n\r\n\rThe watershed  segmentation algorithm as implemented in CVIPtools was initially designed to  separate a single object from the background in color images. The watershed  algorithm is a morphological technique based on the idea of modeling a gray  level image as a topographic surface, with higher gray levels corresponding  to higher elevations. The image is then flooded with a rainfall simulation,  and pools of water are created corresponding to segments within the image.  When rising water reaches a point where two pools will merge, a dam is built  to prevent the merging.        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Watershed_Segment","scr\\COM_HELP/Watershed_Segment.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T17:09:00Z  2003-11-04T17:47:00Z  1  83  476  Westar  3  1  558  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rWavdaub4_Transform      performs a Daubechies wavelet transform      \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Wavdaub4_Transform([in]  long* image,[in] long param1,[in] long param2, [out,retval]  long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rparam1      \n\r\n\rlong    1 (forward transform) or 2 (inverse transform)      \n\r\n\rParam2      \n\r\n\rlong     # of rows/(2^([(# bands desired -1)/3]-1))      \n\r\n\rDescription      This function performs a Daubechies 4 tap wavelet filter  in     the spatial domain.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Wavdaub4_Transform","scr\\COM_HELP/Wavdaub4_Transform.html","   Iris Cheng  Iris Cheng  2  2  2003-11-04T17:48:00Z  2003-11-04T17:48:00Z  1  76  434  Westar  3  1  509  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rWavhaar_Transform        \n\r\n\rperforms Haar wavelet  transform        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Wavhaar_Transform([in] long* image,[in] long param1,[in]  long param2, [out,retval] long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rparam1      \n\r\n\rlong     1 (forward transform) or 2 (inverse transform)      \n\r\n\rimage      \n\r\n\rlong     of rows/(2^([(# bands desired -1)/3]-1))      \n\r\n\rDescription      This function performs a Haar wavelet transform.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Wavhaar_Transform","scr\\COM_HELP/Wavhaar_Transform.html","   Iris Cheng  Iris Cheng  2  0  2003-11-04T17:48:00Z  2003-11-04T17:48:00Z  1  255  1455  Westar  12  3  1707  10.2625    Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rWiener      performs wiener filtering  \n\r\n\r&nbsp;        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Wiener([in]  long* image,[in] long* image1,[in] long* image2,[in] long* image3,[in] long  choice,[in] long cutoff,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *    pointer to an Image structure      \n\r\n\rImage1      \n\r\n\rlong *    pointer to the degradation function      \n\r\n\rImage2      \n\r\n\rlong *    pointer to the noise power spectral density&nbsp;      \n\r\n\rImage3      \n\r\n\rlong *    pointer to the original  image  power  spectral     density&nbsp;      \n\r\n\rCutoff      \n\r\n\rLong    cutoff frequency for filtering      \n\r\n\rDescription      This function performs a wiener filter, (a frequency  domain     filter).   See  any  image  processing  textbook for info on     Wiener Filters.  The function does its  own  memory  manage-     ment,  freeing  everything passed to it, so if you need your     images intact, make a copy of them before calling this func-     tion.&nbsp;     The function tries to determine whether an FFT has been per-     formed on the passed images.  If not, the function will per-     form the FFT.  This is especially important to note for  the     power  images.   If  the  power  images  are  in the spatial     domain, they will have an FFT performed on them, before  the     squared  magnitude  is calculated.  If an FFT is detected in     the history of any  of  the  power  images,  that  image  is     assumed  to  be  representing  a power image, and no squared     magnitude is calculated.&nbsp;     The function will also extend the sizes of the passed images     as best it can when they are of unequal size.&nbsp;     Also note that the passed images must have the  same  number     of (color) bands.&nbsp;&nbsp;      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Wiener","scr\\COM_HELP/Wiener.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:32:00Z  2004-06-03T23:33:00Z  1  162  924  SIUE  7  2  1084  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rWrite_Image        \n\r\n\rwrites the contents of a CVIP Image  structure out to disk        \n\r\n\rFunction Prototype        \n\r\n\rWrite_Image([in] long* input_im,[in ]BSTR*File_Name, [in] long retain_image,  [in] long set_up, [in]long new_format,  [in] long showmessages);        \n\r\n\rReturn Value        \n\r\n\rnone      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im      \n\r\n\rlong *      \n\r\n\rpointer to valid CVIP Image structure        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rimage file name to save        \n\r\n\rretain_image      \n\r\n\rlong      \n\r\n\rretain image after writing (CVIP_YES or CVIP_NO)?        \n\r\n\rset_up      \n\r\n\rlong      \n\r\n\rrun setup (CVIP_YES or CVIP_NO)?        \n\r\n\rnew_format      \n\r\n\rlong      \n\r\n\renumeration constant specifying the format  of the file to be written in        \n\r\n\rshowmessages      \n\r\n\rlong      \n\r\n\rshall I be verbose (CVIP_YES or CVIP_NO)?        \n\r\n\rDescription        \n\r\n\rWrites the contents of a CVIP Image  structure out to disk in the specified format &lt;new_format&gt;.  Many of the formats offer variations on the way a file can be presented to  disk. (e.g. compression schemes, byte ordering,  etc..) To take full advantage of this a set-up routine can be run by setting  &lt;set-up&gt; equal to CVIP_YES; otherwise, default options will be used.  Set-up routines vary for each format.        \n\r\n\rBugs        \n\r\n\rNone   \n\r\n\r&nbsp;","Write_Image","scr\\COM_HELP/Write_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:03:00Z  2004-06-03T23:04:00Z  1  71  407  SIUE  3  1  477  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rXor_Image        \n\r\n\rperforms logical XOR of two images        \n\r\n\rFunction Prototype        \n\r\n\rXor_Image([in] long* input_im1,[in] long* input_im2, [out,retval]  long* result_im);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to newly allocated Image structure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rinput_im1      \n\r\n\rLong *      \n\r\n\rpointer to an Image structure        \n\r\n\rinput_im2      \n\r\n\rLong *      \n\r\n\rpointer to an Image structure        \n\r\n\rDescription        \n\r\n\rThis function performs a bitwise XOR of two  images. Complex data is NOT supported.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Xor_Image","scr\\COM_HELP/Xor_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  2  2  2004-06-04T00:52:00Z  2004-09-17T23:54:00Z  1  92  529  SIUE  4  1  620  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rXvq_Compress        \n\r\n\rXVQ compress function        \n\r\n\rFunction Prototype        \n\r\n\rXvq_Compress([in] long* image,[in] long xform, [in] long  scheme, [in] BSTR *File_Name, [in] long file_type, [in] long remap_type,  [in] long dc,[out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to the result image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rInput image        \n\r\n\rxform      \n\r\n\rlong      \n\r\n\rtype of the transform        \n\r\n\rscheme      \n\r\n\rlong      \n\r\n\rscheme of the transform        \n\r\n\rFile_Name      \n\r\n\rlong      \n\r\n\rcompressed filename        \n\r\n\rfile_type      \n\r\n\rlong      \n\r\n\rType of the file        \n\r\n\rremap_type      \n\r\n\rlong      \n\r\n\rType of the remap        \n\r\n\rdc      \n\r\n\rlong      \n\r\n\rif to keep the dc term        \n\r\n\rDescription        \n\r\n\rXVQ compress function        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;\n\r\n\r\n\r&nbsp;","Xvq_Compress","scr\\COM_HELP/Xvq_Compress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-09-18T01:01:00Z  2004-09-25T22:05:00Z  1  48  274  SIUE  2  1  321  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rXvq_Decompress        \n\r\n\rXVQ decompress function        \n\r\n\rFunction Prototype        \n\r\n\rXvq_Decompress([in] BSTR *File_Name, [out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rPointer to the result image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rXvq_Decompress      \n\r\n\rlong      \n\r\n\rcompressed filename        \n\r\n\rDescription        \n\r\n\rXVQ decompress function        \n\r\n\rBugs        \n\r\n\rN/A   \n\r\n\r&nbsp;","Xvq_Decompress","scr\\COM_HELP/Xvq_Decompress.html","   Iris Cheng  Iris Cheng  2  1  2003-11-04T17:48:00Z  2003-11-04T17:48:00Z  1  137  787  Westar  6  1  923  10.2625    Clean  Clean                     MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rYpmean_Filter        \n\r\n\ra non-linear mean filter which is better  at removing   gaussian   type  noise and preserving edge  features      than the mean filter        \n\r\n\rFunction Prototype        \n\r\n\rHRESULT Ypmean_Filter([in] long* image,[in] long mask_size, [in] long p,[out,retval]  long* Result_Image)        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      Result image      \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rLong *    pointer to an Image structure      \n\r\n\rmask_size      \n\r\n\rLong    size of the filtering window (3-&gt;3x3).      \n\r\n\rimage      \n\r\n\rLong    pointer to an Image structure      \n\r\n\rDescription      Calculates the sum of the pixels in the filter window raised     to the power of p, then divided by N*N.  Returns this value     rose to the power of 3/p.  Good at removing positive     outliers for negative values of p and negative outliers for     positive values of p.  Size of filter should be an odd     integer limited from &lt; 3 - 31 &gt;, and order of filter is lim-ited from &lt;-5 to +5&gt;.      \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Ypmean_Filter","scr\\COM_HELP/Ypmean_Filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:22:00Z  2004-06-03T23:22:00Z  1  162  928  SIUE  7  2  1088  10.3501    Clean  Clean                  MicrosoftInternetExplorer4    \n\r  \n\r  \n\r  \n\r    \n\r\n\rName      \n\r\n\rZon_Compress        \n\r\n\rcompress and decompress an image using  zonal coding        \n\r\n\rFunction Prototype        \n\r\n\rZon_Compress([in] BSTR *File_Name, [in] long* Input_image, [in]int block_size,[in]int choice, [in  ]int mask_type, [in]float  compress_ratio);        \n\r\n\rReturn Value        \n\r\n\rNone      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rblock_size      \n\r\n\rint      \n\r\n\ra power of 2; kernel size is &lt;block_size&gt;^2        \n\r\n\rchoice      \n\r\n\rint      \n\r\n\rtransform to use: 1=FFT 2=DCT 3=Walsh 4=Hadamard        \n\r\n\rmask_type      \n\r\n\rint      \n\r\n\rtype of kernel to use: 1=triangle 2=square  3=circle        \n\r\n\rcompress_ration      \n\r\n\rfloat      \n\r\n\rcompression ratio, from 1.0 (min) to (block_size*block_size/4) (max) for all kinds of  transforms        \n\r\n\rDescription        \n\r\n\rThe program consists of two parts: zon_compress()  and zon_decompress(). zon_compress()  first performs a selected transform on the input image, forms a kernel  according to arguments block_size, mask_type and compress_ratio,  then uses the kernel to sample the transform of the input image, maps the  result to CVIP_BYTE data(unsigned char) and stores them in the file filename.        \n\r\n\rBugs   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Zon_Compress","scr\\COM_HELP/Zon_Compress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:27:00Z  2004-06-03T23:27:00Z  1  71  406  SIUE  3  1  476  10.3501    Clean  Clean                  MicrosoftInternetExplorer4    \n\r    \n\r\n\rName      \n\r\n\rZon_Decompress        \n\r\n\rerforms the inverse process of zon_compress().        \n\r\n\rFunction Prototype        \n\r\n\rZon_Decompress([ in ] BSTR *File_Name, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rreturned pointer to the uncompressed image  structure, a valid Image pointer on success, a NULL pointer on failure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rDescription        \n\r\n\rerforms the inverse process of zon_compress().        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Zon_Decompress","scr\\COM_HELP/Zon_Decompress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  1  2004-06-03T23:27:00Z  2004-06-03T23:28:00Z  1  152  871  SIUE  7  2  1021  10.3501    Clean  Clean                  MicrosoftInternetExplorer4    \n\r  \n\r  \n\r  \n\r  \n\r    \n\r\n\rName      \n\r\n\rZon2_Compress        \n\r\n\rcompress and decompress an image using  zonal coding        \n\r\n\rFunction Prototype        \n\r\n\rZon2_Compress([in] BSTR *File_Name, [in] long* Input_image,  [in]int block_size,[in]int choice, [in ]int mask_type, [in]float compress_ratio);        \n\r\n\rReturn Value        \n\r\n\rNone      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rblock_size      \n\r\n\rint      \n\r\n\ra power of 2; kernel size is &lt;block_size&gt;^2        \n\r\n\rchoice      \n\r\n\rint      \n\r\n\rtransform to use:  \n\r\n\r1=FFT 2=DCT 3=Walsh 4=Hadamard        \n\r\n\rmask_type      \n\r\n\rint      \n\r\n\rtype of kernel to use: 1=triangle 2=square  3=circle        \n\r\n\rcompress_ration      \n\r\n\rfloat      \n\r\n\rcompression ratio, from 1.0 (min) to (block_size*block_size/4) (max) for all kinds of  transforms        \n\r\n\rDescription        \n\r\n\rzon2_compress() first performs a selected  transform on the input image, forms a kernel according to arguments block_size, mask_type and compress_ratio, then uses the kernel to sample the  transform of the input image, maps the result to CVIP_BYTE data (unsigned  char) and stores them in the file filename.        \n\r\n\rBugs   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Zon2_Compress","scr\\COM_HELP/Zon2_Compress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:28:00Z  2004-06-03T23:28:00Z  1  102  584  SIUE  4  1  685  10.3501    Clean  Clean                  MicrosoftInternetExplorer4    \n\r    \n\r\n\rName      \n\r\n\rZon2_Decompress        \n\r\n\rerforms the inverse process of zon_compress().        \n\r\n\rFunction Prototype        \n\r\n\rZon_Decompress([ in ] BSTR *File_Name, [out,retval] long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rreturned pointer to the uncompressed image  structure, a valid Image pointer on success, a NULL pointer on failure        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rDescription        \n\r\n\rzon2_decompress()  performs the inverse process of zon2_compress(). The difference between zon_compress()  and zon2_compress() is that in zon_compress(), the  DC component is included into local remapping; while it is not included in  zon2_compress() coding.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;\n\r\n\r&nbsp;","Zon2_Decompress","scr\\COM_HELP/Zon2_Decompress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:46:00Z  2004-06-03T23:46:00Z  1  352  2013  SIUE  16  4  2361  10.3501                    MicrosoftInternetExplorer4      \n\r\n\rName      \n\r\n\rZoom        \n\r\n\rEnlarges a user-defined image area up to 10  times        \n\r\n\rFunction Prototype        \n\r\n\rZoom([in] long* image, [ in ] int quadrant,  [ in ] int X, [ in ] int Y, [ in ] int dx, [ in ] int dy, [ in ] float temp_factor,[out,retval]  long* Result_Image);        \n\r\n\rReturn Value        \n\r\n\rResult_Image      \n\r\n\rlong *      \n\r\n\rresult image        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rimage      \n\r\n\rlong *      \n\r\n\rpointer to an Image        \n\r\n\rquadrant      \n\r\n\rint      \n\r\n\r1=UL,2=UR,3=LL,4=LR,5=ALL,  6=Specify (x,y), dx, dy        \n\r\n\rX      \n\r\n\rint      \n\r\n\rcolumn coordinate of area\'s upper-left  corner        \n\r\n\rY      \n\r\n\rint      \n\r\n\rrow coordinate of area\'s upper-left corner        \n\r\n\rdx      \n\r\n\rint      \n\r\n\rwidth of area to enlarge        \n\r\n\rdy      \n\r\n\rint      \n\r\n\rheight of area to enlarge        \n\r\n\rtemp_factor      \n\r\n\rfloat      \n\r\n\rdegree of enlargement        \n\r\n\rDescription        \n\r\n\rTo the function zoom, a pointer to the  original image is passed as a parameter. After performing the zooming  operation, the pointer to the resultant image is returned to the calling  function to display the resultant image. As the &lt;quadrant&gt; implies, the  user can zoom the entire image, the first quadrant, the second and so on as  well as specifying the co-ordinates and their respective distances to be  zoomed. The maximum zoom factor allowed is 10. The zoom factor entered by the  user is rounded before performing the actual zooming. If the zoom factor is  3/4th or above the closest integer value, the zooming factor is rounded to  the nearest integer value. Like wise if the zoom factor is 1/4th or below the  closest integer value, the zooming factor is rounded to the nearest integer  value. If the zoom factor is between 1/4th or 3/4th an integer value, then  depending upon the zooming factor, selected pixels are skipped in a uniform  pattern and the zooming factor is rounded to the nearest integer. In this  case, if the zooming factor is close or above 1/2 the integer value, the  zooming factor is rounded to the nearest high integer value, else it is  rounded to the nearest lower integer value.  \n\r\n\r The  zooming is performed as a first order zooming algorithmn. For example, a  zooming factor n implies n*n pixels are replicated in the neighborhood of any  given original pixel.  \n\r\n\r Depending upon the &lt;quadrant&gt; chosen  by the user, the oppropriate regions in the original image are chosen and  zoomed accordingly. A new image of the appropriate size is created where the  zoomed pixels of the original image are written. The pointer to this newly  created zoomed image is returned to the calling function.        \n\r\n\rBugs        \n\r\n\rNone.   \n\r\n\r&nbsp;","Zoom","scr\\COM_HELP/Zoom.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  1  0  2004-06-03T23:29:00Z  2004-06-03T23:29:00Z  1  69  398  SIUE  3  1  466  10.3501    Clean  Clean                  MicrosoftInternetExplorer4    \n\r  \n\r  \n\r  \n\r    \n\r\n\rName      \n\r\n\rZvl_Compress        \n\r\n\rperforms Ziv-Lempel  compression        \n\r\n\rFunction Prototype        \n\r\n\rZvl_Compress([ in ] BSTR *File_Name, [in] long* Input_image);        \n\r\n\rReturn Value        \n\r\n\rNone      \n\r\n\r&nbsp;      \n\r\n\r&nbsp;        \n\r\n\rParameters        \n\r\n\rName      \n\r\n\rType      \n\r\n\rDescription        \n\r\n\rFile_Name      \n\r\n\rBSTR      \n\r\n\rtemporary compressed image file name        \n\r\n\rInput_image      \n\r\n\rlong *      \n\r\n\rPointer to image        \n\r\n\rDescription        \n\r\n\rThis function encodes an image using the Ziv-Lempel algorithm. The first two 9-bit codes have been  reserved for communication between the encoder and decoder.        \n\r\n\rBugs   \n\r\n\r\n\r&nbsp;","Zvl_Compress","scr\\COM_HELP/Zvl_Compress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  8  4  2004-06-04T21:33:00Z  2004-10-19T23:43:00Z  1  368  2101  SIUE  17  4  2465  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     ace2_filter - a spatial- an Adaptive Contrast  and  Enhance-     ment filter&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPspfltr.h&gt;&nbsp;     Image    *ace2_filter(Image    *inputIMAGE,int    size,float     alpha,float beta)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;size&gt; - mask size (3,5,7,9,...)      &lt;alpha&gt; - local mean      &lt;beta&gt; - local gain factor&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\lee_filter.c&nbsp;DESCRIPTION     The ACE2 filter is a spatial-domain method for contrast  and     dynamic  range  modifications with less limitation on linear     contrast stretching. For more  detail,  see  &quot;Digital  image     enhancement  and noise filtering by use of local statistics&quot;     by J.S.Lee&nbsp;        ACE2_filter = K2 * m_l(r,c) + K1 * [I(r,c) - m_l(r,c)]&nbsp;     Where I(i,j) represents the pixel brightness  value  of  the     original  image  and m_l(r,c) is the arithmetic mean bright-     ness value of an (n x n) window  that  is  centered  on  the     pixel position (r,c).  The parameters &quot;K1&quot; = local gain fac-     tor and &quot;K2&quot; = local mean factor.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to the processed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPspfltr.h&gt;&nbsp;      void main() {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs filter operation in a      kernel size of 5 with the local gain factor 0.5 multiplier      and local mean multiplier equal to 1.0 */      cvipImage = ace2_filter(cvipImage, 5, 1.0, 0.5);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Lingwei Sun.&nbsp;\n\r\n\r&nbsp;","ace2_filter","scr\\CVIP_C_functions/ace2_filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  5  2004-06-04T21:36:00Z  2004-10-19T23:40:00Z  1  211  1203  SIUE  10  2  1412  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     acuity_nightvision_filter - visual  acuity  and  nightvision     simulations&nbsp;SYNOPSIS      #include &quot;CVIPtools.h&quot;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPfs.h&quot;      #include &quot;CVIPhisto.h&quot;      #include &quot;threshold.h&quot;      #include &quot;CVIPspfltr.h&quot;&nbsp;     Image *acuity_nightvision_filter(Image *cvipImage,char  rea-     son, int threshold, int choice)&nbsp;      &lt;cvipImage&gt; - pointer to an Image      &lt;reason&gt; - y = nightvision, n = acuity simulation      &lt;threshold&gt; - binary threshold for nightvision simulation      &lt;choice&gt; - visual acuity value (20, 30, 40, ...)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\nightvision.c&nbsp;&nbsp;DESCRIPTION     Performs visual acuity and nightvision goggles  simulations.     For  visual  acuity, set &lt;reason&gt; to \'n\', set &lt;threshold&gt; to     -1, and specify the desired acuity &lt;choice&gt; as the numerator     of a standard visual acuity rating, such as \'50\' to simulate     20/50 vision.&nbsp;     For nightvision goggles simulation,  set  &lt;reason&gt;  to  \'y\',     select a threshold value (1-154), and set &lt;choice&gt; to -1.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A modified image&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO    SPATIALFILTER Library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh,  Mark  Zuke  and     Kun Luo.\n\r\n\r&nbsp;","acuity_nightvision_filter","scr\\CVIP_C_functions/acuity_nightvision_filter.html","   ACADEMIC COMPUTING  Normal  P!Nk  21  36  2009-12-04T16:17:00Z  2009-12-04T16:44:00Z  1  301  1717  SIUE  14  4  2014  12.00    120  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                              NAME      ad_filter – anisotropic diffusion filter&nbsp;SYNOPSIS      #include &quot;CVIPImage.h&quot;&nbsp;      Image *ad_filter(Image *inputImage, int iteration_num, int speed, int edge_height)&nbsp;      &lt;inputImage&gt; - pointer to Image structure      &lt;iteration_num&gt; - maximum number of complete iterations      &lt;speed&gt; - number of diffusion that is to be applied at each iteration      &lt;edge_height&gt; - minimum strength of edges that is to be preserved by the filterPATH      $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\spatial_filter.c&nbsp;DESCRIPTION\n\r\n\r     Theanisotropic diffusion filter in CVIPtools iteratively removes the noise from&lt;inputImage&gt;. The number of iterations is specified by&lt;iteration_num&gt;. While iteratively blurring the image, the filter stopsdiffusion at edges so that it preserves edges whose strength are greater than&lt;edge_height&gt;. RETURN VALUES     Pointer to an Image structure on success and NULL pointer     on failure.BUGS     None at this time&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;&nbsp;      void main()      {      Image *inputImage;      Image *outputImage;      IMAGE_FORMAT format;      char *inputfile, *outputfile;              setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      inputImage = read_Image(inputfile, 1);      view_Image(inputImage, inputfile);      free(inputfile);\n\r\n\r      \n\r\n\r      outputImage = ad_filter(inputImage, 20, 1,5);            print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(outputImage, outputfile);      write_Image(outputImage, outputfile, CVIP_NO, CVIP_NO, format, 1);      free(outputfile);&nbsp;      }&nbsp;SEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 2010 SIUE - by Scott Umbaugh and Serkan Kefel\n\r\n\r&nbsp;","ad_filter.htm","scr\\CVIP_C_functions/ad_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  5  2  2004-06-04T21:39:00Z  2004-10-19T23:43:00Z  1  378  2157  SIUE  17  5  2530  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     adapt_median_filter - a ranked-order based  adaptive  median     filter&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPxformfilter.h&gt;      #include &lt;CVIPtransform.h&gt;      #include &lt;math.h&gt;&nbsp;&nbsp;      Image *adapt_median_filter(Image *inputIMAGE,int wmax)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;wmax&gt; - mask size (3,5,7,9,...)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\median_hist.c&nbsp;DESCRIPTION     Ranked-order based adaptive median filter is used to  remove     positive and negative impulse noises in an image.      The Algorithm:      Xmed = median value in window      Xmin = minimum value in window      Xmax = maximum value in window      Xrc = current pixel value at (r,c)      (Level 1) T1 = Xmed - Xmin, T2 = Xmed - Xmax      (Level 2) U1 = Xrc - Xmin,  U2 = Xrc - Xmax      Level 1: If T1&gt;0&amp;T2&lt;0, goto Level 2               Else increase window size      Level 2: If U1&gt;0&amp;U2&lt;0, output = Xrc               Else output=Xmed&nbsp;     For more details see H. Hwang, R.A. Haddad, &quot;Adaptive Median     Filters: New Algorithms and Results&quot;, IEEE Trans. Image Pro-     cessing, Vol. 4, pp. 499-501, April 1995.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     The function returns an image that has been median filtered.&nbsp;HISTORY     History information recorded: filter window size&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;stdio.h&gt;      #include &lt;math.h&gt;&nbsp;      void main() {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile, *outputfile;&nbsp;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      cvipImage = (Image *)adapt_median_filter(cvipImage, 3);      /* example size 3 */      fflush(stdin);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage, outputfile);      write_Image(cvipImage,   outputfile,CVIP_NO,CVIP_NO,format,     1);      free(inputfile);      free(outputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO    SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Lingwei Sun.&nbsp;\n\r\n\r&nbsp;","adapt_median_filter","scr\\CVIP_C_functions/adapt_median_filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  1  2004-06-04T21:38:00Z  2004-10-19T23:43:00Z  1  396  2263  SIUE  18  5  2654  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     adaptive_contrast_filter - adaptive contrast filter&nbsp;SYNOPSIS     Image * adaptive_contrast_filter(Image *  inputImage,  float     k1,  float  k2,  unsigned  int  kernel_size, float min_gain,     float max_gain)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;k1&gt; - local gain factor multiplier  (typically  between  0     and 1)      &lt;k2&gt; - local mean multiplier (between 0 and 1)      &lt;kernel_size&gt; - size of local window (an odd number)      &lt;min_gain&gt; - the minimum local gain factor      &lt;max_gain&gt; - the maximum local gain factor&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\adaptive_contrast.c&nbsp;DESCRIPTION     The  adaptive  contrast  enhancement  filter  is   used   to     adjustthe  contrast  differently in different regions of the     image.The adaptive contrast filter is based on the following     equation:&nbsp;     adaptive_contrast_filter =&nbsp;                  M{I(r,c)}              k1*----------- * (I(r,c) - m_l(r,c)) + k2*m_l(r,c)                 sigma_l(r,c)&nbsp;     where M{I(r,c)} is the mean for  the  entire  image  I(r,c),     sigma_l  is  the  local standard deviation, m_l is the local     mean and k1, k2 are constants between 0 and 1.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to the processed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs filter operation in a      kernel size of 5 with the local gain factor multiplier      and local mean multiplier equal to 0.5 with the minimum      and maximum local gain factor equal to 0.5 and 5 */      cvipImage = adaptive_contrast_filter(cvipImage,0.5,0.5,      5,0.5,5);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSOSPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","adaptive_contrast_filter","scr\\CVIP_C_functions/adaptive_contrast_filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  3  2004-06-04T21:41:00Z  2004-10-19T23:43:00Z  1  270  1541  SIUE  12  3  1808  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     add_Image - adds two images&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIParithlogic.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;     Image *add_Image(Image *inputImage1,Image *inputImage2)&nbsp;     &lt;inputImage1&gt; - pointer to an Image structure  &lt;inputImage2&gt;     - pointer to an Image structure&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\ARITHLOGIC\\arithlogic.c&nbsp;&nbsp;DESCRIPTION     This function uses the CVIP function \'add_Matrix\' to perform     bitwise  addition  of  two images. Complex matrices are sup-     ported.&nbsp;TYPES AND CONSTANTS      #define MATPWISE_DEFINED&nbsp;RETURN VALUES     An added image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &quot;CVIPimage.h&quot;      #include &quot;CVIParithlogic.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;      void main() {        Image *inputImage1, *inputImage2, *outputImage;        IMAGE_FORMAT format;        char *inputfile1, *inputfile2, *outputfile;&nbsp;        (void) setDisplay_Image(&quot;RamViewer&quot;, &quot;Default&quot;);&nbsp;        print_CVIP(&quot;\\n\\tEnter the first Input File Name:  &quot;);        inputfile1 =(char *) getString_CVIP();        inputImage1 = read_Image(inputfile1, 1);        view_Image(inputImage1,inputfile1);        free(inputfile1);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the second Input File Name:  &quot;);        inputfile2 =(char *) getString_CVIP();        inputImage2 = read_Image(inputfile2, 1);        view_Image(inputImage2,inputfile2);        free(inputfile2);&nbsp;        outputImage = add_Image(inputImage1, inputImage2);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);        outputfile = getString_CVIP();        view_Image(outputImage,outputfile);        free(outputfile);&nbsp;      }&nbsp;SEE ALSO     ARITHLOGIC libraryAUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh, Jianxin  Tan,     and Kun Luo.&nbsp;\n\r\n\r&nbsp;","add_Image","scr\\CVIP_C_functions/add_Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-04T21:43:00Z  2004-10-19T23:43:00Z  1  396  2261  SIUE  18  5  2652  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     alpha_filter - used when an image contains  both  short  and     long  tailed  types  of  noise such as Gaussian and salt and     pepper noises. Filter varies between a  median  and  a  mean     filter.&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &lt;CVIPspfltr.h&gt;      #include &lt;float.h&gt;&nbsp;     Image *alpha_filter(Image *imageP, int mask_size, int p)          &lt;imageP&gt; - pointer to Image structure.          &lt;mask_size&gt; - the size of the filtering  window  (e.g.,     3-&gt;3x3).          &lt;p&gt; - number  of  maximum  and  minimum  pixels  to  be     excluded from the mean calculation.&nbsp;&nbsp;OPTIONS     None.&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\spatial_filter.c&nbsp;DESCRIPTION     Filter is based on order statistics. The parameter p  deter-     mines  how  many  of  the  endpoints are eliminated from the     ordered data. Returns the mean of the  filter  window  after     the endpoints have been removed. Size of filter should be an     odd integer limited from &lt; 3 - 31 &gt;, and  size  of  trim  is     limited from &lt;1-4&gt;.&nbsp;TIPS     Works best on images that contain both short and long tailed     type noise.  Keep filtering mask small to minimize blurring.&nbsp;DIAGNOSTICS     Returns the modified Image structure pointer on success, and     returns  NULL  pointer  if  the input image data type is not     CVIP_BYTE, and can\'t be cast to CVIP_FLOAT.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs a alpha filter operation      with the mask size equal to 3 with the number of pixels      skipped for mean calculation equal to 2*/      cvipImage = alpha_filter(cvipImage,3,2);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;BUGS     None.&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE - by Scott E. Umbaugh and John     A Creighton.&nbsp;\n\r\n\r&nbsp;","alpha_filter","scr\\CVIP_C_functions/alpha_filter.htm","   ACADEMIC COMPUTING  Normal  akharba  6  3  2004-06-04T21:44:00Z  2006-08-11T22:23:00Z  1  315  1797  SIUE  14  4  2108  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME     and_Image - performs logical AND of two images&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPmatrix.h&quot;      #include &quot;CVIParithlogic.h&quot;      #include &quot;CVIPdef.h&quot;           Image *and_Image(Image *inputImage1,Image *inputImage2)&nbsp;           &lt;inputImage1&gt; - pointer to an Image structure           &lt;inputImage2&gt; - pointer to an Image structure&nbsp;&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\ARITLOGIC\\arithlogic.c&nbsp;DESCRIPTION     This function performs a bitwise AND of two images.  Complex     data is NOT supported.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     An ANDed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE           #include &quot;CVIPtoolkit.h&quot;           #include &quot;CVIPimage.h&quot;           #include &quot;CVIPmatrix.h&quot;           #include &quot;CVIParithlogic.h&quot;           #include &quot;CVIPdef.h&quot;                      void main() {             Image *inputImage1, *inputImage2, *outputImage;             IMAGE_FORMAT format;             char *inputfile1, *inputfile2, *outputfile;&nbsp;             setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;             print_CVIP(&quot;0Enter the first Input File Name:  &quot;);             inputfile1 =(char *) getString_CVIP();             inputImage1 = read_Image(inputfile1, format, 1);             view_Image(inputImage1,inputfile1);          free(inputfile1);&nbsp;             print_CVIP(&quot;0Enter the second Input File Name:  &quot;);             inputfile2 =(char *) getString_CVIP();             inputImage2 = read_Image(inputfile2, format, 1);             view_Image(inputImage2,inputfile2);          free(inputfile2);&nbsp;          outputImage  =   and_Image(inputImage1,   inputImage2);          print_CVIP(&quot;0Enter the Output File Name:  &quot;);      out-     putfile                 =                  getString_CVIP();          view_Image(outputImage,outputfile);          free(outputfile);&nbsp;           }&nbsp;SEE ALSO     ARITHLOGIC library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh, Jainxin  Tan,     and  Kun  Luo.  # Revision 1.1  1997/01/29  22:20:01  kcai #     Initial revision #\n\r\n\r&nbsp;","and_Image","scr\\CVIP_C_functions/and_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-04T21:46:00Z  2004-10-19T23:44:00Z  1  315  1800  SIUE  15  4  2111  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     area - calculates area of an object of interest&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;&nbsp;     long area(Image * labeledImage, int r, int c)&nbsp;      &lt;labeledImage&gt; -  Pointer to the labeled image      &lt;r&gt; - row coordinate of a point on the labled image      &lt;c&gt; - column coordinate of a point on the labled image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\binary_feature.c&nbsp;DESCRIPTION     The program gets the sum of pixels whose gray  level  values     equal  to  a  specific  label.  This label is the gray level     value of the point  of  coordinates  &lt;r,c&gt;  on  the  labeled     image.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A value of type long int: area&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPobject.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;&nbsp;      void main() {         Image *inputImage, *labeledImage;         IMAGE_FORMAT format;         char *inputfile, *outputfile;         int rows, cols, r, c;&nbsp;         setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;         print_CVIP(&quot;\\nEnter the Input File Name:  &quot;);         inputfile = (char *) getString_CVIP();         inputImage = read_Image(inputfile, format, TRUE);         view_Image(inputImage,inputfile);         labeledImage = label(inputImage);&nbsp;         rows = getNoOfRows_Image(labeledImage);         cols = getNoOfCols_Image(labeledImage);&nbsp;         print_CVIP(&quot;\\nEnter the row coordinate of a point         on the labled image: &quot;);         r = getInt_CVIP(10, 0, rows);         print_CVIP(&quot;\\nEnter the col coordinate of the point         on the labled image: &quot;);         c = getInt_CVIP(10, 0, cols);         print_CVIP(&quot;The area of the image which has the         same label = %d&quot;, area(labeledImage, r, c));         print_CVIP(&quot;\\n&quot;);         free(inputfile);       }&nbsp;DIAGNOSTICS     The labeled image can only of data type CVIP_INTEGER&nbsp;SEE ALSO     FEATURE library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","area","scr\\CVIP_C_functions/area.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-04T21:47:00Z  2004-10-19T23:44:00Z  1  331  1888  SIUE  15  4  2215  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     aspect - calculates aspect ratio of an object of interest&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;&nbsp;     double aspect(Image * labeledImage, int r, int c)&nbsp;      &lt;labeledImage&gt; -  Pointer to the labeled image      &lt; r &gt; - row coordinate of the point on the labled image      &lt; c &gt; - column coordinate of the point on the labled image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\binary_feature.c&nbsp;DESCRIPTION     The  program  calculates  aspect  ratio  of  the  object  of     interest  on  the  labeled  image  Aspect ration is equal to     difference between maximum column value and  minimum  column     value  of  the  object divided by difference between maximum     row value and mimum row value of the object.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A value of type double: aspect ratio&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;      #include &quot;CVIPfeatures.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;      void main() {         Image *inputImage, *labeledImage;         IMAGE_FORMAT format;         char *inputfile, *outputfile;         int rows, cols, r, c;         double result;&nbsp;         setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;         print_CVIP(&quot;\\nEnter the Input File Name:  &quot;);         inputfile = (char *) getString_CVIP();         inputImage = read_Image(inputfile, 1);         view_Image(inputImage,inputfile);         labeledImage = label(inputImage);         rows = getNoOfRows_Image(labeledImage);         cols = getNoOfCols_Image(labeledImage);         print_CVIP(&quot;\\nEnter the row coordinate of any pixel         on the labled image: &quot;);         r = getInt_CVIP(10, 0, rows);         print_CVIP(&quot;Enter the col coordinate of any pixel on         the labled image: &quot;);         c = getInt_CVIP(10, 0, cols);         result = aspect(labeledImage, r, c);         print_CVIP(&quot;\\nThe aspect ratio of the object =         %f\\n&quot;, result );&nbsp;         free(inputfile);       }&nbsp;DIAGNOSTICS     The labeled image can only of data type CVIP_INTEGER&nbsp;SEE ALSO     FEATURE library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","aspect","scr\\CVIP_C_functions/aspect.htm","   Mounika  Normal  jhansi  16  7  2003-11-04T17:29:00Z  2010-01-06T21:53:00Z  1  358  2046  SIUE  17  4  2400  11.9999    125  Clean  Clean    false  false  false                  MicrosoftInternetExplorer4        NAME&nbsp;&nbsp;&nbsp;&nbsp; auto_threshold_segment-a segmentation- automatic thresholding filter.&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPtoolkit.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPconvert.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPdef.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPimage.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPspfltr.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image auto_threshold_segment(Image* inputImage,float limit);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;inputImage&gt; - pointer to an Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Limit&gt;- limiting value to find threshold value&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;PATH&nbsp;&nbsp;&nbsp;&nbsp; $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\auto_theshold_segment.c&nbsp;DESCRIPTION\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp; Autothreshold is a method to find the threshold automatically. This is an iterativeprocess, easily implemented via computer program.&nbsp;Auto threshold is alsocalled as Isodata or K-means algorithm.\n\r\n\r                              \n\r\n\r \n\r\n\rMean1is the pixels greater than Told \n\r\n\rMean2is the pixels less than Told\n\r\n\r&nbsp;\n\r\n\raverage of the twomean values:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Tnew = (m1 + m2)/2\n\r\n\rTold -Tnew &lt; limitthen Tnew &nbsp;is the threshold value otherwisereplace old threshold with new and find the mean values.TYPES AND CONSTANTS&nbsp;&nbsp;&nbsp;&nbsp; None&nbsp;RETURN VALUES&nbsp;&nbsp;&nbsp;&nbsp; Pointer to the processed image&nbsp;HISTORY&nbsp;&nbsp;&nbsp;&nbsp; History information recorded: None&nbsp;EXAMPLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPtoolkit.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPconvert.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPdef.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPimage.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPsegment.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void main() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image *cvipImage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMAGE_FORMAT format;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *inputfile,*outputfile;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void) setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_CVIP(&quot;\\n\\t\\tEnter the&nbsp; Input File Name:&nbsp; &quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputfile =(char *) getString_CVIP();&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;format = getFormat_CVIP(inputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvipImage = read_Image(inputfile,1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view_Image(cvipImage, inputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(inputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* the following call performs filter operation with limit value of 10*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvipImage = auto_threshold_segment(cvipImage,10.0f);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:&nbsp; &quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputfile = getString_CVIP();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view_Image(cvipImage,outputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(outputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; SEGMENTATION library&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 2010 SIUE - by Scott Umbaugh and Mounika Mamidi.&nbsp;\n\r\n\r&nbsp;","auto_threshold_segment","scr\\CVIP_C_functions/auto_threshold_filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  3  2004-06-04T21:48:00Z  2004-10-19T23:44:00Z  1  405  2314  SIUE  19  5  2714  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     bilinear_interp - shrinks or enlarges an image&nbsp;SYNOPSIS      #include &lt;stdio.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &quot;bilinear.h&quot;&nbsp;     Image *bilinear_interp(Image *inImg, float factor)&nbsp;      &lt;inImg&gt; - pointer to an Image structure      &lt;factor&gt; - factor &gt; 1 to enlarge, factor &lt; 1 to shrink&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\bilinear.c&nbsp;DESCRIPTION     This function shrinks or enlarges an  image  using  bilinear     interpolation  to calculate the gray-level value of new pix-     els. This technique provides a smooth appearance, especially     when enlarging an image. The newly-created pixel values  are     linearly interpolated from formerly  adjacent  pixels,  thus     producing even transitions.&nbsp;TYPES AND CONSTANTS      #define LOOP_BILINEAR(type,row,Mcol,int_map,delta_map,_Dptr, _Nptr) {          type **_Rowp=(type **)(_Dptr);          type *NEWP=(type *)(_Nptr);          int rI;   for(rI=0; rI &lt; (int)Mcol ; rI++) {               *NEWP++=BILINEAR((float)delta_map[row],(float)delta_map[rI],                    _Rowp[(int)int_map[row]][(int)int_map[rI]],                    _Rowp[(int)int_map[row]][(int)int_map[rI+1]],                    _Rowp[(int)int_map[row+1]][(int)int_map[rI]],                    _Rowp[(int)int_map[row+1]][(int)int_map[rI+1]], type);          }&nbsp;RETURN VALUES     A scaled image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE       #include &lt;CVIPtoolkit.h&gt;       #include &lt;CVIPdef.h&gt;       #include &lt;CVIPimage.h&gt;       #include &lt;CVIPconvert.h&gt;       #include &lt;CVIPimage.h&gt;       #include &quot;bilinear.h&quot;       #include &lt;stdio.h&gt;&nbsp;      void main()      {&nbsp;      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile, *outputfile;      float factor;      setDisplay_Image(&quot;RamViewer&quot;, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);&nbsp;      print_CVIP(&quot;\\n&quot;);      print_CVIP(&quot;\\n\\t\\tEnter a scaling factor (from 0.1 to 3.0):     &quot;);      factor = getFloat_CVIP( 0.1, 3.0 );&nbsp;      cvipImage = bilinear_interp(cvipImage, factor)      fflush(stdin);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      display_Image(outputfile,format);      free(inputfile);      free(outputfile);      }&nbsp;BUGS     The function cannot accept the value \'0.3\'; it causes a pro-     gram crash.&nbsp;SEE ALSO     GEOMETRY library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Arve     Kjoelen.&nbsp;\n\r\n\r&nbsp;","bilinear_interp","scr\\CVIP_C_functions/bilinear_interp.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  5  2  2004-06-04T21:50:00Z  2004-10-19T23:44:00Z  1  744  4245  SIUE  35  9  4980  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     bit_compress, bit_decompress, bitplane_sep -  Performs  bit-     plane runlength coding&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;bitplane_RLC.h&quot;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;&nbsp;     int bit_compress(Image  *inputImage,  char  *filename,  byte     sect )&nbsp;      &lt;inputImage&gt; - pointer to the image      &lt;filename&gt; - pointer to a character array      &lt;sect&gt; - bitmask of planes to retain&nbsp;     Image *bit_decompress(char *filename)&nbsp;      &lt;filename&gt; - pointer to a character array&nbsp;     Image *bit_planeadd(char *filename)&nbsp;      &lt;filename&gt; - pointer to a character array&nbsp;     Image *bitplane_sep(Image *input_Image, char *string)&nbsp;      &lt;input_Image&gt; - pointer to an Image      &lt;string&gt; - string containing bits to retain (7,6,5,...,0)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\bitplane_RLC.c&nbsp;DESCRIPTION     bit_compress  takes  three  parameters,  the   input   Image     pointer,  the  filename  to  store the encoded data, and the     bits to retain. This algorithm decomposes  the  input  image     into  eight binary bitplanes each corressponding to each bit     position in an eight bit binary. Then each bitplane is  run-     length  coded separately and written into an individual file     name derived from the input filename. The  user  is  advised     not  to  provide  the extension for the filename because the     program automaticaly appends suitable extension with numbers     to identify the bitplane files.&nbsp;     bit_decompress takes a pointer  to  the  encoded  data  file     name,   and  returns  a  pointer  to the decompressed image.     Since there are eight files with the  same  name  with  dif-     ferent  extension(each  file corresponds to a bitplane), the     program automatically derives the extension and decodes each     file  sequentialy.  So, the user is advised not to enter the     extension. Even the user enters a wrong extension  the  pro-     gram  takes care of it by appending the proper extension. It     generates seven images and returns the pointer to the  eigth     image.  Each  image corresponds to the one of the eight bit-     plane of the originalimage.&nbsp;     bit_planeadd takes a pointer  to  the  character  array  and     returns pointer to the image. The character array represents     the filename to be decoded(without any extension). The  same     explainations  for  no  extension  as discussed in the above     paragraph  applies  here  too.  The  operation  is  same  as     bit_decompress except it allows the user to add any combina-     tion of bitplanes together and display the resultant  image.     The user is advised not to add the same bitplane twice as it     makes no sense.  It returns the  pointer  to  the  resultant     image.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     bit_compress: 0 on success, -1 on failure&nbsp;     bit_decompress, bit_planeadd: a valid Image pointer on  suc-     cess, a NULL pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;DIAGNOSTICS     The Bit plane Runlength coding and  decoding  algorithm  was     designed  to  work  only  on  monochrome image(.pgm).  Eight     files are derived from the filename passed  in  the  command     line  or entered by the user, by appending proper extension.     So, the user has to enter the filename without any extension     wherever he or she needs to enter the filename.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;bitplane_RLC.h&quot;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the bit plane run length      coding on the inputnput image  retaining only the most      significant bit and the data is stored in &quot;file1&quot; */      bit_compress(cvipImage,&quot;file1&quot;,128);      /* the following call performs the bit plane run length      decoding of the input image */      cvipImage=bit_decompress(&quot;file1&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     COMPRESSION library&nbsp;AUTHOR     Muthu kumar, Southern Illinois University at Edwardsville&nbsp;     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Muthu kumar.&nbsp;\n\r\n\r&nbsp;","bit_compress,bit_decompress,bitplane_sep","scr\\CVIP_C_functions/bit_compress, bit_decompress, bitplane_sep.htm","   ACADEMIC COMPUTING  Normal  akharba  9  43  2004-07-03T23:07:00Z  2006-07-08T22:32:00Z  1  368  2102  SIUE  17  4  2466  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAMEboiecox_filter – performs a Boie-Cox edge detection on the image&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPspfltr.h&gt;&nbsp;     Image *boiecox_filter(Image *inputImage, float var, unsigned int       do_thresh, unsigned int do_hyst,unsigned int do_thin, float high_factor,     float low_factor, Image *Imagethld, Image *Imagehyst)&nbsp;&lt;inputImage&gt; - pointer to the input image structure                  &lt;var&gt; - variance 0.5 &lt;= var &lt;= 5 of Gaussian filter      &lt;do_thresh&gt; - 0 or 1      &lt;do_hyst&gt; - 0 or 1      &lt;do_thin&gt; -0 or 1      &lt;high_factor&gt; - high threshold scale factor for the hysteresis threshold      &lt;low_factor&gt; - low threshold scale for the hysteresis threshold or threshold scale                     factor for normal thresholding         &lt;Imagethld&gt; - pointer to an intermediate image structure      &lt;Imagehyst&gt; - pointer to an intermediate image structure&nbsp;       Final high threshold = high factor * mean absolute value       Final low threshold = low factor * high threshold * 0.5&nbsp;       Therefore range for high factor 0-10.       low factor = 0-1.&nbsp;        if (do_thresh  == 1){        get threshold factor for ordinary thresholding         0 &lt; high_factor &lt; 10        if factor  =1 then mean absolute value of the image is used as threshold.        if factor !=1 the threshold = factor * mean absolute value of image        low_factor =0        }        else if (do_hysterisis == 1){        then get low threshold factor and high threshold factor         }&nbsp;        do_thin  - 0 or 1         0- no thinning,         1- thining is done which means the thickness of edges is reduced        &nbsp;&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\boiecox_filter.c&nbsp;DESCRIPTION     boiecox_filter function applies Boie-Cox’s detector to an input image. The inputs of           all data types are accepted but the integer and float type inputs are remapped to      short. The function takes 6 parameters as input, variance of the Gaussian, the high      threshold factor and the low threshold factor, options to perform normal thresholding     or hysteresis thresholding and option to perform thinning or not. The output is of      byte data type. All the functions are in the file boiecox_edge.c       TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to the processed image&nbsp;HISTORY     History information recorded: NoneSEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 2004 SIUE - by Scott Umbaugh.\n\r\n\r&nbsp;","boiecox_filter","scr\\CVIP_C_functions/boiecox_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-04T21:55:00Z  2004-10-19T23:45:00Z  1  428  2440  SIUE  20  5  2863  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME      btc_compress, btc_decompress -  2  level  Block  Truncation     Coding (BTC) scheme&nbsp;SYNOPSIS      #include &lt;stdio.h&gt;      #include &lt;string.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;block_trunc_coding.h&quot;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;&nbsp;     int  btc_compress(Image  *inputImage,  char  *filename,  int     blocksize)&nbsp;      &lt;inputImage&gt; - pointer to an Image structure      &lt;filename&gt; - character array      &lt;blocksize&gt; - blocksize&nbsp;     Image* btc_decompress(char *filename)&nbsp;      &lt;filename&gt; - character array&nbsp;&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\block_trunc_coding.c&nbsp;DESCRIPTION     The image is first divided into blocks, and then the digital     representation  of each pixel in a block is truncated to one     bit by  thresholding  and  moment  preserving  selection  of     binary levels.&nbsp;     The function code was developed from  Chapter  5  Section  6     &quot;Block  Truncation  Compression&quot;  (P176  - P181) in &quot;Digital     Picture Processing&quot; Volume1, second edition,  Azriel  Rosen-     feld  and  Avinash  C.  KakYiyan.  Academic  Press, INC. San     Diego, CA. 1982&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     btc_compress: 0 on success, -1 on failure&nbsp;     btc_decompression:  an   uncompressed   image   pointer   on     success,a NULL pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;block_trunc_coding.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;      void main() {        Image *cvipImage, *outImage;        IMAGE_FORMAT format;        char *inputfile, *outputfile;        int blocksize;&nbsp;        setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);        inputfile =(char *) getString_CVIP();        cvipImage = read_Image(inputfile, 1);        view_Image(cvipImage, inputfile);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the block size:&quot;);        blocksize = getInt_CVIP(10, 0, 64);        print_CVIP(&quot;\\n\\t\\tEnter the Compressed File Name:&quot;);        outputfile =(char *) getString_CVIP();&nbsp;        if (btc_compress(cvipImage,outputfile,blocksize)&lt;0) {          error_CVIP(&quot;btc_compress&quot;, &quot;compression failed&quot;);          exit(1);        } else if ((outImage=btc_decompress(outputfile))==NULL){          error_CVIP(&quot;btc_decompress&quot;, &quot;decompression failed&quot;);          exit(1);        } else view_Image(outImage, outputfile);&nbsp;        free(inputfile);        free(outputfile);      }&nbsp;BUGS     For gray level images, the compression ratios are not calcu-     lated correctly.&nbsp;SEE ALSO     COMPRESSION library,       btc2_compress(),       btc2_decompress(),     btc3_compress(), btc3_decompress()&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh, Kui Cai.\n\r\n\r&nbsp;","btc_compress,btc_decompress","scr\\CVIP_C_functions/btc_compress, btc_decompress.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  3  2004-06-04T21:51:00Z  2004-10-19T23:44:00Z  1  440  2514  SIUE  20  5  2949  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     btc2_compress, btc2_decompress - a Block  Truncation  Coding     (BTC) scheme using multilevel coding&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPhisto.h&quot;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;&nbsp;     int btc2_compress(Image  *inputImage,  char  *filename,  int     blocksize)&nbsp;      &lt;inputImage&gt; - pointer to an Image structure      &lt;filename&gt; - character array      &lt;blocksize&gt; - blocksize&nbsp;     Image* btc2_decompress(char *filename)&nbsp;      &lt;filename&gt; - character array&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\m_btc.c&nbsp;DESCRIPTION     Multilevel BTC is a form of  block  truncation  coding  that     greatly  improves  the  resulting image fidelity compared to     the use of the standard BTC, when applied to  visually  com-     plex  images. The improvement comes from the use of a minmax     error criterion  in  place  of  the  conventional  two-level     moment-preserving quantizer. This approach to implementation     uses block quantization map encoding and decoding.&nbsp;     The function code was developed from &quot;Multilevel Block Trun-     cation  Coding  Using  a  Minimax  Error Criterion for High-     Fidelity Compression of Digital Images.&quot;, Yiyan Wu and David     C.  Coll, IEEE TRANSACTIONS ON COMMUNICATIONS. VOL.41, NO.8,     AUGUST 1993&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     btc2_compress: 0 on success, -1 on failure&nbsp;     btc2_decompression:  an  uncompressed   image   pointer   on     success,a NULL pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPhisto.h&gt;      #include &lt;CVIPcompress.h&gt;&nbsp;      void main() {        Image *cvipImage, *outImage;        IMAGE_FORMAT format;        char *inputfile, *outputfile;        int blocksize;&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);        inputfile =(char *) getString_CVIP();&nbsp;        cvipImage = read_Image(inputfile, 1);        view_Image(cvipImage, inputfile);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the block size:&quot;);        blocksize = getInt_CVIP(10, 0, 64);        print_CVIP(&quot;\\n\\t\\tEnter the Compressed File Name:&quot;);        outputfile =(char *) getString_CVIP();&nbsp;        if (btc2_compress(cvipImage,outputfile,blocksize)&lt;0) {          error_CVIP(&quot;btc2_compress&quot;, &quot;compression failed&quot;);          exit(1);        } else if ((outImage=btc2_decompress(outputfile))==NULL){          error_CVIP(&quot;btc2_decompress&quot;, &quot;decompression failed&quot;);          exit(1);        } else view_Image(outImage, outputfile);&nbsp;        free(inputfile);        free(outputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     COMPRESSION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott  Umbaugh,  Zhen  Li,  and     Hong Niu.&nbsp;\n\r\n\r&nbsp;","btc2_compress,btc2_decompress","scr\\CVIP_C_functions/btc2_compress, btc2_decompress.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  3  2004-06-04T21:52:00Z  2004-10-19T23:45:00Z  1  441  2519  SIUE  20  5  2955  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     btc3_compress - a Block Truncation Coding (BTC) scheme using     predictive multilevel coding&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPhisto.h&quot;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;&nbsp;     int btc3_compress(Image  *inputImage,  char  *filename,  int     blocksize)&nbsp;      &lt;inputImage&gt; - pointer to an Image structure      &lt;filename&gt; - character array      &lt;blocksize&gt; - blocksize&nbsp;     Image *btc3_decompress(char *filename)&nbsp;      &lt;filename&gt; - character array&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\m_btc.c&nbsp;DESCRIPTION     Predictive multilevel BTC is another form of  block  trunca-     tion  coding  (see  btc2)  that improves the resulting image     fidelity compared to the  use  of  the  standard  BTC,  when     applied to visually complex images. The improvement with the     predictive method comes  from  the  use  of  interblock  and     intrablock prediction and vector encoding/decoding, in place     of the conventional two-level moment-preserving quantizer.&nbsp;     The function code was developed from &quot;Multilevel Block Trun-     cation  Coding  Using  a  Minimax  Error Criterion for High-     Fidelity Compression of Digital Images.&quot;, Yiyan Wu and David     C.  Coll, IEEE TRANSACTIONS ON COMMUNICATIONS. VOL.41, NO.8,     AUGUST 1993&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     btc3_compress: 0 on success, -1 on failure&nbsp;     btc3_decompression:  an  uncompressed   image   pointer   on     success,a NULL pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPhisto.h&gt;      #include &lt;CVIPcompress.h&gt;&nbsp;      void main() {        Image *cvipImage, *outImage;        IMAGE_FORMAT format;        char *inputfile, *outputfile;        int blocksize;&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);        inputfile =(char *) getString_CVIP();&nbsp;        cvipImage = read_Image(inputfile, 1);        view_Image(cvipImage, inputfile);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the block size:&quot;);        blocksize = getInt_CVIP(10, 0, 64);        print_CVIP(&quot;\\n\\t\\tEnter the Compressed File Name:&quot;);        outputfile =(char *) getString_CVIP();&nbsp;        if (btc3_compress(cvipImage,outputfile,blocksize)&lt;0) {          error_CVIP(&quot;btc3_compress&quot;, &quot;compression failed&quot;);          exit(1);        } else if ((outImage=btc3_decompress(outputfile))==NULL){          error_CVIP(&quot;btc3_decompress&quot;, &quot;decompression failed&quot;);          exit(1);        } else view_Image(outImage, outputfile);&nbsp;        free(inputfile);        free(outputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     COMPRESSION library     &nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott  Umbaugh,  Zhen  Li,  and     Hong Niu.&nbsp;\n\r\n\r&nbsp;","btc3_compress","scr\\CVIP_C_functions/btc3_compress.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-04T21:56:00Z  2004-10-19T23:45:00Z  1  649  3700  SIUE  30  8  4341  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Butterworth_Band_Pass  -  performs  Butterworth  band   pass     filtering&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;&nbsp;     Image    *Butterworth_Band_Pass(Image     *in_Image,     int     block_size, int dc, int inner, int outer, int order)&nbsp;      &lt;in_Image&gt; - pointer to an Image structure      &lt;block_size&gt; - desired block size      &lt;dc&gt; - drop(0) or retain(1) dc component      &lt;inner&gt; - inner cutoff frequency      &lt;outer&gt; - outer cutoff frequency      &lt;order&gt; - filter order&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\filter.c&nbsp;DESCRIPTION     This function performs two-dimensional Butterworth  bandpass     filtering  in  transform  domain  on input image. The filter     transfer function of order &lt;order&gt; is:             H(u,v) = -[ {1 / (1+ pow(k, 2*f_order))} -1]           where k = D(u,v)W/[pow(D(u,v), 2) - pow(D0, 2)]     D(u, v) is the distance from the origin, W the width of  the     band,  and  D0  is  the  center of the band. W is calculated     using the inner and outer cut-off frequencies specified. The     frequency  components  within the band enclosed by inner and     outer cut-off frequencies are not attenuated. All other fre-     quency  components outside the band are attenuated according     to the transfer function.  The band is a 1/4 of  a  circular     band if the dc component is on the upper left-hand corner of     its transform plane. If dc equals 1, the dc  component  will     be retained, if dc equals, the dc component will be dropped.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A filtered image&nbsp;HISTORY     History information recorded: None&nbsp;DIAGNOSTICS       The Butterworth_Band_Pass filter will work for both  real-     valued  and imaginary-valued transform. If the origin of the     transform is on the center of its frequency plane (shifted),     the  cutoff  frequencies can range from 1 to blocksize/2 and     the Butterworth_Band_Pass function can  be  called  directly     with  correct  parameters. If the origin of the transform is     on the  upper  left-hand  corner  of  its  frequency  plane,     nonfft_xformfilter()     must     be     used     to    call     Butterworth_Band_Pass() with filtertype  =  6.   The  cutoff     frequencies in this case can range from 1 to blocksize since     a block is treated as a quarter of a regular block with  its     origin  on  the center. If bpf_setup() is to be used to call     Butterworth_Band_Pass(), the transform  must  be  setup  and     recognized  by  bpf_setup(),  otherwise  the  setup  program     automatically assumes the transform\'s dc  component  is   on     the center (dcpos=1).&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the fft_transform on the      input image with the block size equal to 256 */      cvipImage=fft_transform(cvipImage,256);      /* the following call performs the butterworth band pass      filtering of order 2 on the transformed image with the      lower cut off equal to 0 and the higher cut off equal      to 64 */      cvipImage = Butterworth_Band_Pass(cvipImage,256,1,0,64,2);      /* the following call performs the inverse fft_transform in      the filtered image with the block size equal to 256 */      cvipImage = ifft_transform(cvipImage,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Simon Low.&nbsp;\n\r\n\r&nbsp;","Butterworth_Band_Pass","scr\\CVIP_C_functions/Butterworth_Band_Pass.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  1  2004-06-04T21:57:00Z  2004-10-19T23:46:00Z  1  655  3736  SIUE  31  8  4383  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Butterworth_Band_Reject - performs Butterworth  band  reject     filtering&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;&nbsp;     Image    *Butterworth_Band_Reject(Image    *in_Image,    int     block_size, int dc, int inner, int outer, int order)&nbsp;      &lt;in_Image&gt; - pointer to an Image structure      &lt;block_size&gt; - desired block size      &lt;dc&gt; - drop(0) or retain(1) dc component      &lt;inner&gt; - inner cutoff frequency      &lt;outer&gt; - outer cutoff frequency      &lt;order&gt; - filter orderPATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\filter.c&nbsp;DESCRIPTION      Butterworth_Band_Reject() performs two-dimensional  butter-     worth  bandreject  filtering  in  transform  domain on input     image. The filter transfer function of order &lt;order&gt; is:                  H(u,v) = 1 / (1+ pow(k, 2*order))         where k = D(u,v)W / [pow(D(u,v), 2) - pow(D0, 2)]     D(u, v) is the distance from the origin, W the width of  the     band,  and  D0  is  the  center of the band. W is calculated     using the inner and outer cut-off frequencies specified. The     frequency  components  within the band enclosed by inner and     outer cut-off frequencies are attenuated  according  to  the     transfer function.  All frequencies outside the band are not     attenuated.  The band is a 1/4 of a circular band if the  dc     component  is on the upper left-hand corner of its transform     plane. If dc equals 1, the dc component will be retained, if     dc equals, the dc component will be dropped.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A filtered image&nbsp;HISTORY     History      information      recorded:       None       The     Butterworth_Band_Reject  filter  will  work  for  both real-     valued and imaginary-valued transform. If the origin of  the     transform is on the center of its frequency plane (shifted),     the cutoff frequencies can range from 1 to  blocksize/2  and     the  Butterworth_Band_Reject function can be called directly     with correct parameters. If the origin of the  transform  is     on  the  upper  left-hand  corner  of  its  frequency plane,     nonfft_xformfilter()    must     be     used     to     call     Butterworth_Band_Reject()  with  filtertype = 8.  The cutoff     frequencies in this case can range from 1 to blocksize since     a  block is treated as a quarter of a regular block with its     origin on the center. If brf_setup() is to be used  to  call     Butterworth_Band_Reject(),  the  transform must be setup and     recognized  by  brf_setup(),  otherwise  the  setup  program     automatically assumes the transform\'s dc component is on the     center (dcpos=1).&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the fft_transform on the      input image with the block size equal to 256 */      cvipImage=(Image *)fft_transform(cvipImage,256);      /* the following call performs the butterworth band reject      filtering of order 2 on the transformed image with the      lower cut off equal to 0 and the higher cut off equal to 64     */      cvipImage = (Image *)Butterworth_Band_Reject(cvipImage,      256,1,0,64,2);      /* the following call performs the inverse fft_transform in      the  filtered image with the block size equal to 256 */      cvipImage = (Image *)ifft_transform(cvipImage,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Simon Low.&nbsp;\n\r\n\r&nbsp;","Butterworth_Band_Reject","scr\\CVIP_C_functions/Butterworth_Band_Reject.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  3  2004-06-04T21:59:00Z  2004-10-19T23:46:00Z  1  609  3475  SIUE  28  8  4076  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Butterworth_High - performs Butterworth highpass filtering&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;&nbsp;     Image *Butterworth_High(Image *in_Image, int block_size, int     dc, int cutoff, int order)&nbsp;      &lt;in_Image&gt; - pointer to an Image structure      &lt;block_size&gt; - desired block size      &lt;dc&gt; - drop(0) or retain(1) dc component      &lt;cutoff&gt; - cutoff frequency      &lt;order&gt; - filter order&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\filter.c&nbsp;DESCRIPTION     Butterworth_High()  performs   two-dimensional   butterworth     highpass  filtering in transform domain on input image.  The     parameter cutoff defines  the  cut-off  frequency  locus  at     points  for  which the filter transfer function H(u,v) is at     0.7071 of its maximum value. All components inside the  cir-     cle (or 1/4 circle if dc component is on the upper-left-hand     corner of  its  transform  plane)  of  radius  &quot;cutoff&quot;  are     attenuated  according  to  the  transition  from passband to     stopband, depending on the degree of filter  order  f_order.     All  frequencies   component outside the circle (or 1/4 cir-     cle) are passed with no attenuation.   If dc equals  1,  the     dc   component  will  be  retained, if dc = 0, dc componenet     will be dropped.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A filtered image&nbsp;HISTORY     History information recorded: None&nbsp;DIAGNOSTICS      The Butterworth_High filter will work for both  real-valued     and  imaginary-  valued  transform.  If  the  origin  of the     transform is on the center of its frequency plane (shifted),     the cutoff frequency can range from 1 to blocksize/2 and the     Butterworth_High  function  can  be  called  directly   with     correct   parameters.  If  the origin of the transform is on     the  upper  left-hand  corner  of   its   frequency   plane,     nonfft_xformfilter() must be used to call Butterworth_High()     with filtertype=4. The cutoff frequency in   this  case  can     range  from  1  to  blocksize  since a block is treated as a     quarter of a regular block with its origin on the center. If     hpf_setup()  is  to  be used to call Butterworth_High(), the     transform must be setup and recognized by hpf_setup(),  oth-     erwise   the   setup   program   automatically  assumes  the     transform\'s dc component is on the center (dcpos=1).&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the fft_transform on      the input image with the block size equal to 256 */      cvipImage=(Image *)fft_transform(cvipImage,256);      /* the following call performs the butterworth high      pass filtering of order 2 on the transformed image with      the cut off frequency equal to 64 */      cvipImage = (Image *)Butterworth_High(cvipImage,256,      1,64,2);      /* the following call performs the inverse fft_transform      in the filtered image with the block size equal      to 256 */      cvipImage = (Image *)ifft_transform(cvipImage,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSOXFORMFILTERlibrary    AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Simon Low.&nbsp;\n\r\n\r&nbsp;","Butterworth_High","scr\\CVIP_C_functions/Butterworth_High.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-04T22:01:00Z  2004-10-19T23:46:00Z  1  573  3271  SIUE  27  7  3837  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Butterworth_Low - performs Butterworth lowpass filtering&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;&nbsp;     Image *Butterworth_Low(Image *in_Image, int block_size,  int     dc, int cutoff, int order)&nbsp;      &lt;in_Image&gt; - pointer to an Image structure      &lt;block_size&gt; - desired block size      &lt;dc&gt; - drop(0) or retain(1) dc component      &lt;cutoff&gt; - cutoff frequency      &lt;order&gt; - filter order&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\filter.c&nbsp;DESCRIPTION      Butterworth_Low()  performs   two-dimensional   butterworth     lowpass  filtering  in transform domain on input image.  The     parameter cutoff defines  the  cut-off  frequency  locus  at     points  for  which the filter transfer function H(u,v) is at     0.7071 of its maximum value. All components inside  the  the     circle  (or 1/4 circle if dc component is on the upper-left-     hand corner of its transform plane) of radius  &quot;cutoff&quot;  are     passed  with  no  attenuation, while all frequencies outside     the circle (or 1/4 circle) are attenuated by the  transition     from  passband  to  stopband  which  depend on the degree of     filter order f_order. If dc equals 1, the dc component  will     be retained, if dc = 0, dc componenet will be dropped.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A filtered image&nbsp;HISTORY     History information recorded: None&nbsp;DIAGNOSTICS     Butterworth_Low()   performs   two-dimensional   butterworth     lowpass  filtering  in transform domain on input image.  The     parameter cutoff defines  the  cut-off  frequency  locus  at     points  for  which the filter transfer function H(u,v) is at     0.7071 of its maximum value. All components inside  the  the     circle  (or 1/4 circle if dc component is on the upper-left-     hand corner of its transform plane) of radius  &quot;cutoff&quot;  are     passed  with  no  attenuation, while all frequencies outside     the circle (or 1/4 circle) are attenuated by the  transition     from  passband  to  stopband  which  depend on the degree of     filter order f_order. If dc equals 1, the dc component  will     be retained, if dc = 0, dc componenet will be dropped.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the fft_transform on the      input image with the block size equal to 256 */      cvipImage=(Image *)fft_transform(cvipImage,256);      /* the following call performs the butterworth low pass      filtering of order 2 on the transformed image with      the cut off frequency equal to 64 */      cvipImage = (Image *)Butterworth_Low(cvipImage,256,1,64,2);      /* the following call performs the inverse fft_transform      in the filtered image with the block size equal to 256 */      cvipImage = (Image *)ifft_transform(cvipImage,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER LIBRARY&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Simon Low.&nbsp;\n\r\n\r&nbsp;","Butterworth_Low","scr\\CVIP_C_functions/Butterworth_Low.htm","   ACADEMIC COMPUTING  Normal  akharba  7  25  2004-07-03T22:35:00Z  2006-07-08T22:34:00Z  1  398  2273  SIUE  18  5  2666  11.5606      false  false  false                  MicrosoftInternetExplorer4   NAME     canny_filter – performs a Canny edge detection on the image&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPspfltr.h&gt;&nbsp;     Image *canny_filter(float low, float high, float var,                          Image *inputImage, Image *nonmax_mag,                         Image *nonmax_dir)&nbsp;      &lt;inputImage&gt; - pointer to the input Image structure      &lt;low&gt; - Low threshold scale factor for the hysteresis               threshold.              0.0 &lt; low_factor &lt; 10       &lt;high&gt; - High threshold scale factor for the hysteresis                threshold.               low_factor &lt; high_factor &lt; 10      &lt;var&gt; - Variance…0.5 &lt;= var &lt;= 5 of the Gaussian filter       &lt;nonmax_mag&gt; - pointer to an intermediate magnitude image structure after non maxima                      suppression      &lt;nonmax_dir&gt; - pointer to an intermediate phase image structure after non maxima                      suppression &nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\canny_filter.c&nbsp;DESCRIPTIONcanny_filter function applies Canny’s edge detector to an input image. The inputs of all data types are accepted but the integer and float type inputs are remapped to short. The function takes 3 parameters as input variance of the Gaussian, the high threshold factor and the low threshold factor.The output is of byte data type. All the function are in the file canny_edge_detection.c. Canny’s edge detector is optimal for step edges corrupted by white noise.  It proposes 3 main criteria detection, localization and one response. The algorithm is as follows:Smooth the image with a Gaussian known variance which is provided as an input, to mitigate noise effect. Apply the derivative of the Gaussian which according to Canny was the optimal edge filter.  Compute the magnitude and phase images. Apply non maxima suppression to eliminate spurious edges. Apply hysteresis thresholding. The threshold values for hysteresis thresholding are computed from the non maxima suppressed magnitude image so that the high threshold is greater that 90% of the pixels and the low threshold is the average of the high threshold and the minimum value in the image. Final high threshold used for hysteresis = high threshold computed from image * high_factorFinal low threshold used for hysteresis = low threshold computed from image * low_factor&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Returns the edge detected image&nbsp;HISTORY     History information recorded: NoneSEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh.\n\r\n\r&nbsp;","canny_filter","scr\\CVIP_C_functions/canny_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  6  2004-06-04T22:02:00Z  2004-10-19T23:49:00Z  1  138  792  SIUE  6  1  929  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     cbrt_Matrix - computes the square root of a matrix.&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPmatrix.h&quot;&nbsp;     Matrix *cbrt_Matrix(Matrix *in)&nbsp;      &lt;in&gt; - input Matrix;&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\MatrixAlgebra\\m_sqrt.c&nbsp;DESCRIPTION     This function calculates the cube root of the passed  matrix     structure  and returns the result in a new Matrix structure.     All data types less  precise  than  float  are  promoted  to     float.   CVIP_DOUBLE matrices are supported, as well as COM-     PLEX matrices.&nbsp;     The passed matrix structure is freed.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     Pointer to Matrix structure containing the cube root of  the     passed Matrix.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE&nbsp;BUGS     None at this time&nbsp;SEE ALSO     MatrixAlgebra library, sqrt_Matrix()&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Arve Kjoelen&nbsp;\n\r\n\r&nbsp;","cbrt_Matrix","scr\\CVIP_C_functions/cbrt_Matrix.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  6  9  2004-06-04T22:08:00Z  2006-01-26T19:46:00Z  1  360  2053  SIUE  17  4  2409  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     centroid - calculates centroid coordinates of an  object  of     interest&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;&nbsp;     int * centroid(Image * labeledImage, int r, int c)&nbsp;      &lt;labeledImage&gt; -  pointer to a labeled image      &lt; r &gt; - row coordinate of a point on the labeled image      &lt; c &gt; - column coordinate of a point on the labeled image&nbsp;&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\binary_feature.c&nbsp;DESCRIPTION     The program  calculates  the  centroid  coordinates  of  the     object  of  interest on the labeled image according to equa-     tions given in chapter 3 of the book:&nbsp;                               Computer Imaging:                  Digital Image Analysis and Processing &nbsp;                   Scott E Umbaugh, CRC Press, 2005&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to int; first value is the row coordinate, second     is column coordinate.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPobject.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPfeatures.h&quot;&nbsp;      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;&nbsp;      void main() {         Image *inputImage, *labeledImage;         IMAGE_FORMAT format;         char *inputfile, *outputfile;         int rows, cols, r, c;         int *result;&nbsp;         setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;         print_CVIP(&quot;\\nEnter the Input File Name:  &quot;);         inputfile = (char *) getString_CVIP();         inputImage = read_Image(inputfile, format, TRUE);         view_Image(inputImage,inputfile);&nbsp;         labeledImage = label(inputImage);&nbsp;         rows = getNoOfRows_Image(labeledImage);         cols = getNoOfCols_Image(labeledImage);&nbsp;         print_CVIP(&quot;\\nEnter the row coordinate of any  pixel  on     the labled image: &quot;);         r = getInt_CVIP(10, 0, rows);         print_CVIP(&quot;\\nEnter the col coordinate of any  pixel  on     the labled image: &quot;);         c = getInt_CVIP(10, 0, cols);&nbsp;         result = centroid(labeledImage, r, c);         print_CVIP(&quot;The centroid of the object  (r,  c)  =  (%d,     %d)&quot;, *result, *(result+1) );         print_CVIP(&quot;\\n&quot;);&nbsp;         free(inputfile);       }&nbsp;DIAGNOSTICS     The labeled image can only of data type CVIP_INTEGER&nbsp;SEE ALSO     FEATURE library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","centroid","scr\\CVIP_C_functions/centroid.htm","   Mounika  Normal  jhansi  88  48  2004-06-04T21:33:00Z  2010-01-06T21:54:00Z  1  286  1633  SIUE  13  3  1916  11.9999    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4        NAME&nbsp;&nbsp;&nbsp;&nbsp; cerchar_filter - a spatial- multi spectral image edge detection filter.&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPtoolkit.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPconvert.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPdef.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPimage.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPspfltr.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image&nbsp;&nbsp;&nbsp; Cerchar_Filter(Image* inputImage);&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;inputImage&gt; - pointer to an Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;PATH&nbsp;&nbsp;&nbsp;&nbsp; $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\cerchar_filter.c&nbsp;DESCRIPTION\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;Cervenka and CharvatFilter is used to find the edges in multispectral images.This can be applied to three band color images, as well as multispectralsatellite images.\n\r\n\rThe result of this edgedetector at pixel (r,c) is\n\r\n\r&nbsp;&nbsp;                              \n\r\n\r \n\r\n\r&nbsp;\n\r\n\r&nbsp;\n\r\n\rIb(r,c) is the arithmetic average of all the pixels inall bands at pixel location (r,c)&nbsp;&nbsp; \n\r\n\r &nbsp;isthe value at location (r,c) in the bth band, with a total of n bands&nbsp;TYPES AND CONSTANTS&nbsp;&nbsp;&nbsp;&nbsp; None&nbsp;RETURN VALUES&nbsp;&nbsp;&nbsp;&nbsp; Pointer to the processed image&nbsp;HISTORY&nbsp;&nbsp;&nbsp;&nbsp; History information recorded: None&nbsp;EXAMPLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPtoolkit.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPconvert.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPdef.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPimage.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPspfltr.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void main() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image *cvipImage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMAGE_FORMAT format;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *inputfile,*outputfile;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void) setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_CVIP(&quot;\\n\\t\\tEnter the&nbsp; Input File Name:&nbsp; &quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputfile =(char *) getString_CVIP();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; format = getFormat_CVIP(inputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvipImage = read_Image(inputfile,1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view_Image(cvipImage, inputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(inputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvipImage = cerchar_filter(cvipImage);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:&nbsp; &quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputfile = getString_CVIP();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view_Image(cvipImage,outputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(outputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; SPATIALFILTER library&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 2010 SIUE - by Scott Umbaugh and Mounika Mamidi.&nbsp;\n\r\n\r&nbsp;","cerchar_filter","scr\\CVIP_C_functions/cerchar_filter.html","   ACADEMIC COMPUTING  Normal  akharba  6  5  2005-07-02T19:38:00Z  2006-07-08T22:23:00Z  1  265  1515  SIUE  12  3  1777  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        city_block – calculates the city block or absolute value metric&nbsp;SYNOPSIS#include &quot;math.h&quot;     float city_block(float *vector1, float *vector2, int n)      &lt;vector1&gt; - pointer to an input array&lt;vector2&gt; - pointer to an input array&lt;n&gt; - number of elements (features) in the array&nbsp;&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\city_block.c&nbsp;DESCRIPTION     This function calculates the city block or absolute value      distance measure from the elements of the two arrays. The      formula used for the calculation is given in chapter 6 of      the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 3\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       float  *vector1;\n\r\n\r       float  *vector2;\n\r\n\r       float  result;\n\r\n\r       int           i;\n\r\n\r&nbsp;\n\r\n\r       vector1 = malloc(MAX_CASE*sizeof(float));\n\r\n\r       vector2 = malloc(MAX_CASE*sizeof(float));\n\r\n\r&nbsp;\n\r\n\r       /* Get the vectors. The items should beseparated by &quot;,&quot; */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector1: &quot;);\n\r\n\r       for(i=0;i&lt;MAX_CASE;i++)\n\r\n\r       {\n\r\n\r              scanf(&quot;%f,&quot;,&amp;vector1[i]);\n\r\n\r       }\n\r\n\r       \n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector1: &quot;);\n\r\n\r       for(i=0;i&lt;MAX_CASE;i++)\n\r\n\r       {\n\r\n\r              scanf(&quot;%f,&quot;,&amp;vector2[i]);\n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       result = city_block(vector1, vector2,MAX_CASE);\n\r\n\r       \n\r\n\r       /* Print out the result */\n\r\n\r       printf(&quot;result=%f\\n&quot;,result);\n\r\n\r&nbsp;\n\r\n\r       /* Free the pointers */\n\r\n\r       free(vector1);\n\r\n\r       free(vector2);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A float number representing the city block distance measure&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","city_block","scr\\CVIP_C_functions/city_block.htm","   ACADEMIC COMPUTING  Normal  Mounika  30  41  2004-06-04T22:09:00Z  2010-04-30T15:48:00Z  2  527  3007  SIUE  25  7  3527  11.5606    105    false  false  false                  MicrosoftInternetExplorer4   NAME     Color_contrast_enhance – Improves the color of the image&nbsp;SYNOPSIS\n\r\n\r#include &quot;CVIPdef.h&quot;\n\r\n\r#include &quot;CVIPcomplex.h&quot;\n\r\n\r#include &quot;CVIPtoolkit.h&quot;\n\r\n\r#include &quot;CVIPcolor.h&quot;\n\r\n\r#include &lt;math.h&gt;\n\r\n\r#include &quot;CVIPconvert.h&quot;\n\r\n\r#include &quot;CVIPimage.h&quot;\n\r\n\r#include &quot;CVIPtyp.h&quot;\n\r\n\r#include &quot;histogram.h&quot;\n\r\n\r#include &quot;CVIPhisto.h&quot;\n\r\n\r#include &lt;CVIPband.h&gt;      #include &quot;CVIPcolor.h&quot;&nbsp;\n\r\n\r            Image*color_contrast_enhance(Image *inputImage, int low_limit,int high_limit, \n\r\n\r      float low_clip,float high_clip&nbsp;      &lt; inputImage&gt; - pointer to an Image structure (data type equal       to or less precise than type CVIP_FLOAT)      &lt;low_limit&gt; - lower limit for stretch      &lt;high_limit&gt; - higher limit for stretch      &lt;low_clip&gt; - percentage of low values to clip before stretching      &lt;high_limit&gt; - percentage of high values to clip before stretching &nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COLOR\\color_contrast_enhance.c&nbsp;DESCRIPTION\n\r\n\rColor contrast enhance is an algorithm used createbrighter and \n\r\n\rbetter images. This takes color image as input. \n\r\n\rThis performs the HSL transform and performsdifferent\n\r\n\rprocesses in step by step process. First remap theimage to\n\r\n\rCVIP_BYTE and then perform HSL transform, nextextract the hue band,\n\r\n\rsaturation band and lightness band. Remap thesaturation band \n\r\n\rto CVIP_BYTE and then perform histogramequalization, which improves\n\r\n\rand intensifies color richness. Cast the luminanceband to CVIP_FLOAT\n\r\n\rthen perform a histogram stretch on the luminanceband to improve the\n\r\n\rcontrast. After the histogram stretch, exceptluminance band the other\n\r\n\rtwo bands are in BYTE format so cast the luminanceto CVIP_FLOAT then\n\r\n\rcombine processed HSL bands and then apply inverseHSL transform.\n\r\n\rThis function increases contrast in an image bystretching the histogram\n\r\n\rto span the range low_limit to high_limit. Toimprove performance of \n\r\n\rthe function when outliers are present, percentageslow_clip and\n\r\n\rhigh_clip pixel values can be removed before thestretch takes place.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to transformed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPcomplex.h&gt;      #include &lt;CVIPcolor.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      float norm[3]={255.0,255.0,255.0};      float ref[3]={1.0,1.0,1.0};            setDisplay_Image(VIEWER, &quot;Default&quot;);      /* The input image should be a COLOR one */      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* /* the following call ranges the histogram between 0      and 255.Before the ranging is done, the histogram is      clipped with the low level being 0.025 and the high level      being 0.025 */      cvipImage=color_contrast_enhance(cvipImage,10,200,0.025,0.025);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,VIP,1);      free(outputfile);      }&nbsp;SEE ALSO     COLOR library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Mounika     Mamidi.&nbsp;\n\r\n\r&nbsp;","color_contrast_enhance","scr\\CVIP_C_functions/color_contrast_enhance.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-04T22:09:00Z  2004-10-19T23:49:00Z  1  548  3128  SIUE  26  7  3669  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     colorxform - transforms an RGB image into a new color space&nbsp;SYNOPSIS      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPcomplex.h&quot;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPcolor.h&quot;&nbsp;     Image  *  colorxform(const  Image  *rgbImage,   COLOR_FORMAT     newcspace, float *norm, float *refwhite, int dir)&nbsp;      &lt;rgbImage&gt; - pointer to an Image structure (data type equal     to or less precise than type CVIP_FLOAT)      &lt;newcspace&gt; - desired color space      &lt;norm&gt; - pointer to a normalization vector      &lt;refwhite&gt; - pointer to reference white values (for LUV and     LAB only)      &lt;dir&gt; - direction of transform (1 =&gt; (RGB-&gt;newcspace)  else     (newcspace-&gt;RGB)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COLOR\\cxform.c&nbsp;DESCRIPTION     Transforms an RGB image into a new color space specified  by     &lt;newcspace&gt;, one of...&nbsp;      HSL - Hue/Saturation/Lightness,      HSV - Hue/Saturation/Value,      SCT - Spherical Coordinates Transform,      CCT - Cylindrical Coordinates Transform,      LAB - C.I.E. L*a*b* Color Coordinate System,      LUV - C.I.E. L*u*v*  Color  Coordinate  System,      XYZ - Chromaticity  Coordinate System.&nbsp;     Each transform  requires  that  the  input  image  be   nor-     malized  between  0 and 1. A pointer to a normalization vec-     tor &lt;norm&gt; must be passed that contains a set of  values  to     normalize the  image  bands  with. (e.g. norm[0] = norm[1] =     norm[2] = 255.0). If &lt;norm&gt; is NULL then it will be  assumed     that  the  input  image is already normalized. colorxform is     capable of performing several inverse transforms as well. If     &lt;dir&gt;  is  passed as any other value except for one then the     inverse transform (&lt;newcspace&gt;-&gt;RGB)  will   be   performed.     Currently the only inverse transforms that are supported are     HSL-&gt;RGB  &amp;  HSV-&gt;RGB.  If  either  a   L*a*b*   or   L*u*v*     transform   is   requested   then  an  additional  parameter     &lt;refwhite&gt; must be  passed  as  well  (e.g.   refwhite[0]  =     refwhite[1]  = refwhite[2] = 1.0 ). All transforms will also     be normalized to the range [0.0 ... 1.0] except  for  L*a*b*     and  L*u*v*  whose  range will vary with different values of     reference white.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to transformed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPcomplex.h&gt;      #include &lt;CVIPcolor.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      float norm[3]={255.0,255.0,255.0};      float ref[3]={1.0,1.0,1.0};&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      /* The input image should be a COLOR one */      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call transforms an RGB image into      a new color space LUV */      cvipImage=colorxform(cvipImage,LUV,norm,ref,1);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,VIP,1);      free(outputfile);      }&nbsp;SEE ALSO     COLOR library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Greg     Hance.&nbsp;\n\r\n\r&nbsp;","colorxform","scr\\CVIP_C_functions/colorxform.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  3  2004-06-04T22:11:00Z  2004-10-19T23:50:00Z  1  388  2218  SIUE  18  5  2601  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     contra_filter - a non-linear mean filter which is better  at     removing  gaussian  type  noise and preserving edge features     than the mean filter.&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;float.h&gt;&nbsp;     Image *contra_filter(Image *imageP, int mask_size, int p)          &lt;imageP&gt; - pointer to Image structure.          &lt;mask_size&gt; - size of the filtering  window  (e.g.,  3-     &gt;3x3).          &lt;p&gt; - filter order.&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\spatial_filter.c&nbsp;OPTIONS     None.&nbsp;DESCRIPTION     Returns the sum of the pixels in the filter window raised to     the  power  &quot;p+3&quot;,  divided  by the sum of the pixels in the     filter window raised to  the  power  &quot;p&quot;.   Size  of  filter     should  be an odd integer limited from &lt; 3 - 31 &gt;, and order     of filter is limited from &lt;-5 to +5&gt;.&nbsp;TIPS     Works well on images containing positive  outlier  noise  if     the  parameter P is negative, and on images containing nega-     tive outlier noise if the parameter P is positive.  P should     remain small (3-3) for better performance.  Keep filter mask     size small to reduce blurring.&nbsp;DIAGNOSTICS     Returns the modified Image  structure  pointer  on  success;     returns  a  NULL pointer if the inpute Image datatype is not     CVIP_BYTE, and can\'t be cast to CVIP_FLOAT.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs a contra filter operation      with the mask size equal to 3 and order of filter equal      to 2*/      cvipImage = contra_filter(cvipImage,3,2);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;BUGS     None.&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE - by Scott E. Umbaugh and John     A Creighton.&nbsp;\n\r\n\r&nbsp;","contra_filter","scr\\CVIP_C_functions/contra_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  3  2004-06-04T22:12:00Z  2004-10-19T23:50:00Z  1  486  2772  SIUE  23  6  3252  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     convert_filetype - various conversion functions&nbsp;SYNOPSIS      Image *bintocvip(char *  raw_image,  FILE  *inputfile,  int     data_bands,   COLOR_ORDER   color_order,   INTERLEAVE_SCHEME     interleaved, int height, int width, CVIP_BOOLEAN verbose)&nbsp;      Image *ccctocvip(char *prog_name, FILE *cccfile,  int  ver-     bose)&nbsp;      Image   *epstocvip(char   *eps_image,   FILE    *inputfile,     CVIP_BOOLEAN verbose)&nbsp;      Image *giftocvip(char *name, FILE *in, int imageNumber, int     showmessage)&nbsp;      Image *iristocvip(char *f_name,FILE *fp,  int  format,  int     verb)&nbsp;      Image  *itextocvip(char   *itex_image,   FILE   *inputfile,     CVIP_BOOLEAN verbose)&nbsp;      Image *pnmtocvip(char *pnm_file, FILE *ifp, int format, int     verbose)&nbsp;      Image *rastocvip(char *rasterfile, FILE *ifp, int verbose)&nbsp;      Image *tifftocvip(char *tiff_file, int verbose)&nbsp;      Image *jpgtocvip(char *filename, int  colors,  CVIP_BOOLEAN     blocksmooth,  CVIP_BOOLEAN grayscale, CVIP_BOOLEAN nodither,     CVIP_BOOLEAN  verbose);   Default   Values:   colors:   256;     blocksmooth:  CVIP_NO; grayscale: CVIP_NO; nodither:CVIP_NO;     verbose: CVIP_YES;&nbsp;      Image *viptocvip( char *filename, FILE *file,  CVIP_BOOLEAN     verbose )&nbsp;      void  cviptobin(Image  *raw_Image,  char  *raw_image,  FILE     *outputfile,   COLOR_ORDER   color_order,  INTERLEAVE_SCHEME     interleaved, CVIP_BOOLEAN verbose)&nbsp;      void  cviptoccc(Image  *cvip_Image,  char  *ccc_name,  FILE     *cccfile, int maxcolor, int dermvis, int verbose)&nbsp;      void cviptoeps(Image *cvip_Image, char  *eps_name,  FILE  *     outputfile,   float   scale_x,   float  scale_y,  int  band,     CVIP_BOOLEAN verbose)&nbsp;      void  cviptogif(Image  *gif_Image,  char  *gif_name,   FILE     *outfp, int interlace, int verbose)      void cviptoitex(Image *cvip_Image,  char  *cvip_name,  FILE     *outputfile, char *image_comment, CVIP_BOOLEAN verbose)&nbsp;      void cviptoiris(Image *cvipImage,char *f_name,FILE  *fp,int     prt_type,int verb)&nbsp;      void cviptopnm(Image *cvip_Image,  char  *pnm_name  ,  FILE     *outfp, int verbose)&nbsp;      void  cviptoras(Image   *ras_Image,  char  *ras_name,  FILE     *outfp, int pr_type, int verbose)&nbsp;      void   cviptotiff(Image   *cvip_Image,   char   *tiff_name,     unsigned short compression,      unsigned short fillorder, long  g3options,  unsigned  short     predictor, long rowsperstrip, int verbose)&nbsp;      int cviptojpg(Image *cvipImage, char *filename,  int  qual-     ity,  CVIP_BOOLEAN  grayscale,  CVIP_BOOLEAN  optimize,  int     smooth, CVIP_BOOLEAN verbose, char *qtablesFile);&nbsp;      CVIP_BOOLEAN cviptovip( Image *cvipImage,  char  *filename,     FILE    *file,   CVIP_BOOLEAN   save_history,   CVIP_BOOLEAN     is_compressed, CVIP_BOOLEAN verbose)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\CONVERSION&nbsp;DESCRIPTION     Each function performs the file-type conversion specified in     its name.&nbsp;TYPES AND CONSTANTS     See individual function code for typedefs&nbsp;RETURN VALUES     An image of the appropriate type.&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     CONVERSION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Greg     Hance.&nbsp;\n\r\n\r&nbsp;","convert_filetype","scr\\CVIP_C_functions/convert_filetype.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:13:00Z  2004-10-19T23:50:00Z  1  395  2255  SIUE  18  5  2645  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     convolve_filter - convolves an image with a filter kernel.&nbsp;SYNOPSIS      #include &quot;CVIPtools.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPfs.h&quot;      #include &quot;CVIPmatrix.h&quot;&nbsp;      Image *convolve_filter(Image *imageP, Matrix *filP)&nbsp;      &lt;imageP&gt; - pointer to an Image      &lt;filP&gt; - pointer to a Matrix containing the kernel               to be convolved with &lt;imageP&gt;&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\spatial_tools.c&nbsp;DESCRIPTION     The convolve function performs a spatial convolution  of  an     input image with an input matrix. The input image must be of     type CVIP_BYTE or CVIP_SHORT.  The filter matrix must be  of     type  CVIP_FLOAT.  The  output  image  returned  is  of type     CVIP_SHORT.&nbsp;     This function assumes mirror (DCT) symmetry  on  edges,  but     does NOT flip the convolution mask before use.&nbsp;     A related function, get_default_filter, can be used to  pro-     vide the kernel &lt;filP&gt;.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Returns pointer to output image.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPmatrix.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage,*cvipImage1;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      Matrix *mat;      int i,j;      unsigned int row=3;      unsigned int col=3;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;)      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      mat=new_Matrix(row,col,CVIP_FLOAT,REAL);      if(mat==NULL)             printf(&quot;NULL&quot;);      /*Provides the filter kernel*/      for(i=0;i&lt;3;i++)       for(j=0;j&lt;3;j++)             ((float **)(mat-&gt;rptr))[i][j]=0.5;      /*The following call convolves the image with the      lowpass filter kernel got by the get_default_filter */      cvipImage1 = (Image *)convolve_filter(cvipImage,mat);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage1,outputfile);      write_Image(cvipImage1,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     new_Matrix&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh, Greg Hance,  and     Kun Luo.&nbsp;\n\r\n\r&nbsp;","convolve_filter","scr\\CVIP_C_functions/convolve_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T22:14:00Z  2004-10-19T23:50:00Z  1  724  4127  SIUE  34  9  4842  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     copy_paste - copy a subimage from one image and paste to the     same or another image&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPgeometry.h&gt;&nbsp;      Image *copy_paste( Image *srcImg, Image *destImg,        unsigned start_r, unsigned start_c, unsigned height,        unsigned width, unsigned dest_r, unsigned dest_c,        CVIP_BOOLEAN transparent);&nbsp;      &lt;srcImg&gt;  - source image to copy the subimage      &lt;destImg&gt; - destination image for pasting      &lt;start_r&gt; - row value of the upper-left corner of the                  subimage on srcImg      &lt;start_c&gt; - column value of the upper-left corner of the                  subimage on srcImg      &lt;height&gt;  - height of desired subimage      &lt;width&gt;   - width of desired subimage      &lt;dest_r&gt;  - row value of the upper-left corner of the                  destImg  area to paste the subimage      &lt;dest_c&gt;  - column value of the upper-left corner of the                  destImg area to paste the subimage      &lt;transparent&gt; - whether the paste is transparent or not&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\copy_paste.c&nbsp;DESCRIPTION     The copy_paste(3) function copies a subimage from the srcImg     and  paste  it  to  the  destImg. copy_paste is designed for     cross-image copy-paste, but it  also  works  for  copy-paste     within  the  same image, which is indicated by making srcImg     == destImg.&nbsp;     If the subimage is too large,  the  size  will  be  adjusted     automatically  so  the  subimage  can be successfully copied     from the srcImg and pasted to the destImg. At the same time,     an  error  message  is put to the standard error to warn the     user of the event. crop_paste  handles  any  CVIP_TYPE  data     types  by  first  boosting  both  images  to CVIP_FLOAT; and     remapping the resulting image to the data type of  the  des-     tImg.&nbsp;     When a subimage is copy-pasted from a REAL image to  a  COM-     PLEX image, the real data on srcImg is also used as the ima-     ginary data for pasting. When a subimage is copy-pasted from     a  COMPLEX  image  to a REAL image, the imaginary components     are discarded.&nbsp;     When copy-pasting from image of N bands to another image  of     M bands, band mapping is done in the following way. For band     band_no in the destImg, band (band_no*N/M) on the srcImg  is     used.  For example, when copying from single band image (N =     1) to a color image (M=3), the single band data is used  for     all  three bands in the resulting image (band_no = 0, 1, 2).     On the other hand, when copying from a three band image to a     single band image, only the red band is used.&nbsp;     For  a non-transparent pasting, the  original  data  in  the     destImg will be overwritten by the subimage from the srcImg.     On the other hand, a transparent pasting will add  the  data     of  the  subimage  to  the  existing destImg data. But other     region of the destImg might turn out to be relatively darker     when transparent pasting is used.&nbsp;TYPES AND CONSTANTS     NONE&nbsp;RETURN VALUES     The pasted Image pointer on success; a (Image *)NULL pointer     on  failure.   In any case, the input Image pointers will be     released.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPgeometry.h&gt;      #include &lt;CVIPview.h&gt;&nbsp;      void main()      {      Image *cvipImage, *cvipImage1;      IMAGE_FORMAT format;      char *inputfile, *outputfile;&nbsp;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the first Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the second Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage1 = read_Image(inputfile, 1);      view_Image(cvipImage1, inputfile);      free(inputfile);&nbsp;      /* the following call  copies a 100x100 area on cvipImage         beginning from (10, 10), and pastes it to the upper-left         corner on cvipImage1 non-transparently.       */      cvipImage = copy_paste(cvipImage, cvipImage1, 10, 10, 100,                  100, 0, 0, CVIP_NO);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      view_Image(cvipImage,outputfile);      free(outputfile);      }&nbsp;SEE ALSO     crop(3), GEOMETRY library&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Yansheng Wei&nbsp;\n\r\n\r&nbsp;","copy_paste","scr\\CVIP_C_functions/copy_paste.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:14:00Z  2004-10-19T23:50:00Z  1  222  1272  SIUE  10  2  1492  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     create_black - creates a black PGM image&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdrawimg.h&quot;&nbsp;     Image *create_black(int width, int height)&nbsp;      &lt;width&gt; - desired image width      &lt;height&gt; - desired image height&nbsp;DESCRIPTION     Creates a black PGM image of size height by width. Used as a     background image for certain geometric functions.&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\create_image.cTYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to an image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPdrawimg.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;)      /* the following call creates a black image of size       100 x 100 */&nbsp;      cvipImage = create_black(100,100);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1)     ;      free(outputfile);      }&nbsp;SEE ALSO      GEOMETRY library&nbsp;AUTHOR      Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh  and  Jianxin     Tan.&nbsp;\n\r\n\r&nbsp;","create_black","scr\\CVIP_C_functions/create_black.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:15:00Z  2004-10-19T23:50:00Z  1  284  1620  SIUE  13  3  1901  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     create_cosine - creates a cosine wave image&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;waves.h&quot;&nbsp;     Image  *create_cosine(int  img_size,  int   frequency,   int     choice)&nbsp;      &lt;img_size&gt; - number of rows (and columns) in new image      &lt;frequency&gt; - sine wave frequency      &lt;choice&gt; - enter 1 for horizontal, 2  for  vertical  cosine     wave&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\cosine.c&nbsp;DESCRIPTION     This function creates a horizontal or vertical  cosine  wave     image  of size img_sizeXimg_size, of frequency 1 to 256. For     each pixel in a  row, the pixel value is calculated as&nbsp;                  {127 + 128*Cos(2*PI*f*j/img_size)}&nbsp;     where f is the frequency chosen by the user  and  j  is  the     column number.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     A pointer to the new image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPdrawimg.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      /* the following call creates a image of size 100 x 100  wi     th  frequency   32 and the cosine wave in the horizontal dir     ection */&nbsp;      cvipImage = create_cosine(100,32,1);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      getFileFormat_Image(cvipImage);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1)     ;      free(outputfile);      }&nbsp;SEE ALSO      GEOMETRY library&nbsp;AUTHOR      Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh , Srinivas  M     adiraju, and   kun luo.&nbsp;\n\r\n\r&nbsp;","create_cosine","scr\\CVIP_C_functions/create_cosine.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  12  2004-06-04T22:16:00Z  2004-10-19T23:51:00Z  1  780  4447  SIUE  37  10  5217  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     create_image - functions to create simple images&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdrawimg.h&quot;&nbsp;      Image  *create_rectangle(int  im_width,  int  im_height,int      start_c,int start_r,int rect_width, int rect_height)      &lt;im_width&gt; - image width, number of columns      &lt;im_height&gt; - image height, number of rows      &lt;start_c&gt; - first column for rectangle      &lt;start_r&gt; - first row for rectangle      &lt;rect_width&gt; - width of rectangle      &lt;rect_height&gt; - rectangle height&nbsp;      Image  *create_circle(int   im_width,   int   im_height,int      center_c,int center_r,int radius)      &lt;im_width&gt; - image width, number of columns      &lt;im_height&gt; - image height, number of rows      &lt;center_c&gt; - circle center column coordinate      &lt;center_r&gt; - circle center row coordinate      &lt;radius&gt; - radius of circle&nbsp;      Image *create_degenerate_circle(int im_width, int im_height,int       Center_c,int center_r,int radius1, int radius2)      &lt;im_width&gt; - image width, number of columns      &lt;im_height&gt; - image height, number of rows      &lt;center_c&gt; - circle center column coordinate      &lt;center_r&gt; - circle center row coordinate      &lt;radius1&gt; - radius of circle      &lt;radius2&gt; - radius of the blur circle (Blur radius)      Note: The blur type is linear.&nbsp;      Image  *create_ellipse(int  im_width,  int  im_height,  int      center_r, int center_c, int hor_length, int ver_length)      &lt;im_width&gt;  - image width, number of columns      &lt;im_height&gt; - image height, number of rows      &lt;center_r&gt;  - ellipse center row coordinate      &lt;center_c&gt;  - ellipse center column coordinate      &lt;hor_length&gt; - horizontal length of ellipse      &lt;ver_length&gt; - vertical length of ellipse&nbsp;      Image   *create_line(int   im_width,   int    im_height,int      start_c,int start_r,int end_c, int end_r)      &lt;im_width&gt; - image width, number ofcolumns      &lt;im_height&gt; - image height, number of rows      &lt;start_c&gt; - first column coordinate of line      &lt;start_r&gt; - first row coordinate of line      &lt;end_c&gt; - last column of line      &lt;end_r&gt; - last row of line&nbsp;      Image *create_checkboard(int  im_width,  int  im_height,int      first_c,int first_r,int block_c,int block_r)      &lt;im_width&gt; - image width, number of columns      &lt;im_height&gt; - image height, number of rows      &lt;first_c&gt; - first column of checkerboard      &lt;first_r&gt; - first row fo checkerboard      &lt;block_c&gt; - width of checkerboard blocks      &lt;block_r&gt; - height of checkerboard blocks&nbsp;&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\create_image.c&nbsp;DESCRIPTION     These functions allow the user to  create  simple  geometric     binary  images. Each has an associated setup function of the     form create_&lt;shape&gt;_setup that can be called to  obtain  the     needed inputs.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     An image containing the desired shape.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPdrawimg.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      /* the following call creates a  image of size 100x100 with     the rectangle starting at location 8,8 and the width and the     height of the rectangle equals 64. */      cvipImage = create_rectangle(100,100,8,8,64,64);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      /* the following call creates a image of size 100x100  with     the  center  of the circle being 25,25 and the radius of the     circle equals 10 */      cvipImage = create_circle(100,100,25,25,10);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      /* the following call creates a image of size 100x100  with     the line starting at location 10,10 and ending at 50,50 */      cvipImage = create_line(100,100,10,10,50,50);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      /* the following call creates a image of size 100x100  with     the checkboard starting at location 10,10 and the width      and the height of the checkerboard equals 5 */      cvipImage = create_checkboard(100,100,10,10,5,5);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO    Geometry library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Jianxin     Tan.&nbsp;\n\r\n\r&nbsp;","create_image","scr\\CVIP_C_functions/create_image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:17:00Z  2004-10-19T23:51:00Z  1  273  1560  SIUE  13  3  1830  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     create_sine - creates a sine wave image&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;waves.h&quot;&nbsp;     Image *create_sine(int img_size, int frequency, int choice)&nbsp;      &lt;img_size&gt; - number of rows (and columns) in new image      &lt;frequency&gt; - sine wave frequency      &lt;choice&gt; - enter 1 for horizontal, 2 for vertical sine wave&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\sine.c&nbsp;DESCRIPTION     This function creates a horizontal  or  vertical  sine  wave     image  of size img_sizeXimg_size, of frequency 1 to 256. For     each pixel in a  row, the pixel value is calculated as  {127     +  128*Sin2(PI)*x*f}, where f is the frequency chosen by the     user and x is the row number.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     A pointer to the new image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPdrawimg.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      /* the following call creates a image of  size  100  x  100     with  freq  uency  32 and the sine wave is in the horizontal     direction */&nbsp;      cvipImage = create_sine(100,32,1);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      getFileFormat_Image(cvipImage);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     GEOMETRY library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott  E.  Umbaugh  ,  Srinivas     Madiraju, and Kun Luo .&nbsp;\n\r\n\r&nbsp;","create_sine","scr\\CVIP_C_functions/create_sine.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:18:00Z  2004-10-19T23:51:00Z  1  253  1448  SIUE  12  3  1698  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     create_squarewave - creates a square wave image&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;waves.h&quot;&nbsp;     Image *create_squarewave(int img_size,  int  frequency,  int     choice)&nbsp;      &lt;img_size&gt; - number of rows (and columns) in new image      &lt;frequency&gt; - sine wave frequency      &lt;choice&gt; - enter 1 for horizontal, 2  for  vertical  square     wave&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\square.c&nbsp;DESCRIPTION     This function creates a horizontal or vertical  square  wave     image of size img_sizeXimg_size, of frequency 1 to 256.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     A pointer to the new image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPdrawimg.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      /* the following call creates a image of  size  100  x  100     with  freq uency 32 and the square wave is in the horizontal     direction */&nbsp;      cvipImage = create_squarewave(100,32,1);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      getFileFormat_Image(cvipImage);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     GEOMETRY library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh,  Srinivas     Madiraju, and Kun Luo .&nbsp;\n\r\n\r&nbsp;","create_squarewave","scr\\CVIP_C_functions/create_squarewave.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T22:19:00Z  2004-10-19T23:51:00Z  1  333  1899  SIUE  15  4  2228  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     crop - crops a sub-image&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPgeometry.h&quot;      #include &lt;stdio.h&gt;&nbsp;     Image  *crop(Image  *imgP,  unsigned  row_offset,   unsigned     col_offset, unsigned rows, unsigned cols)&nbsp;      &lt;imgP&gt; - pointer to an Image structure      &lt;row_offset&gt; - row coordinate of upper-left corner      &lt;col_offset&gt; - column coordinate of upper-left corner      &lt;rows&gt; - height of desired subimage      &lt;cols&gt; - width of desired subimage&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\crop.cDESCRIPTION     This function allows the user to specify a  subimage  to  be     cropped  from an input image. The user specifies the row and     column coordinates of the upper-left corner of  the  desired     area,  along  with  the  subimage\'s  width  and height.  The     passed image is deleted.  The function  works  on  all  data     types and supports complex images.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     The desired subimage&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPgeometry.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call selects a subimage of size 10x10 from     location 10,10 of the original image */      cvipImage = crop(cvipImage,10,10,10,10);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     GEOMETRY library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh,  Greg  Hance,     and Arve Kjoelen.&nbsp;\n\r\n\r&nbsp;","crop","scr\\CVIP_C_functions/crop.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T22:19:00Z  2004-10-19T23:51:00Z  1  422  2406  SIUE  20  5  2823  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     CVIPhalftone - converts a grayscale image to a binary image&nbsp;SYNOPSIS      #include &lt;stdio.h&gt;      #include &lt;math.h&gt;      #include &lt;stdlib.h&gt;      #include &quot;CVIPimage.h&quot;      #include &quot;dithers.h&quot;      #include &quot;CVIPhalftone.h&quot;&nbsp;     Image *CVIPhalftone(Image  *cvip_Image,  int  halftone,  int     maxval,   float   fthreshval,   CVIP_BOOLEAN   retain_image,     CVIP_BOOLEAN verbose)&nbsp;      &lt;cvip_Image&gt; - pointer to input image      &lt;halftone&gt; - indicates method used to convert  from  grays-     cale  to  binary.  (one  of  QT_FS,  QT_THRESH,  QT_DITHER8,     QT_CLUSTER3, QT_CLUSTER4, QT_CLUSTER8)      &lt;maxval&gt; - specifies maximum range of input image  (usually     255)      &lt;fthreshval&gt; - threshold value (for QT_THRESH) between [0.0     ... 1.0].      &lt;retain_image&gt; - retain image after  writing  (CVIP_YES  or     CVIP_NO)?      &lt;verbose&gt; - shall I be verbose (CVIP_YES or CVIP_NO)?PATH     $CVIPtoolsHOME\\CVIPC\\CONVERSION\\halftone.c&nbsp;DESCRIPTION     Quantizes a grayscale image to two levels (a binary  image).     Possible  methods  of quantization are: (1) QT_FS -- Floyd -     Steinberg  error  diffusion, (2) QT_THRESH -- simple  thres-     holding,  (3)  QT_DITHER8  -- Bayer\'s ordered dither and (4)     QT_CLUSTER3, QT_CLUSTER4 and QT_CLUSTER8 -- three  different     sizes  of  45-degree   clustered-dot dither. Floyd-Steinberg     will almost always  give  the  best looking results.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     Pointer to a binary image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the gray level to binary      conversion using the QT_THRESH method with threshold      value equal to 0.5 */      cvipImage = CVIPhalftone(cvipImage,QT_THRESH,255,0.5,      CVIP_NO,CVIP_NO);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     CONVERSION library&nbsp;NOTES     See Jef Poskanzer\'s &quot;PBMPLUS&quot;&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Greg     Hance.&nbsp;\n\r\n\r&nbsp;","CVIPhalftone","scr\\CVIP_C_functions/CVIPhalftone.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T22:27:00Z  2004-10-19T23:52:00Z  1  151  866  SIUE  7  2  1015  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     CVIPluminance - a fast RGB to luminance calculation&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &lt;stdio.h&gt;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPluminance.h&quot;&nbsp;     Image   *CVIPluminance(Image   *cvip_Image,   int    maxval,     CVIP_BOOLEAN retain_image, CVIP_BOOLEAN verbose)&nbsp;      &lt;cvip_Image&gt; - pointer to valid CVIP Image structure      &lt;maxval&gt; - maximum range of the input image (usually 255)      &lt;retain_image&gt; - retain image after  writing  (CVIP_YES  or     CVIP_NO)?      &lt;verbose&gt; - shall I be verbose (CVIP_YES or CVIP_NO)?&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\CONVERSION\\luminance.c&nbsp;DESCRIPTION     Uses a lookup table to perform a fast RGB to luminance  cal-     culation. Approximates  0.299 r + 0.587 g + 0.114 b.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     Pointer to luminance transformed image&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO    CONVERSION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Greg     Hance.&nbsp;\n\r\n\r&nbsp;","CVIPluminance","scr\\CVIP_C_functions/CVIPluminance.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:27:00Z  2004-10-19T23:52:00Z  1  140  804  SIUE  6  1  943  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     cylin_inv_xform - cylindrical inverse transform&nbsp;SYNOPSIS     void  cylin_inv_xform(float  **cvecP,  unsigned  long  vdim,     float Xo, float Yo, float Zo)&nbsp;      &lt;cvecP&gt; - pointer to an array of normalized band vectors      &lt;vdim&gt; - dimension of each vector (number of pixels)      &lt;Xo&gt; - reference white for red      &lt;Yo&gt; - reference white for green      &lt;Zo&gt; - reference white for blue&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COLOR\\cxform.c&nbsp;DESCRIPTION     This function performs cylindrical to RGB color  transforma-     tion according to the following equations:&nbsp;                         r = rho * cos(theta)                         g = rho * sin(theta)                         b = b  (not changed)&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     None&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     COLOR library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","cylin_inv_xform","scr\\CVIP_C_functions/cylin_inv_xform.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:29:00Z  2004-10-19T23:52:00Z  1  437  2492  SIUE  20  5  2924  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     dct_transform - performs Discrete Cosine Transform&nbsp;SYNOPSIS      #include &quot;CVIPtools.h&quot;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPtransform.h&quot;&nbsp;     Image* dct_transform(Image* inputImage, int blocksize)&nbsp;      &lt;inputImage&gt; - pointer to an Image structure      &lt;blocksize&gt; - block size&nbsp;     Image* idct_transform(Image* inputImage, int blocksize)&nbsp;      &lt;inputImage&gt; - pointer to an Image structure      &lt;blocksize&gt; - block sizePATH     $CVIPtoolsHOME\\CVIPC\\TRANSFORMS\\dct.c&nbsp;&nbsp;DESCRIPTION     dct_transform transforms an image from the  spatial  to  the     frequency  domain  in  a  blockwise fashion using a discrete     cosine transform.&nbsp;     idct_transform   performs   the   inverse   2D-dct_transform     transform.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to an image structure with transformed image  data     in VIP format&nbsp;HISTORY     History information  recorded:  Discrete  Cosine  Transform.     Blocksize: #&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;CVIPtransform.h&gt;      #include &lt;math.h&gt;      #include &lt;sys/file.h&gt;      #include &lt;float.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/uio.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs a dct_transform on the input      image with block size equal to 8 */      cvipImage = dct_transform(cvipImage, 8);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      /*  note the format is VIP */      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,VIP,1);      free(outputfile);      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs a inverse dct_transform      on the input image with block size equal to 8 */      cvipImage = idct_transform(cvipImage, 8);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     TRANSFORMS library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Jianxin     Tan.&nbsp;\n\r\n\r&nbsp;","dct_transform","scr\\CVIP_C_functions/dct_transform.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  0  2004-06-04T22:30:00Z  2004-10-19T23:52:00Z  1  264  1509  SIUE  12  3  1770  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     define_histogram - Enables a user to specify a histogram  in     terms of a variable \'x\'.&nbsp;SYNOPSIS     #include &quot;histogram.h&quot;&nbsp;     float **define_histogram(int bands, int mode, char **eq)&nbsp;      &lt;bands&gt; - number of bands in the image      &lt;mode&gt; - prompt the user for input (mode=1),               or use &lt;eq&gt; (mode=0)      &lt;eq&gt; - string for mapping equation&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\HISTOGRAM\\histogram.c&nbsp;DESCRIPTION     define_histogram is used  to  generate  a  histogram  to  be     passed  to  the  histogram_spec function.  This function can     either work interactively when mode = 1, or use  the  string     to  generate  the histogram when mode = 0. When mode = 1, it     asks the user to enter an equation in terms of \'x\' for  each     band in the image.&nbsp;     The following functions may be specified:&nbsp;     sin(arg)     cos(arg)     tan(arg)     asin(arg)     acos(arg)     atan(arg)     sinh(arg)     cosh(arg)     tanh(arg)     exp(arg)     ln(arg)     log(arg)     sqrt(arg)     floor(arg)     ceil(arg)     abs(arg)     hypot(arg1,arg2)     deg(arg)     rad(arg)     imp(arg)     impulse(arg)     step(arg)     u(arg)     ramp(arg)     r(arg)     random(low val,high val)&nbsp;RETURN VALUES     On success, this function returns a pointer of pointer to  a     float,  with  dimensions  float[int][256],  where int is the     integer passed to the function.&nbsp;BUGS     It could fail if complicated equations are specified.&nbsp;SEE ALSO     get_histogram,        get_histogram_Image,        hist_spec,     histogram_show,        histogram_spec,       make_histogram,     showMax_histogram&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE - by Scott E.  Umbaugh,  David     A. Lyons and Yansheng Wei.&nbsp;\n\r\n\r&nbsp;","define_histogram","scr\\CVIP_C_functions/define_histogram.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  0  2004-06-04T22:30:00Z  2004-10-19T23:52:00Z  1  525  2993  SIUE  24  7  3511  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     display_Image, setDisplay_Image, getDisplay_Image - function     suites  for displaying an image by executing a shell command     or internal function call&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPview.h&quot;&nbsp;      void  display_Image(const  char  *image_name,  IMAGE_FORMAT     format);      &lt;image_name&gt; - name of the image file      &lt;format&gt; - the image format&nbsp;      void setDisplay_Image(char *viewer, char *format);      &lt;viewer&gt; - viewer name      &lt;format&gt; - intermediate image format for display&nbsp;      char *getDisplay_Image(void);&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\Display\\display.c&nbsp;DESCRIPTION     These three functions are usually used in  conjunction  with     view_Image(3)  and  display_RAMImage(3)  for  the purpose of     displaying     an     image.     setDisplay_Image(3)     and     getDisplay_Image(3)  are  used  to  set  and get the program     (viewer) used to display an image.  display_Image(3) is used     to  display  an image stored on the disk using the specified     viewer.&nbsp;     Since usual external  viewers  can  not  display  some  CVIP     specific  image  formats  (such  as  FFT spectrum with float     data), The second parameter for setDisplay_Image(3) is  used     to   perform   necessary  conversion  before  the  image  is     displayed. With  a  fully  functional  viewer,   the  second     parameter can be set to &quot;Default&quot;, or a NULL pointer, and no     conversion will be performed.&nbsp;     One special case is when the display program is set as &quot;Ram-     Viewer&quot;, the RAM viewer is used. The currently available RAM     viewer is display_RAMImage(3) for the X windows system.&nbsp;     Usually, the user doesn\'t dirrectly call display_Image(3) or     display_RAMImage(3).    Instead,   view_Image(3)  should  be     called, which automatically decides which function should be     called based on the viewer choice.&nbsp;TYPES AND CONSTANTS     NONE&nbsp;RETURN VALUES     getDisplay_Image(3):  a string of the current  viewer;  oth-     ers: void&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;&nbsp;      void main()      {      char *inputfile;      IMAGE_FORMAT format;&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);&nbsp;      /* Note the difference with view_Image &amp; display_RAMImage,         The image is not even read, and the only thing that         display_Image does is call a shell command to display         the image. Usually you should call view_Image(3),         instead of display_Image(3).       */&nbsp;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);      /* You can use setDisplay_Image(&quot;xv&quot;, &quot;JPG&quot;) to sepcify         that you want to use &quot;xv&quot; as the viewer, and use JPG         as the image format for display. If the second         parameter is NULL or &quot;Default&quot;, the original image         format of the image is used, which might not be         displable on some systems. For example, there is         currently no viewer on Windows95/NT to display VIP         images.       */      display_Image(inputfile, format);      free(inputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     Display library, view_Image(3), display_RAMImage(3).&nbsp;AUTHOR     Copyright (C)  1995,  1996, 2004  SIUE  -  by  Scott  Umbaugh  and     Yansheng Wei.&nbsp;\n\r\n\r&nbsp;","display_Image,setDisplay_Image,getDisplay_Image","scr\\CVIP_C_functions/display_Image, setDisplay_Image, getDisplay_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T22:31:00Z  2004-10-19T23:52:00Z  1  271  1548  SIUE  12  3  1816  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     display_mesh - draw the mesh corresponding to the given mesh     structure on a given image&nbsp;SYNOPSIS      #include &quot;mesh.h&quot;&nbsp;      int display_mesh(Image* inputImage,struct mesh *inmesh);&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\warp.c&nbsp;DESCRIPTION     The display_mesh() draws the input mesh on  an  image.   The     &quot;inmesh&quot;  is  a  pointer points to the input mesh structure.     The &quot;inputImage&quot; is a pointer points to the image structure.&nbsp;TYPES AND CONSTANTS     struct mesh_node {          int x;          int y;     };&nbsp;     struct mesh {          int width;          int height;          struct mesh_node** nodes;     };&nbsp;     struct float_pair {          float x;          float y;     };&nbsp;RETURN VALUES     The display_mesh() returns  1  when  succeeded  and  0  when     failed.&nbsp;EXAMPLE      #include &quot;mesh.h&quot;      #include &lt;CVIPio.h&gt;&nbsp;      main ()      {          char           *inputfile;          Image          *inputImage;          int       width, height;          struct mesh    *inmesh;          print_CVIP(&quot;0Input   the   mesh    file    name:    &quot;);     /*OPTIONAL1*/          inputfile = getString_CVIP();           /*get a*/          inmesh = file_to_mesh(inputfile);  /*mesh structure*/&nbsp;          print_CVIP(&quot;0Width of the image: &quot;); /*OPTIONAL2, get*/          width = getInt_CVIP(10, 1, 1024);       /*an image*/          print_CVIP(&quot;0Height of the image: &quot;);          height = getInt_CVIP(10, 1, 1024);      /*OPTIONAL2*/          inputImage = black_pgm(width, height);  /*OPTIONAL2*/&nbsp;          display_mesh(inputImage, inmesh);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     file_to_mesh(),     keyboard_to_mesh(),      mesh_to_file(),     print_mesh();&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Jianxin Tan.&nbsp;\n\r\n\r&nbsp;","display_mesh","scr\\CVIP_C_functions/display_mesh.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:32:00Z  2004-10-19T23:53:00Z  1  567  3232  SIUE  26  7  3792  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     display_RAMImage - an X-based image viewer used in CVIPtools&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPview.h&quot;&nbsp;      void display_RAMImage(Image *inputImage, char *name)      &lt;inputImage&gt; - pointer to the input Image structure      &lt;name&gt; - character string as the image name&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\Display\\xview.c&nbsp;DESCRIPTION     display_RAMImage(3) is the  X-based  image  viewer  used  in     CVIPtools.  This  function  will not release the input Image     structure, so there is no need to duplicate the Image before     calling this function. The functionalities available at this     point include: resize, change the aspect-ratio,    revert to     original  image, rotate the image by 90 degrees clockwise or     counter-clockwise, horizontal and vertical flip.  Most  com-     mands  are made compatible with xv(1) to favor users familar     with xv(1).&nbsp;      Button 1 press and drag          --- draw a selection box      Button 1 click out of the selection box          --- unselect of subimage      Button 1 press and drag on selection box          ---  move selection box      Button 2 press          --- display information about the image&nbsp;      right/left arrow          --- move selection box one pixel right/left      up/down arrow          --- move selection box one pixel up/down      shift right/left arrow          --- enlarge/shrink selection box one pixel horizontally      shift up/down          --- enlarge/shrink selection box one pixel vertically&nbsp;      Resizing image:         m     maximize image to whole screen         M     maximize image and retains original aspect-ratio         &gt;     double size image         &lt;     half size image         .     enlarge image by 10%         ,     shrink image by 10%&nbsp;      Changing aspect-ratio:         a     re-aspect-ratio using shorter side         A     re-aspect-ratio using longer side         4     re-aspect-ratio to 43 using shorter side         $     re-aspect-ratio to 43 using longer side&nbsp;      Rotation:         t     turn image 90 degrees clockwise         T     turn image 90 degrees counter-clockwise&nbsp;      Flip:         h     horizontal flip         v     vertical flip&nbsp;      Others:         n, &lt;Enter&gt;   revert to original image         q,Q,Ctr-C    quit the RamViewer         ?, i, H      display the help message&nbsp;     In addition, the event of mounse  clicks  and  movement  are     also  sent to the window manager, and this infomation can be     used for communication with other software. Here, it is used     for   the   copy_paste,  feature  extraction,  ang  geometry     transformation in the GUI.&nbsp;TYPES AND CONSTANTS     NONE&nbsp;RETURN VALUES     NONE&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile;&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      /* Hmm, I don\'t copy the Image structure.         We can also view the image by calling view_Image, but         we want to use display_RAMImage intentionally.         Enjoy the image, and play the commands with         this image.       */&nbsp;      display_RAMImage(cvipImage, inputfile);      free(inputfile);      }&nbsp;SEE ALSO     Display library,      display_Image(3),      getDisplay_Image(3),     setDisplay_Image(3), view_Image(3), picture(1)&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh, Kun  Luo  and     Yansheng Wei.&nbsp;\n\r\n\r&nbsp;","display_RAMImage","scr\\CVIP_C_functions/display_RAMImage.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:33:00Z  2004-10-19T23:53:00Z  1  350  1995  SIUE  16  4  2341  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     divide_Image - divides two images&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPmatrix.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIParithlogic.h&quot;&nbsp;      Image *divide_Image(Image *inputImage1,Image *inputImage2,      CVIP_BOOLEAN zero2num)&nbsp;      &lt;inputImage1&gt; - pointer to an Image structure      &lt;inputImage2&gt; - pointer to an Image structure      &lt;zero2num&gt;    - method of handling 0s in denominator&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\ARITHLOGIC\\arithlogic.c&nbsp;DESCRIPTION     This function performs bitwise division of two images.  Data     type  of each image is promoted to float, where needed. Com-     plex matrices are supported. If zero2num  ==  CVIP_YES,  the     numerator  data  is  used in the resulting image in case the     denominator is 0; otherwise, the resulting image data is set     to 0.&nbsp;TYPES AND CONSTANTS     NONE&nbsp;RETURN VALUES     The divided  Image  pointer  on  success;  a  (Image  *)NULL     pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &quot;CVIParithlogic.h&quot;&nbsp;      void main()      {      Image *cvipImage, *cvipImage1;      IMAGE_FORMAT format;      char *inputfile, *outputfile;&nbsp;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the numerator File Name:&quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = (Image *)read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the denominator File Name:&quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage1 = (Image *)read_Image(inputfile,1);      view_Image(cvipImage1, inputfile);      free(inputfile);&nbsp;      /* if the denominator is 0, set the numerator to 0*/      cvipImage = divide_Image(cvipImage,cvipImage1,CVIP_NO);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,VIP,1);      free(outputfile);      }&nbsp;SEE ALSO     ARITHLOGIC library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh,  Greg  Hance,     and Kun Luo.&nbsp;\n\r\n\r&nbsp;","divide_Image","scr\\CVIP_C_functions/divide_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:34:00Z  2004-10-19T23:53:00Z  1  131  748  SIUE  6  1  878  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     divide_Matrix - divides one matrix by another&nbsp;SYNOPSIS      #include &quot;stdlib.h&quot;      #include &quot;stdio.h&quot;      #include &quot;CVIPmatrix.h&quot;      #include &quot;CVIPcomplex.h&quot;      #include &quot;MATpwise.h&quot;&nbsp;     int  divide_Matrix(Matrix  **dP,  const  Matrix  *aP,  const     Matrix    *bP, const Matrix *cP)&nbsp;      &lt;dP&gt; - matrix containing the result of the division      &lt;aP&gt; - pointer to the numerator      &lt;bP&gt; - pointer to the denominator      &lt;cP&gt; - pointer to mask used when a zero  is  found  in  the     denominator&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\MatrixAlgebra\\mm.c&nbsp;DESCRIPTION     Divides one matrix by another.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     None&nbsp;HISTORY     History information recorded: None&nbsp;BUGS     None at this time&nbsp;SEE ALSO     ARITHLOGIC library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Greg Hance.&nbsp;\n\r\n\r&nbsp;","divide_Matrix","scr\\CVIP_C_functions/divide_Matrix.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:35:00Z  2004-10-19T23:53:00Z  1  503  2868  SIUE  23  6  3365  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     dpc_compress - compresses an image using differential  pulse     code modulation&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPcompress.h&quot;      #include &lt;sys/stat.h&gt;&nbsp;     int dpc_compress(Image *inputImage,  char  *filename,  float     ratio,  int   bit_length,  int  clipping, int direction, int     origin)&nbsp;      &lt;inputImage&gt; - a pointer to an Image structure      &lt;filename&gt; - pointer to char string containing filename      &lt;ratio&gt; - the correlation factor      &lt;bit_length&gt; - number of bits for compression (1 to 8)      &lt;clipping&gt; - clip to maximum value (1), otherwise 0      &lt;direction&gt; - scan image horizontally (0) or vertically (1)      &lt;origin&gt; - use original (1) or reconstructed (0) values&nbsp;     Image *dpc_decompress(char *filename)&nbsp;      &lt;filename&gt; - compressed file&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\dpcm.c&nbsp;DESCRIPTION     DPCM is a compression technique  that  uses  the  predictive     method of differential pulse code modulation. It is based on     the observation that adjacent pixels are  highly  correlated     within  real  images,  and it is wasteful to store repeated,     large values to represent consecutive pixels.  Rather,  DPCM     stores  an initial value, followed by the difference between     the initial value and subsequent pixel values. For  example,     a  line  of  10  white pixels (value = 255) would usually be     represented in 80 bits(8 bits/pixel X  10  pixels),  whereas     with  DPCM, only 17 bits are needed: the first pixel needs 8     bits, but each of the other  pixels  only  requires  1  bit,     since  the difference between the initial value and the oth-     ers is zero (255 - 255 = 0).&nbsp;TYPES AND CONSTANTS     none&nbsp;RETURN VALUES     dpc_compress: 0 on success, -1 on failure&nbsp;     dpc_decompression: an uncompressed image pointer on success,     a NULL pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;BUGS     None at this time&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the differential      predictive coding on the input image with the correlation      factor equal to .9 and the number of bits equal to 3 */      dpc_compress(cvipImage,&quot;file1&quot;,.9,3,1,0,1,1);      /* the following call performs the differential predictive      decoding of the input image */      cvipImage=dpc_decompress(&quot;file1&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     COMPRESSION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh.&nbsp;\n\r\n\r&nbsp;","dpc_compress","scr\\CVIP_C_functions/dpc_compress.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  2  3  2004-06-09T19:09:00Z  2004-10-19T23:53:00Z  1  310  1770  SIUE  14  4  2076  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     dpc_decompress - compresses an image using differential  pulse     code modulation&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPcompress.h&quot;      #include &lt;sys/stat.h&gt;&nbsp;     int dpc_compress(Image *inputImage,  char  *filename,  float     ratio,  int   bit_length,  int  clipping, int direction, int     origin)&nbsp;      &lt;inputImage&gt; - a pointer to an Image structure      &lt;filename&gt; - pointer to char string containing filename      &lt;ratio&gt; - the correlation factor      &lt;bit_length&gt; - number of bits for compression (1 to 8)      &lt;clipping&gt; - clip to maximum value (1), otherwise 0      &lt;direction&gt; - scan image horizontally (0) or vertically (1)      &lt;origin&gt; - use original (1) or reconstructed (0) values&nbsp;     Image *dpc_decompress(char *filename)&nbsp;      &lt;filename&gt; - compressed file&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\dpcm.c&nbsp;DESCRIPTION     DPCM is a compression technique  that  uses  the  predictive     method of differential pulse code modulation. It is based on     the observation that adjacent pixels are  highly  correlated     within  real  images,  and it is wasteful to store repeated,     large values to represent consecutive pixels.  Rather,  DPCM     stores  an initial value, followed by the difference between     the initial value and subsequent pixel values. For  example,     a  line  of  10  white pixels (value = 255) would usually be     represented in 80 bits(8 bits/pixel X  10  pixels),  whereas     with  DPCM, only 17 bits are needed: the first pixel needs 8     bits, but each of the other  pixels  only  requires  1  bit,     since  the difference between the initial value and the oth-     ers is zero (255 - 255 = 0).&nbsp;TYPES AND CONSTANTS     none&nbsp;RETURN VALUES     dpc_compress: 0 on success, -1 on failure&nbsp;     dpc_decompression: an uncompressed image pointer on success,     a NULL pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;BUGS     None at this time&nbsp;SEE ALSO     COMPRESSION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh.&nbsp;\n\r\n\r&nbsp;","dpc_decompress","scr\\CVIP_C_functions/dpc_decompress.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:36:00Z  2004-10-19T23:53:00Z  1  992  5656  SIUE  47  13  6635  10.3501                    MicrosoftInternetExplorer4 NAME     edge_detect_filter - perform edge detection&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPfs.h&quot;      #include &lt;limits.h&gt;&nbsp;     Image *edge_detect_filter(Image *imageP,  int  program,  int     mask_choice,  int mask_size, int keep_dc, int threshold, int     threshold1, int thresh,int thr)&nbsp;      &lt;imageP&gt; - pointer to an Image      &lt;program&gt; - desired edge detector      &lt;mask_choice&gt; - type of smoothing filter      &lt;mask_size&gt; - Laplacian mask (1 or 2)      &lt;keep_dc&gt; - 0 (no) or 1 (yes)      &lt;threshold&gt; - value for binary threshold      &lt;threshold1&gt; - Frei-Chen projection method      &lt;thresh&gt; - Frei-Chen projection threshold      &lt;thr&gt; - angle (in radians) for Frei-Chen edge              or line projection threshold&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\edge_detect.c&nbsp;DESCRIPTION     This function applies various edge detection  algorithms  to     &lt;imageP&gt;.    The   difference   between  this  function  and     edge_detect_setup  is  that  this  function  gets  all   the     required  input  from the parameters, instead from the stan-     dard input.  Edge detectors available for &lt;program&gt; are:                            EDGE_KIRSCH                            EDGE_ROBINSON                            EDGE_PYRAMID                            EDGE_LAPLACIAN                            EDGE_SOBEL                            EDGE_ROBERTS                            EDGE_PREWITT                            EDGE_FREI&nbsp;     If a smoothing filter is desired as  a  preprocessing  step,     set &lt;mask_choice&gt; to:                       1 = Gaussian blur                       2 = generic lowpass 1                       3 = generic lowpass 2                       4 = neighborhood average&nbsp;     For &lt;mask_size&gt;:     If you select EDGE_LAPLACIAN, set &lt;mask_size&gt;:                    1 = [0,-1,0; -1,4,-1; 0,-1,0]                    2 = [1,-2,1; -2,4,-2; 1,-2,1]&nbsp;     If you select EDGE_SOBEL, set &lt;mask_size&gt;:     kernel size (3,5,or 7)&nbsp;     If you select EDGE_ROBERTS, set &lt;mask_size&gt;:     1 = G[f(x,y)]=[f(x,y)-f(x+1,y)]^2+[f(x,y)-f(x,y+1)]^2}^1/2)     2 = G[f(x,y)]=|f(x,y)-f(x+1,y+1)|+|f(x+1,y)-f(x,y+1)|&nbsp;     If you select EDGE_PREWITT, set &lt;mask_size&gt; to desired     kernel size&nbsp;     If you select EDGE_FREI, you  need  to  set  the  following:     &lt;threshold1&gt; :                    1 = Project onto edge subspace                    2 = Project onto line subspace                    3 = Show complete projection&nbsp;     &lt;thresh&gt; :                 1 = Set threshold on edge projection                 2 = Set threshold on line projection                 3 = Smallest angle between the above&nbsp;     If &lt;thresh&gt; = 1 or 2, set &lt;thr&gt; = threshold angle (radians)&nbsp;     NOTE: FOR ALL OF THE ABOVE PARAMETERS, USE THE VALUE -1  FOR     ANY PARAMETER NOT NEEDED.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     An edge-detected image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      Image *cvipImage4;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      cast_Image(cvipImage,CVIP_SHORT);      /* the following function performs EDGE_FREI edge      detection.Projection is done onto the edge subspace      with the threshold angle equal to 1.05 radians */      cvipImage4=edge_detect_filter(cvipImage,EDGE_FREI,-1,      -1,-1,-1,1,1,1.05);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage4,outputfile);      write_Image(cvipImage4,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      Image *cvipImage1;      Image *cvipImage2;      Image *cvipImage3;&nbsp;      (void) setDisplay_Image(VIEWER);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      cast_Image(cvipImage,CVIP_SHORT);      /* for all the edge detecting functions there is no      preprocessing step */      /* Laplacian edge detection */      /* the mask is [0,-1,0; -1,4,-1; 0,-1,0]*/      cvipImage1=edge_detect_filter(cvipImage,EDGE_LAPLACIAN,      -1,1,-1,-1,-1,-1,-1);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage1,outputfile);      write_Image(cvipImage1,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);&nbsp;      /* Sobel edge detection */      /* mask size is 3 */      cvipImage = read_Image(inputfile, 1);      cast_Image(cvipImage,CVIP_SHORT);      cvipImage2=edge_detect_filter(cvipImage,EDGE_SOBEL,-1,3,      -1,-1,-1,-1,-1);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage2,outputfile);      write_Image(cvipImage2,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);&nbsp;      /* Roberts edge detection */      /* type -1:Regular gradient             G[f(x,y)] = {[f(x,y)-f(x+1,y)]^2 +                             [f(x,y)-f(x,y+1)]^2}^1/2 */      cvipImage = read_Image(inputfile, 1);      cast_Image(cvipImage,CVIP_SHORT);      cvipImage3=edge_detect_filter(cvipImage,EDGE_ROBERTS,      -1,1,-1,-1,-1,-1,-1);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage3,outputfile);      write_Image(cvipImage3,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      free(inputfile);      }&nbsp;SEE ALSO    SPATIALFILTER library, edge_detect_setup&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh, Greg Hance,  and     Kun Luo.&nbsp;\n\r\n\r&nbsp;","edge_detect_filter","scr\\CVIP_C_functions/edge_detect_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  5  2004-06-04T22:37:00Z  2004-10-19T23:54:00Z  1  200  1144  SIUE  9  2  1342  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     edge_detect_setup - performs edge detection&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPfs.h&quot;      #include &lt;limits.h&gt;&nbsp;     Image *edge_detect_setup(Image *imageP, int program)&nbsp;      &lt;imageP&gt; - pointer to an Image structure      &lt;program&gt; - edge detector to apply; one of:&nbsp;                            EDGE_KIRSCH                            EDGE_ROBINSON                            EDGE_PYRAMID                            EDGE_LAPLACIAN                            EDGE_SOBEL                            EDGE_ROBERTS                            EDGE_PREWITT                            EDGE_FREIPATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\edge_detect.c&nbsp;DESCRIPTION     edge_detect_setup is the  frontend  function  for  the  edge     detection  subroutines.   This function performs edge detec-     tion on an input image, primarily through the application of     2-D  convolution  masks.  The function calls the appropriate     edge detection program, also located in edge_detect.c.&nbsp;TYPES AND CONSTANTS     See SPATIALFILTER&nbsp;RETURN VALUES     An edge-detected image&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     SPATIALFILTER library, edge_detect_filter&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh,  Greg  Hance,     and Kun Luo.&nbsp;\n\r\n\r&nbsp;","edge_detect_setup","scr\\CVIP_C_functions/edge_detect_setup.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:39:00Z  2004-10-19T23:54:00Z  1  304  1734  SIUE  14  4  2034  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     edge_link_filter - connects pixels to form lines&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPfs.h&quot;&nbsp;     Image* edge_link_filter(Image *cvipImage, int connection)&nbsp;      &lt;cvipImage&gt; - pointer to an binary Image      &lt;connection&gt; - maximum connect distance&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\hough.c&nbsp;DESCRIPTION     This function links  pixels  in  a  binary  image  that  are     separated by no more than &lt;connection&gt; pixels.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A linked image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call converts the input image into a      binary image with the threshold value equal to 210 */      cvipImage =(Image *) threshold_segment(cvipImage,210,1);      /* the following call links the pixels in the binary      image that are seperated by no more than 3 pixels */      cvipImage=(Image *)edge_link_filter(cvipImage,3);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     SPATIALFILTER Library,      hough_transform,       hough_inverse,     hough_filter&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","edge_link_filter","scr\\CVIP_C_functions/edge_link_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:40:00Z  2004-10-19T23:54:00Z  1  120  687  SIUE  5  1  806  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     encode_data - assigns codebook  to  input  vectors  for  LBG     compression&nbsp;SYNOPSIS     #include &lt;LBG.h&gt;&nbsp;     void encode_data(float **codebook, float **data, int *index,     int size, int dim, int nvecs)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\LBG_utils.c&nbsp;DESCRIPTION     This routine assigns a codebook index to the  input  vectors     based  on  the  nearest-neighbor  classification  criterion.     This criterion results in  the  selection  of  the  codebook     entry  which  is  closest  to  the input vector in euclidian     space.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A codebook index for use with LBG compression&nbsp;HISTORY     History information recorded: None&nbsp;&nbsp;AUTHOR     Arve Kjoelen, SIUE&nbsp;     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh.&nbsp;\n\r\n\r&nbsp;","encode_data","scr\\CVIP_C_functions/encode_data.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T22:41:00Z  2004-10-19T23:54:00Z  1  331  1890  SIUE  15  4  2217  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     enlarge - Enlarges an image to a user-defined size&nbsp;SYNOPSIS      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmatrix.h&gt;      #include &lt;CVIPgeometry.h&gt;&nbsp;      Image *enlarge(Image *cvipImage, int row, int col)&nbsp;      &lt;cvipImage&gt; - pointer to an Image structure      &lt;row&gt; - number of rows for enlarged image      &lt;column&gt; - number of columns for enlarged image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\enlarge.c&nbsp;DESCRIPTION     Enlarge allows the user to specify the number  of  rows  and     columns  in the resultant image, corresponding to the height     and width of the new image. The integers specified  for  row     and  column sizes must be equal to or greater than the input     image sizes or an error results.&nbsp;     Because the user may enter different values for  height  and     width,  enlarge  may  be  used  to geometrically distort the     image in a rubber-sheet fashion.&nbsp;TYPES AND CONSTANTS     none&nbsp;RETURN VALUES     Returns enlarged image upon successful  completion;  returns     NULL upon error in size specification.&nbsp;EXAMPLE       #include &lt;CVIPtoolkit.h&gt;       #include &lt;CVIPconvert.h&gt;       #include &lt;CVIPimage.h&gt;       #include &lt;CVIPmatrix.h&gt;       #include &lt;CVIPgeometry.h&gt;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile, *outputfile;&nbsp;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;      system(&quot;ln      -s       /opt/cvipimages/Gray/cameraman.pgm&nbsp;     cameraman.pgm&quot;);      print_CVIP(&quot;\\nPlease enter the image \'cameraman.pgm\' at the     prompt\\n\\n&quot;);      print_CVIP(&quot;Enter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      cvipImage = enlarge(cvipImage, 300,420);      print_CVIP(&quot;Enter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage, outputfile);      write_Image(cvipImage,   outputfile,CVIP_NO,CVIP_NO,format,     1);      free(inputfile);      free(outputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     none&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","enlarge","scr\\CVIP_C_functions/enlarge.htm","   ACADEMIC COMPUTING  Normal  akharba  6  15  2005-07-02T19:22:00Z  2006-07-08T22:24:00Z  1  262  1498  SIUE  12  3  1757  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        euclidean_distance – calculates the euclidean distance&nbsp;SYNOPSIS#include &quot;math.h&quot;     float euclidean_distance(float *vector1, float *vector2, int n)      &lt;vector1&gt; - pointer to an input array&lt;vector2&gt; - pointer to an input array&lt;n&gt; - number of elements (features) in the array&nbsp;&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\euclidean_distance.c&nbsp;DESCRIPTION     This function calculates the Euclidean distance measure from     the elements of the two arrays. The formula used for the      calculation is given in chapter 6 of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 3\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       float  *vector1;\n\r\n\r       float  *vector2;\n\r\n\r       float  result;\n\r\n\r       int           i;\n\r\n\r&nbsp;\n\r\n\r       vector1 = malloc(MAX_CASE*sizeof(float));\n\r\n\r       vector2 = malloc(MAX_CASE*sizeof(float));\n\r\n\r&nbsp;\n\r\n\r       /* Get the vectors. The items should beseparated by &quot;,&quot; */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector1: &quot;);\n\r\n\r       for(i=0;i&lt;MAX_CASE;i++)\n\r\n\r       {\n\r\n\r              scanf(&quot;%f,&quot;,&amp;vector1[i]);\n\r\n\r       }\n\r\n\r       \n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector1: &quot;);\n\r\n\r       for(i=0;i&lt;MAX_CASE;i++)\n\r\n\r       {\n\r\n\r              scanf(&quot;%f,&quot;,&amp;vector2[i]);\n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       result = euclidean_distance(vector1,vector2, MAX_CASE);\n\r\n\r       \n\r\n\r       /* Print out the result */\n\r\n\r       printf(&quot;result=%f\\n&quot;,result);\n\r\n\r&nbsp;\n\r\n\r       /* Free the pointers */\n\r\n\r       free(vector1);\n\r\n\r       free(vector2);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A float number representing the Euclidean distance&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","euclidean_distance","scr\\CVIP_C_functions/euclidean_distance.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T22:42:00Z  2004-10-19T23:54:00Z  1  312  1784  SIUE  14  4  2092  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     euler - calculates the euler number&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;&nbsp;     int euler(Image * labeledImage, int r, int c)&nbsp;      &lt;labeledImage&gt; -  pointer to a labeled image      &lt;r&gt; - row coordinate of a point on the labeled image      &lt;c&gt; - column coordinate of a point on the labeled image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\binary_feature.c&nbsp;DESCRIPTION     This function calculates the euler number of  na  object  of     interest  on  a  labeled image. The Euler number is equal to     the number of upstream-facing convexities minus  the  number     of upstream-facing concavities.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A value of type int: euler number&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPobject.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;&nbsp;      void main() {         Image *inputImage, *labeledImage;         IMAGE_FORMAT format;         char *inputfile, *outputfile;         int rows, cols, r, c;&nbsp;         setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;         print_CVIP(&quot;\\nEnter the Input File Name:  &quot;);         inputfile = (char *) getString_CVIP();         inputImage = read_Image(inputfile, format, TRUE);         view_Image(inputImage,inputfile);         labeledImage = label(inputImage);&nbsp;         rows = getNoOfRows_Image(labeledImage);         cols = getNoOfCols_Image(labeledImage);&nbsp;         print_CVIP(&quot;\\nEnter the row coordinate of a point on the     labled image: &quot;);         r = getInt_CVIP(10, 0, rows);         print_CVIP(&quot;\\nEnter the col coordinate of the  point  on     the labled image: &quot;);         c = getInt_CVIP(10, 0, cols);&nbsp;         print_CVIP(&quot;The Euler number = %d&quot;,  euler(labeledImage,     r, c));         print_CVIP(&quot;\\n&quot;);&nbsp;         free(inputfile);       }&nbsp;DIAGNOSTICS     The labeled image can only of data type CVIP_INTEGER&nbsp;SEE ALSO     FEATURE library &nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","euler","scr\\CVIP_C_functions/euler.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T22:43:00Z  2004-10-19T23:54:00Z  1  347  1979  SIUE  16  4  2322  10.3501    Clean                  MicrosoftInternetExplorer4 NAME     exp_ace_filter -  a  method  to  enhance  the  contrast  and     dynamic range of the image&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPspfltr.h&gt;&nbsp;&nbsp;      Image *exp_ace_filter(Image *inputIMAGE,int size,float beta,float alpha)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;size&gt; - mask size (3,5,7,9,...)      &lt;alpha&gt; - local gain factor      &lt;beta&gt; - local mean factor&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\lee_filter.c&nbsp;DESCRIPTION     exp_ACE\'s algorithms are able to enhance  the  contrast  and     dynamic  range of the image. exp_ACE\'s algorithm uses linear     brightness stretching to modify  the  dynamic  range  of  an     image.&nbsp;      output =  M*[I(r,c)/M]**k1 + [m_l(r,c)/I(r,c)]**k2&nbsp;      where M =  the number of gray levels (255)            m_l = the local mean            k1 = Local gain factor (exponent)            k2 = Local mean factor (exponent)            kernel size = size of local window&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to the processed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPspfltr.h&gt;&nbsp;      void main() {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs filter operation in a      kernel size of 5 with the local gain factor 0.5 multiplier      and local mean multiplier equal to 1.0 */      cvipImage = exp_ace_filter(cvipImage, 5, 1.0, 0.5);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     SPATIALFILTER libraryAUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Lingwei Sun.&nbsp;\n\r\n\r&nbsp;","exp_ace_filter","scr\\CVIP_C_functions/exp_ace_filter.htm","   Jhansi  jhansi  21  9  2004-06-04T22:44:00Z  2010-01-06T21:48:00Z  1  373  2127  SIUE  17  4  2496  11.9999    120  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                             NAME     fft_mag - extract magnitude of fft&nbsp;SYNOPSIS     Image * fft_mag(Image * fftImage)&nbsp;      &lt;fftImage&gt; - Pointer to a complex image structure      PATH     $CVIPtoolsHOME\\CVIPC\\TRANSFORMS\\fft_mag.c&nbsp;DESCRIPTION     This function performs two types of  operations:   normalize     Phase by setting                      REAL = magnitude                      IMAG = 0     where magnitude is a constant, and remaps  the  magnitude  data  into  a     CVIP_BYTE image:                      magnitude = sqrt(REAL^2 + IMAG^2)&nbsp;     TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to a complex or CVIP_BYTE image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;CVIPtransform.h&gt;      #include &lt;math.h&gt;      #include &lt;sys/file.h&gt;      #include &lt;float.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/uio.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;      void main()      {      Image *cvipImage,*cvipImage1;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      cvipImage = fft_transform(cvipImage,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      /* VIP format because of the complex image */      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,VIP,1);      free(outputfile);      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call extracts the magnitude of the      transformed complex image*/      cvipImage = fft_mag(cvipImage);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,PGM,1);      free(outputfile);      }&nbsp;SEE ALSO     TRANSFORMS library&nbsp;AUTHOR     Copyright (C) 2010 SIUE - by Scott E. Umbaugh  and  Jhansi&nbsp;\n\r\n\r&nbsp;","fft_mag","scr\\CVIP_C_functions/fft_mag.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T22:44:00Z  2004-10-19T23:54:00Z  1  466  2661  SIUE  22  6  3121  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     fft_phase - extract phase of fft&nbsp;SYNOPSIS     Image * fft_phase(Image * fftImage, int remap_norm, float k)&nbsp;      &lt;fftImage&gt; - Pointer to a complex image structure      &lt;remap_norm&gt; - 0 = remaps the phase data and returns                         a CVIP_BYTE image                     1 = normalizes the magnitude, using value                         of k, returns a complex image      &lt;k&gt; - constant to normalize the magnitude&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\TRANSFORMS\\fft_phase.c&nbsp;DESCRIPTION     This function performs two types of  operations:   normalize     magnitude by setting                      REAL = k*cos(phase_angle)                      IMAG = k*sin(phase_angle)     where k is a constant, and remaps  the  phase  data  into  a     CVIP_BYTE image:                      phase = arctan(IMAG/REAL)&nbsp;     Phase data are values between 0 -- 2*PI, values between PI/4     --  5*PI/4  are remapped to 255 -- 0; values between -3*PI/4     -- PI/4 are remapped to 0 -- 255.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to a complex or CVIP_BYTE image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;CVIPtransform.h&gt;      #include &lt;math.h&gt;      #include &lt;sys/file.h&gt;      #include &lt;float.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/uio.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;      void main()      {      Image *cvipImage,*cvipImage1;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      cvipImage = fft_transform(cvipImage,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      /* VIP format because of the complex image */      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,VIP,1);      free(outputfile);      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call extracts the phase of the      transformed complex image,remaps the phase      between 0 and 255 and diplays the CVIP_BYTE      image.Since we are not normalising the magnitude,      we use k=-1 */      cvipImage = fft_phase(cvipImage,0,-1);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,PGM,1);      free(outputfile);      }&nbsp;SEE ALSO     TRANSFORMS library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","fft_phase","scr\\CVIP_C_functions/fft_phase.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  8  2004-06-04T22:46:00Z  2004-10-19T23:55:00Z  1  323  1847  SIUE  15  4  2166  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     fft_transform - perform fast Fourier transform&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &lt;float.h&gt;      #include &lt;sys/file.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/uio.h&gt;      #include &lt;CVIPtools.h&gt;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtransform.h&quot;&nbsp;     Image *fft_transform(Image *input_Image,int block_size)&nbsp;      &lt;input_Image&gt; - pointer to an Image structure      &lt;block_size&gt; - block size&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\TRANSFORMS\\fft.c&nbsp;DESCRIPTION     This function performs  a  Fast  forward  Fourier  Transform     (FFT)  on  an  image.Block  sizes  in power of two should be     specified,otherwise segmentation fault will occur.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     An image pointer with complex data&nbsp;HISTORY     History information recorded: Fast Fourier Transform. Block-     size: #&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;CVIPtransform.h&gt;      #include &lt;math.h&gt;      #include &lt;sys/file.h&gt;      #include &lt;float.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/uio.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the fft_tranform on the      input image with the block size being 8 */      cvipImage = fft_transform(cvipImage, 8);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     TRANSFORMS library, ifft_transform&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh,  Simon  Low,     and Kun Luo.&nbsp;\n\r\n\r&nbsp;","fft_transform","scr\\CVIP_C_functions/fft_transform.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T22:54:00Z  2004-10-19T23:55:00Z  1  178  1021  SIUE  8  2  1197  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     file_to_mesh - retrieve a mesh structure from a file&nbsp;SYNOPSIS      #include &quot;mesh.h&quot;&nbsp;      struct mesh *file_to_mesh(char* mesh_file);&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\warp.c&nbsp;DESCRIPTION     This function is one of several used  to  perform  geometric     distortion  or restoration on an image. It rettrieves a mesh     structure from a file.&nbsp;TYPES AND CONSTANTS     struct mesh_node {          int x;          int y;     };&nbsp;     struct mesh {          int width;          int height;          struct mesh_node** nodes;     };&nbsp;     struct float_pair {          float x;          float y;     };&nbsp;RETURN VALUES     The file_to_mesh() returns a pointer to the  mesh  structure     it retrieves from the file.&nbsp;EXAMPLE      #include &quot;mesh.h&quot;      #include &lt;CVIPio.h&gt;&nbsp;      void main()      {          char *inputfile;          struct mesh *inmesh;&nbsp;          print_CVIP(&quot;0Input the mesh file name: &quot;);          inputfile = getString_CVIP();          inmesh = file_to_mesh(inputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     keyboard_to_mesh(), mesh_to_file()&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Jianxin Tan.&nbsp;\n\r\n\r&nbsp;","file_to_mesh","scr\\CVIP_C_functions/file_to_mesh.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T22:55:00Z  2004-10-19T23:55:00Z  1  288  1643  SIUE  13  3  1928  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Find_euler - calculates the Euler number of a binary object&nbsp;SYNOPSIS      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmatrix.h&gt;      #include &lt;CVIPfeatures.h&gt;&nbsp;     int Find_euler(Image *cvipImage, int gray_level)&nbsp;      &lt;inputImage&gt; - a pointer to an Image structure      &lt;gray_level&gt; - the gray value of the labeled object&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\gray_euler.c&nbsp;DESCRIPTION     This function finds the Euler number for  a  labeled  binary     image.  The  Euler number is found by subtracting the number     of holes (distinct background regions)  from the  number  of     objects  in  the image. For a single object, it is a measure     of the number of closed curves the object contains.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Returns an integer value.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE           #include &lt;CVIPtoolkit.h&gt;           #include &lt;CVIPimage.h&gt;           #include &lt;CVIPconvert.h&gt;           #include &lt;CVIPdef.h&gt;&nbsp;           #include &lt;CVIPmatrix.h&gt;           #include &lt;CVIPfeatures.h&gt;&nbsp;           void main()           {           Image *cvipImage;           IMAGE_FORMAT format;           char *inputfile;           int euler_no;&nbsp;           (void) setDisplay_Image(&quot;RamViewer&quot;, &quot;Default&quot;);&nbsp;           print_CVIP(&quot;\\nThis program requires a binary image.&quot;);           print_CVIP(&quot;0t assumes the object has value 255.\\n&quot;);           print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);           inputfile =(char *) getString_CVIP();           format = getFormat_CVIP(inputfile);           cvipImage = read_Image(inputfile, 1);&nbsp;           euler_no = Find_euler(cvipImage,255);           printf(&quot;\\nThe  Euler  number   for   this   image   is     %d.\\n\\n&quot;,euler_no);&nbsp;           free(inputfile);           }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     euler&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","Find_euler","scr\\CVIP_C_functions/Find_euler.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T22:56:00Z  2004-10-19T23:55:00Z  1  154  878  SIUE  7  2  1030  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Find_irregular - determines the irregularity  of  a  labeled     binary object&nbsp;SYNOPSIS      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmatrix.h&gt;      #include &lt;CVIPfeatures.h&gt;      #include &lt;CVIPdef.h&gt;&nbsp;     float Find_irregular(Image *inputImage, int gray_level)&nbsp;      &lt;inputImage&gt; - a pointer to an Image structure      &lt;gray_level&gt; - the gray value of the labeled object&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\thinness.c&nbsp;DESCRIPTION     Irregularity is a measure of the regularity  of  an  object.     Once  the  perimeter(P)  and  the  area(A)  of an object are     known, the irregularity(I) is found:                           I = (P^2/4*pi*A)     Irregularity is the inverse of thinness.&nbsp;     This function requires a labeled binary object.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Returns a float value.&nbsp;HISTORY     History information recorded: None&nbsp;BUGS     None at this time&nbsp;SEE ALSO     Find_thinness&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","Find_irregular","scr\\CVIP_C_functions/Find_irregular.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  0  2004-06-04T22:57:00Z  2004-10-19T23:55:00Z  1  275  1569  SIUE  13  3  1841  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Find_perimeter - finds the perimeter  of  a  labeled  binary     object&nbsp;SYNOPSIS      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPfeatures.h&quot;&nbsp;     long Find_perimeter(Image *input_Image, int gray_level)&nbsp;      &lt;inputImage&gt; - a pointer to an Image structure      &lt;gray_level&gt; - the gray value of the labeled object&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\gray_perimeter.c&nbsp;DESCRIPTION     This function  finds  the  perimeter  of  a  labeled  binary     object.  It  uses  a Roberts mask to find edge pixels, which     are counted and returned as the perimeter of the object.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Returns a long integer value.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE           #include &lt;CVIPtoolkit.h&gt;           #include &lt;CVIPimage.h&gt;           #include &lt;CVIPconvert.h&gt;           #include &lt;CVIPdef.h&gt;&nbsp;           #include &lt;CVIPmatrix.h&gt;           #include &lt;CVIPfeatures.h&gt;&nbsp;           void main()           {           Image *cvipImage;           IMAGE_FORMAT format;           char *inputfile;           long int perim;&nbsp;           (void) setDisplay_Image(&quot;RamViewer&quot;, &quot;Default&quot;);&nbsp;           print_CVIP(&quot;\\nThis program requires a binary image.&quot;);           print_CVIP(&quot; It assumes the object has value 255.\\n&quot;);           print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);           inputfile =(char *) getString_CVIP();           format = getFormat_CVIP(inputfile);           cvipImage = read_Image(inputfile, 1);&nbsp;           perim = Find_perimeter(cvipImage,255);           print_CVIP(&quot;\\nThe   perimeter   is    %d.\\n\\n&quot;,perim);&nbsp;           free(inputfile);           }&nbsp;BUGS     None at this time&nbsp;SEE ALSO    FEATURE library&nbsp;AUTHOR     Copyright (C) 1996 SIUE - by Scott Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","Find_perimeter","scr\\CVIP_C_functions/Find_perimeter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T22:57:00Z  2004-10-19T23:55:00Z  1  150  861  SIUE  7  2  1009  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Find_thinness - determines the thinness ratio of  a  labeled     binary object&nbsp;SYNOPSIS      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmatrix.h&gt;      #include &lt;CVIPfeatures.h&gt;      #include &lt;CVIPdef.h&gt;&nbsp;     float Find_thinness(Image *inputImage, int gray_level)&nbsp;      &lt;inputImage&gt; - a pointer to an Image structure      &lt;gray_level&gt; - the gray value of the labeled object&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\thinness.c&nbsp;DESCRIPTION     Thinness is a measure of the roundness of  an  object.  Once     the perimeter(P) and the area(A) of an object are known, the     thinness(T) is found:                           T = 4*pi(A/P^2)     A circle has a thinness ratio of 1.&nbsp;     This function requires a labeled binary object.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Returns a float value.&nbsp;HISTORY     History information recorded: None&nbsp;BUGS     None at this time&nbsp;SEE ALSO     Find_irregular&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","Find_thinness","scr\\CVIP_C_functions/Find_thinness.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  10  2004-06-04T22:58:00Z  2004-10-19T23:56:00Z  1  983  5606  SIUE  46  13  6576  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME      fractal - A fractal compression method&nbsp;SYNOPSIS      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtransform.h&quot;      #include &quot;fractal.h&quot;&nbsp;     int frac_compress(Image *inputImage,char  *filename,  double     tol,  int  min_part1,  int  max_part1,  int  dom_type1,  int     dom_step1, char c1, char c2, int s_bits1, int o_bits1)&nbsp;      &lt;inputImage&gt; - pointer to an Image structure      &lt;filename&gt; - character array      &lt;tol&gt; - tolerance value      &lt;min_part1&gt; - recursion size min.      &lt;max_part1&gt; - recursion size max.      &lt;dom_type1&gt; - domain type      &lt;dom_step1&gt; - domain step      &lt;c1&gt; - character(y/n) for searching 24 domain classes      &lt;c2&gt; - character(y/n) for searching 3 domain classes      &lt;s_bits1&gt; - scaling bits      &lt;o_bits1&gt; - offset bits&nbsp;     Image *frac_decompress(char *filename)&nbsp;      &lt;input&gt; - character array&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\fracenc.c,fracdec.c&nbsp;DESCRIPTION      Fractal compression utilizes the property of self  similar-     ity in images. The natural images are such that a portion of     the image is always an affine transformation of  some  other     portion  of  the  image.  The  fractal compression method in     CVIPtools uses the quadtree scheme to  partition  the  image     into  subimages  and each of the subimage is compared to the     domains(which also are subimages) and the resulting  mapping     equations  are  stored  in  the  compressed file. A quadtree     scheme is a representation of an image in which  each  node,     corresponding  to  a  square  portion of the image, contains     four subnodes, corresponding to the four  quadrants  of  the     square.  The  root  of  the  tree  is the initial image. The     decompression algorithm is an iterative process which  util-     izes  the  stored mapping in the compressed file to generate     the decompressed image.&nbsp;     The tolerance is a real value which is a  loose  target  for     the  final  rms  error  of  the  encoded image. Lower values     result in better looking encoded images which have  a  lower     compression ratio.&nbsp;     The recursion size min. is the minimum number of times  that     the  largest  square  sub-image  will  be recursively parti-     tioned. Using larger values will result in  higher  compres-     sion  ratios when the file is easy to encode. Using a recur-     sion size min. of 2 for a 256x256 image means that the image     will  be  partitioned  at  least twice, so we would look for     mapping starting from 64x64 subimage.&nbsp;     The recursion size max. is the maximum number of times  that     the  largest  square  sub-image  will  be recursively parti-     tioned. Using larger values will help encode the fine detail     in the image at the cost of lower compression ratios.&nbsp;     The domain type selects a method for determining the  domain     pool  with  which the range is compared to get the resultant     mapping. The domain pool type 0 gives fast results while the     results  get  slower with higher values for the domain pool.     The domain pool type 2 takes a exceptionally long time.&nbsp;     The domain step determines the selection of the domain pool.     If  we  choose  a  higher value of d, the density of domains     would be higher and this would reult in higher  compression.     The higher compression occurs at the expense of time.&nbsp;     The character c1(y/n) specifies  ths  search  to  24  domain     classes. This results in better encodings with slower encod-     ing times. The character c2(y/n) specifies the search  to  3     domain  sub  classes.  This results in slower encoding times     with better encodings.&nbsp;     The scaling bits specifies the number of bits used to  quan-     tize  the  scale  factor of the affine transformation of the     pixel values between the domain and the range.  The  default     value is 5.&nbsp;     The offset bits specifies the number of bits used  to  quan-     tize  the  offset  of  the affine transformation between the     domain and the range. The default value is 7.&nbsp;     You can play with all the parameters mentioned above in  the     cviptcl shell. In the CVIPtools GUI, the character c1 and c2     are combined to slower  encoding  button,  the  scaling  and     offset  bits  are  set  to default values of 5 and 7 and the     domain step is set to 1.&nbsp;TYPES AND CONSTANTS     #define bound(a)   ((a) &lt; 0.0 ? 0 : ((a)&gt;255.0? 255 : a))     #define DEBUG 0     #define swap(a,b,TYPE)           {TYPE _temp; _temp=b; b=a; a= _temp;}     #define IMAGE_TYPE unsigned char&nbsp;RETURN VALUES      frac_compress: 0 on success, -1 on failure&nbsp;      frac_decompression:  an  uncompressed  image   pointer   on     success,a NULL pointer on failure&nbsp;EXAMPLE      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtransform.h&quot;      #include &quot;fractal.h&quot;&nbsp;      void main() {         Image *cvipImage, *outImage;         IMAGE_FORMAT format;         char *inputfile, *outputfile;         char c1=\'n\',c2=\'n\';&nbsp;         setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);         print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);         inputfile =(char *) getString_CVIP();         cvipImage = read_Image(inputfile, 1);         view_Image(cvipImage, inputfile);         print_CVIP(&quot;\\n\\t\\tEnter the Compressed File Name:&quot;);         outputfile =(char *) getString_CVIP();         /* The following command will compress the input image with the         tolerance value equal to 15, recursion size min. equal to 4 and         recursion size max. equal to 6, domain type equal to 0, domain step         equal to 1, scale bits equal to 5 and offset bits equal to 7 with         faster compression time */         if (frac_compress(cvipImage,outputfile,15,4,6,0,1,c1,c2,5,7)&lt;0) {          error_CVIP(&quot;frac_compress&quot;, &quot;compression failed&quot;);             exit(1);         } else if ((outImage=frac_decompression(outputfile))==NULL){          error_CVIP(&quot;frac_decompress&quot;, &quot;decompression failed&quot;);             exit(1);         } else view_Image(outImage, outputfile);&nbsp;         free(inputfile);         free(outputfile);         }&nbsp;BUGS     None&nbsp;SEE ALSO     COMPRESSION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by  Scott  E.  Umbaugh  and  Makam     Sreenivas.&nbsp;\n\r\n\r&nbsp;","fractal","scr\\CVIP_C_functions/fractal.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  5  3  2004-06-04T22:59:00Z  2005-12-01T22:15:00Z  1  657  3748  SIUE  31  8  4397  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     fuzzyc_segment - image segmentation based on fuzzy c-means&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;fuzzyc.h&quot;      #include &quot;CVIPdef.h&quot;&nbsp;     Image *fuzzyc_segment(Image *srcImage, float variance)&nbsp;      &lt;srcImage&gt; - pointer to 3-band Image structure      &lt;variance&gt; - value for Gaussian kernal variance&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\fuzzyc.c&nbsp;DESCRIPTION     Color image segmentation based on thresholding and the fuzzy     c-means can be divided into two stages: coarse and fine seg-     mentation.  The coarse segmentation is  intended  to  reduce     the  computational burden required for the fine segmentation     - the fuzzy c-means. In coarse segmentation,  a  scale-space     filter  is used to analyze the histograms of the three color     components. It determines the number of valid  classes   and     assigns  classified pixels to these classes according to the     threshold value (safety margins).  The   fine   segmentation     uses fuzzy c-means to assign the remaining unclassified pix-     els to their closest class. Histogram   analysis  using  the     scale-space  filter  in coarse segmentation stage is a tech-     nique that  involves generating a multiscale  description of     histogram  by  convolving  it  with a series of Gaussians of     gradually increasing width, and marking  the   location  and     direction  of the sign change of zero-crossing in its second     derivatives. The parameter (x,  tau)-space  is known  to  be     the  scale-space where tau is the scale constant.  The scale     constant tau is inversely  proportional to  the  number   of     peaks and valleys that can be extracted from the histograms.     The importance of this fact is that if prior  knowledge   is     known about a particular type of image, tau can be set to be     a constant to  obtain  the  desired  number  of   peaks  and     values,  and  the  process can be made unsupervised. The tau     value that will give satisfactory  result  in  most  of  the     color  space  used  in  an  experiment is 5. After histogram     analysis, valid classes will  be  determined  according   to     the  safety  margin  (Usually  5%  - 20%) specified by user.     Classified pixels will be assigned to their valid   classes,     and  the  other  pixels  will be tagged as unclassified.  In     this implementation, they will appear as white pixels  (255)     on  the  image. The larger the safety margin, the more accu-     rate the result of the  segmentation   will  be,   and   the     more   computational  efforts  it  will  need when using the     fuzzy c-means in fine stage.  In  fine  segmentation  stage,     the fuzzy membership of the unclassified pixels will be cal-     culated and assigned to the class where they have  the  max-     imum  membership  value.  The last parameter the user has to     decide when  using  the program  is the display color of the     result  image.   The  user has the option of using the means     value for each valid class or the predefined colors for  the     segmented regions.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     Pointer to an Image structure on success, and  NULL  pointer     on failure.&nbsp;EXAMPLE      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;fuzzyc.h&quot;&nbsp;           void main()           {           Image *cvipImage;           IMAGE_FORMAT format;           char *inputfile, *outputfile;&nbsp;           setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;           print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);                /* The input file should be a 3-band Image */            inputfile =(char *) getString_CVIP();           format = getFormat_CVIP(inputfile);           cvipImage = read_Image(inputfile, 1);           view_Image(cvipImage, inputfile);           cvipImage = (Image *) fuzzyc_segment(cvipImage,  4.0);               /* Four color example */           print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);           outputfile = getString_CVIP();           view_Image(cvipImage, outputfile);           write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);           free(inputfile);           free(outputfile);           }&nbsp;BUGS     None at this time&nbsp;SEE ALSO    SEGMENTATION library&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Greg Hance.&nbsp;\n\r\n\r&nbsp;","fuzzyc_segment","scr\\CVIP_C_functions/fuzzyc_segment.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  0  2004-06-04T23:07:00Z  2004-10-19T23:56:00Z  1  378  2158  SIUE  17  5  2531  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     gamma_noise - Add gamma noise to an image&nbsp;SYNOPSIS     #include &quot;CVIPnoise.h&quot;&nbsp;     Image *gamma_noise(Image *imageP,float *var,int *alpha);&nbsp;      &lt;imageP&gt; - pointer to Image structure      &lt;var&gt; - variance of noise distribution      &lt;alpha&gt; - alpha parameter distribution (see equation)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\NOISE\\noise.c&nbsp;DESCRIPTION     Gamma type noise is the result of low-pass filtering  of  an     image containing negative exponential noise as the result of     acquiring an image which is illuminated by a coherent laser.     It\'s histogram is defined as follows:&nbsp;                 Gi^(alpha-1)          hi = -----------------exp(-(Gi/a))               (alpha-1)!a^alpha&nbsp;     where Gi is the grey-level value of the ith pixel, a*a*alpha     is  the variance, and alpha determines the shape of the his-     togram: aplha=1 gives a negative exponential histogram,  and     alpha=infinity gives a Gaussian histogram.&nbsp;RETURN VALUES     The  gamma_noise()  function  returns  the  modified   Image     pointer on success, and returns a NULL pointer on failure&nbsp;BUGS     none&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;CVIPnoise.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      float var=100.0;      int alpha=2;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call adds gamma noise to the input      image with the variance equal to 100.0 and the      factor alpha  equal to 2.We can use the function      gamma_noise_setup so  that the user can specify      the inputs  */      cvipImage = gamma_noise(cvipImage,&amp;var,&amp;alpha);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     gaussian_noise(3),   neg_exp_noise(3),    rayleigh_noise(3),     speckle_noise(3), uniform_noise(3)&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and     David Lyons.&nbsp;\n\r\n\r&nbsp;","gamma_noise","scr\\CVIP_C_functions/gamma_noise.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:07:00Z  2004-10-19T23:56:00Z  1  351  2002  SIUE  16  4  2349  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     gaussian_noise - Add gaussian noise to an image&nbsp;SYNOPSIS     #include &quot;CVIPnoise.h&quot;&nbsp;     Image *gaussian_noise(Image *imageP,float *var,float *mean);&nbsp;      &lt;imageP&gt; - pointer to Image structure      &lt;var&gt; - variance of noise distribution      &lt;mean&gt; - mean or average value of noise distribution&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\NOISE\\noise.c&nbsp;DESCRIPTION     Gaussian noise is the most common type of noise appearing in     an  image.   It  is  called such because it has the Gaussian     shaped histogram as shown by the following equation:&nbsp;                      1          hi = -----------------exp((Gi-m)/(2*sigma^2))               sigma*sqrt(2*pi)&nbsp;     where Gi is the grey-level value of the ith pixel, sigma  is     the variance, m is the mean.&nbsp;RETURN VALUES     The gaussian_noise() function  returns  the  modified  Image     pointer on success, and returns a NULL pointer on failure&nbsp;BUGS     none&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;CVIPnoise.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      float var=100.0;      float alpha=0.5;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call adds gaussian noise to the      input image with the variance equal to 100.0 and      the mean equal to  0.5.We can use the function      gaussian_noise_setup so that the user can      specify the inputs  */      cvipImage = gaussian_noise(cvipImage,&amp;var,&amp;alpha);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);;      }&nbsp;SEE ALSO     gamma_noise(3),     neg_exp_noise(3),     rayleigh_noise(3),     speckle_noise(3), uniform_noise(3)&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE - by Scott Umbaugh  and  David     Lyons.&nbsp;\n\r\n\r&nbsp;","gaussian_noise","scr\\CVIP_C_functions/gaussian_noise.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:08:00Z  2004-10-19T23:56:00Z  1  342  1954  SIUE  16  4  2292  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     geometric_filter - a non-linear mean filter which is  better     at removing gaussian type noise and preserving edge features     than the mean filter.&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;float.h&gt;&nbsp;     Image *geometric_filter(Image *imageP, int mask_size)          &lt;imageP&gt; - pointer to Image structure.          &lt;mask_size&gt; - the size of the filtering  window  (e.g.,     3-&gt;3x3).&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\spatial_filter.c&nbsp;OPTIONS     None.&nbsp;DESCRIPTION     Returns the product of all the pixels in the  filter  window     raised  to  the power of 3/N*N.  Size of filter should be an     odd integer limited from &lt; 3 - 31 &gt;. A zero pixel value will     result in the filtered value being zero.&nbsp;TIPS     Works best on images containing short  tailed  noise.   Keep     filter mask size small to reduce blurring.&nbsp;DIAGNOSTICS     Returns a pointer to the modified Image  structure  on  suc-     cess.  Returns a NULL pointer if the input Image datatype is     not CVIP_BYTE and can\'t be cast to CVIP_FLOAT.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs a geometric filter      operation with the mask size equal to 3 */      cvipImage = geometric_filter(cvipImage,3);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;BUGS     None.&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE - by Scott E. Umbaugh and John     A Creighton.&nbsp;\n\r\n\r&nbsp;","geometric_filter","scr\\CVIP_C_functions/geometric_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:09:00Z  2004-10-19T23:56:00Z  1  672  3835  SIUE  31  8  4499  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     geometric_mean - performs a parametric wiener filter&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtransform.h&quot;      #include &quot;CVIPxformfilter.h&quot;      #include &quot;CVIPdef.h&quot;&nbsp;     Image *geometric_mean(Image  *degr,  Image  *degr_fn,  Image     *p_noise,  Image  *p_orig,  float  gamma,  float  alpha, int     choice, int cutoff)&nbsp;      &lt;degr&gt;    - pointer to the degraded image      &lt;degr_fn&gt; - pointer to the degradation function      &lt;p_noise&gt; - pointer to the noise power spectral density      &lt;p_orig&gt;  - pointer to the original  image  power  spectral     density      &lt;gamma&gt;   - \'gamma\' in the generalized restorationequation.      &lt;alpha&gt;   - \'alpha\' in the  generalized  restoration  equa-     tion.      &lt;choice&gt;  - sets the maximum gain using the DC value  as  a     baseline      &lt;cutoff&gt;  - cutoff frequency for filtering&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\restore_xformfilter.c&nbsp;DESCRIPTION     This function performs a parametric wiener filter.  See  any     image processing textbook for info on Wiener Filters.&nbsp;     The function does its own memory management, freeing  every-     thing  passed to it, so if you need your images intact, make     a copy of them before calling this function.&nbsp;     The function tries to determine whether an FFT has been per-     formed on the passed images.  If not, the function will per-     form the FFT.  This is especially important to note for  the     power  images.   If  the  power  images  are  in the spatial     domain, they will have an FFT performed on them, before  the     squared  magnitude  is calculated.  If an FFT is detected in     the history of any  of  the  power  images,  that  image  is     assumed  to  be  representing  a power image, and no squared     magnitude is calculated.&nbsp;     The function will also extend the sizes of the passed images     as best it can when they are of unequal size.&nbsp;     Also note that the passed images must have the  same  number     of (color) bands.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to the restored (filtered) image&nbsp;HISTORY     History information recorded:&nbsp;       parameter #1 = filter cutoff.       parameter #2 = method 1: F(u,v)=G(u,v) when H(u,v)=0                      method 2: F(u,v)=0 when H(u,v)=0&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;CVIPxformfilter.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage,*cvipImage1;      Image *cvipImage2,*cvipImage3;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      char *inputfile1,*inputfile2;&nbsp;      (void) setDisplay_Image(VIEWER,&quot;default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the File Name of the degraded      image:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call creates a gaussian mask of size      3  * 3 */      cvipImage1 = (Image *)h_image(3,3,3);      print_CVIP(&quot;\\n\\t\\tEnter the File Name of the original      power spectrum image:  &quot;);      inputfile1 =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile1);      cvipImage2 = read_Image(inputfile1,1);      view_Image(cvipImage2, inputfile1);      free(inputfile1);      print_CVIP(&quot;\\n\\t\\tEnter the File Name of the noise      power spectrum image:  &quot;);      inputfile2 =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile2);      cvipImage3 = read_Image(inputfile2,1);      view_Image(cvipImage3, inputfile2);      free(inputfile2);      /* the following call performs the geometric mean on the      input image with the gaussian mask,alpha equal to .25,gamma      equal to .5 and the cut off frequency equal to 32  */      cvipImage3=(Image *)geometric_mean(cvipImage,cvipImage1,      cvipImage2,cvipImage3,.25,.5,1,32);      cvipImage=(Image *)ifft_transform(cvipImage3,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Arve     Kjoelen.&nbsp;\n\r\n\r&nbsp;","geometric_mean","scr\\CVIP_C_functions/geometric_mean.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-04T23:09:00Z  2004-10-19T23:58:00Z  1  223  1277  SIUE  10  2  1498  10.3501                    MicrosoftInternetExplorer4 NAME     GEOMETRY - CVIPtools core toolbox library  for  geometric     manipulations&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPgeometry.h&gt;&nbsp;     See the individual function man pages for details and  exam-     ples.&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY&nbsp;FUNCTIONS     The following functions are included in GEOMETRY:&nbsp;                          bilinear_interp                          copy_paste                          create_black                          creat_checkboard                          create_cosine                          create_circle                          create_degenerate_circle                          create_ellipse                          create_line                          create_rectangle                          create_sine                          create_squarewave                          crop                          display_mesh                          enlarge                          keyboard_to_mesh                          mesh_warping                          mesh_to_file                          rotate                          shrink                          solve_c                          spatial_quant                          translate                          zoom&nbsp;RETURN VALUES     See individual function man pages&nbsp;SEE ALSO     Functions listed above&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E Umbaugh.&nbsp;\n\r\n\r&nbsp;","GEOMETRY","scr\\CVIP_C_functions/GEOMETRY.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:12:00Z  2004-10-19T23:58:00Z  1  390  2227  SIUE  18  5  2612  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     get_default_filter - provides filter kernel&nbsp;SYNOPSIS      #include &quot;CVIPtools.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPfs.h&quot;      #include &quot;CVIPmatrix.h&quot;&nbsp;     Matrix * get_default_filter(PROGRAMS type, int dimension,int     direction)&nbsp;      &lt;type&gt; - type of filter needed      &lt;dimension&gt; - size of blur filter needed      &lt;direction&gt; - direction for difference filter&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\spatial_tools.c&nbsp;DESCRIPTION     Provides a matrix containing the desired  kernel  values  to     calling    functions.&lt;type&gt;   is   one   of:   BLUR_SPATIAL,     DIFFERENCE_SPATIAL,   LOWPASS_SPATIAL,    LAPLACIAN_SPATIAL,     HIGHPASS_SPATIAL.  &lt;dimension&gt;  applies only to BLUR_SPATIAL     filters, and is 3,5,  or  7.  &lt;direction&gt;  applies  only  to     DIFFERENCE_SPATIAL, with 0 = horizontal and 1 = vertical.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to the appropriate matrix&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPmatrix.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage,*cvipImage1;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      Matrix *mat;      int i,j;      unsigned int row=3;      unsigned int col=3;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      mat=new_Matrix(row,col,CVIP_FLOAT,REAL);      if(mat==NULL)             printf(&quot;NULL&quot;);      /*Provides the filter kernel for lowpass spatial      filter in the horizontal direction */      mat=(Matrix *)get_default_filter(LOWPASS_SPATIAL,3,0);      /*The following call convolves the image with      the lowpass filter kernel got by the      get_default_filter */      cvipImage1 = (Image *)convolve_filter(cvipImage,mat);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage1,outputfile);      write_Image(cvipImage1,outputfile,CVIP_NO,CVIP_NO,format,1);     free(outputfile);      }&nbsp;SEE ALSO     SPATIALFILTER library, convolve_Image&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","get_default_filter","scr\\CVIP_C_functions/get_default_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:13:00Z  2004-10-19T23:58:00Z  1  383  2189  SIUE  18  5  2567  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     get_histogram, get_histogram_Image - generates  a  histogram     array/Image from an image&nbsp;SYNOPSIS     #include &quot;histogram.h&quot;&nbsp;     float **get_histogram(Image *imageP)      &lt;imageP&gt; - pointer to the input Image pointer&nbsp;     Image *get_histogram_Image(Image* imageP)      &lt;imageP&gt; - pointer to the input Image pointer&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\HISTOGRAM\\histogram.c&nbsp;DESCRIPTION     get_histogram takes a pointer to an Image structure and gen-     erates  a  histogram  from  the input Image structure in the     form of a pointer to a pointer to a float.  A separate  his-     togram will be generated for each band in the image.&nbsp;     get_histogram_Image is  similar  to  get_histogram,  but  it     returns an Image * of the input Image histogram, and is usu-     ally used for display purpose.&nbsp;RETURN VALUES     On success, get_histogram returns float**, which  is  a  2-D     array  containing  a  histogram  for each band in the image;     get_histogram_Image  returns  a  valid  Image  pointer.   On     failure, both functions return a NULL pointer.&nbsp;BUGS     May not work with some gif images.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include  &quot;histogram.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      float **histogram;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call generates the histogram of      the image and returns a double float pointer */      histogram = get_histogram(cvipImage);      free(histogram);      /* the following call generates the histogram of      the image and returns the image pointer */      cvipImage = get_histogram_Image(cvipImage);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     define_histogram, hist_spec, histogram_show, histogram_spec,     make_histogram, showMax_histogram&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and     David Lyons.&nbsp;\n\r\n\r&nbsp;","get_histogram,get_histogram_Image","scr\\CVIP_C_functions/get_histogram, get_histogram_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  4  2004-06-04T23:10:00Z  2004-10-19T23:59:00Z  1  193  1105  SIUE  9  2  1296  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     getFormat_CVIP - returns file format&nbsp;SYNOPSIS      #include &lt;stdlib.h&gt;      #include &lt;string.h&gt;      #include &lt;stdio.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #include &lt;unistd.h&gt;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPhalftone.h&quot;      #include &quot;CVIPluminance.h&quot;      #include &quot;CVIPconutils.h&quot;      #include &quot;CVIPgif.h&quot;      #include &quot;CVIPras.h&quot;      #include &quot;CVIPpnm.h&quot;      #include &quot;CVIPccc.h&quot;      #include &quot;CVIPtiff.h&quot;      #include &quot;CVIPitex.h&quot;      #include &quot;CVIPeps.h&quot;      #include &quot;CVIPbin.h&quot;      #include &quot;CVIPmagic.h&quot;      #include &quot;CVIPvip.h&quot;      #include &quot;pnm.h&quot;      #include &quot;CVIPcompress.h&quot;&nbsp;     IMAGE_FORMAT getFormat_CVIP(char *filename)&nbsp;     &lt;filename&gt; - pointer to character string containing the name     of the file name&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\CONVERSION\\convert.c&nbsp;DESCRIPTION     This function will read the name of filename  passed  to  it     and and return the enumerated type name of the function. The     function is case insensitive.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES      The FORMAT of the image&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO      CONVERSION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Greg     Hance.&nbsp;\n\r\n\r&nbsp;","getFormat_CVIP","scr\\CVIP_C_functions/getFormat_CVIP.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:14:00Z  2004-10-19T23:59:00Z  1  512  2923  SIUE  24  6  3429  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     glr_compress - Performs gray level runlength coding&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;grey_RLC.h&quot;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;&nbsp;     int glr_compress(Image *inputImage, char *filename, int win)      &lt;inputImage&gt; - a pointer to an Image structure      &lt;filename&gt; - pointer to char string containing filename      &lt;win&gt; - size of window (1-128)&nbsp;     Image *glr_decompress(char filename)&nbsp;      &lt;filename&gt; - name of the compressed file&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\gray_RLC.c&nbsp;DESCRIPTION     glr_compress takes three parameters,   the  pointer  to  the     input  image  array of type byte, the file name to which the     compressed image is to be stored, and the window length. The     valid window length is (1-128). The user is suggested to use     window length from 1-75 as this range gives better  results.     The higher the window range the higher the compression ratio     and vice versa. At the end of the compression, this  routine     automatically  writes  to  the  working window the following     data: the size of the original image, size of the compressed     file, compression ratio.&nbsp;     Algorithmic details can be found in &quot;A Dynamic  Window-Based     Runlength Coding Algorithm Applied to Gray-Level Images&quot;, M.     Kumaran, S.E Umbaugh, GRAPHICAL MODELS AND IMAGE PROCESSING,     Vol. 57, No. 4, July 1995, pp. 267-282.&nbsp;     glr_decompress takes pointer  to  the  character  array  and     returns pointer to the image. The character array represents     the filename to be decoded. It  returns  a  pointer  to  the     decoded image structure.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     glr_compress: 0 on success, -1 on failure&nbsp;     glr_decompress: an uncompressed image pointer on success,  a     NULL pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the gray level run length      coding with the window size equal to 32 */      glr_compress(cvipImage,&quot;file1&quot;,32);      /* the following call performs the gray level run length      decoding of the &quot;file1&quot; */      cvipImage=glr_decompress(&quot;file1&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO    COMPRESSION library&nbsp;DIAGNOSTICS     The Gray level Runlength coding and decoding  algorithm  was     designed to work only on monochrome images.&nbsp;AUTHOR     Muthu Kumar, SIUE&nbsp;     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Muthu Kumar.&nbsp;\n\r\n\r&nbsp;","glr_compress","scr\\CVIP_C_functions/glr_compress.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:15:00Z  2004-10-19T23:59:00Z  1  281  1603  SIUE  13  3  1881  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME    gray_binary - performs binary/gray code conversion&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPimage.h&quot;&nbsp;     Image * gray_binary(Image * inputImage, int direction)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;direction&gt; - direction (0=gray-&gt;binary 1=binary-&gt;gray)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\CONVERSION\\gray_binary.c&nbsp;DESCRIPTION     Performs binary code to gray code conversion and the inverse     conversion.   The input image should be a real image, of any     data type (CVIP_BYTE, CVIP_SHORT,  CVIP_INTEGER,  CVIP_FLOAT     or CVIP_DOUBLE).&nbsp;     Based on code in Numerical Recipes in C, second edition.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to an encoded image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the binary code to gray      code conversion */      cvipImage = gray_binary(cvipImage,0);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO    CONVERSION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","gray_binary","scr\\CVIP_C_functions/gray_binary.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:15:00Z  2004-10-19T23:59:00Z  1  448  2557  SIUE  21  5  3000  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     gray_linear - performs linear gray level modification&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPimage.h&quot;&nbsp;     Image *gray_linear(Image * inputImage, double start,  double     end, double s_gray, double slope, int change, int band)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;start&gt; - initial gray level to modify      &lt;end&gt; - final gray level to modify      &lt;s_gray&gt; - new initial gray level      &lt;slope&gt; - slope of modifying line      &lt;change&gt; - 0=change out-of-range pixels to black                 1=don\'t modify out-of-range pixel values      &lt;band&gt; - the band number to modify&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\HISTOGRAM\\graylevel_mod.c&nbsp;DESCRIPTION     Performs linear gray level modification on a range of values     in an image.  The user specifies a range of values to change     with &lt;start&gt; and &lt;end&gt;, the new gray level to apply  at  the     &lt;start&gt;  value,  and the function calculates a new value for     each subsequent gray value by applying &lt;slope&gt; to  &lt;s_gray&gt;,     until  &lt;end&gt; is reached. Slope can be positive, negative, or     zero. Those values not within the range &lt;start&gt;...&lt;end&gt;  can     be set to zero or left unmodified.&nbsp;     The parameter band specifies which band to modify, which can     be a non-negative integeter (from 0 to no_of_bands -1) for a     specific band, or -1 representing  all  bands.  If  band  is     equal to or greater than no_of_bands, the function will fail     and return a NULL pointer, since the required  band  doesn\'t     exist.  Usually,  the  user  is recommended to use -1 as the     simplest way to use the function.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to a modified image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;histogram.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs a mapping for pixels      ranging from 0 to 255 with the starting pixel being      0 and the slope of the mapping being 2. The mapping      works on all bands*/      cvipImage = gray_linear(cvipImage,0.0,255.0,0.0,2.0      ,0, -1);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     HISTOGRAM library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","gray_linear","scr\\CVIP_C_functions/gray_linear.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:16:00Z  2004-10-19T23:59:00Z  1  265  1513  SIUE  12  3  1775  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     gray_multiply - multiplies each pixel by a fixed ratio&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmatrix.h&gt;&nbsp;     Image *gray_multiply(Image *input,float ratio)&nbsp;      &lt;input&gt; - pointer to an Image      &lt;ratio&gt; - multiplier&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\HISTOGRAM\\graylevel_mod.c&nbsp;DESCRIPTION     The function gray_multiply multiplies each pixel in an image     by  a  fixed  value.  The  function  clips to 0 and 255, and     requires CVIP_BYTE type input.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to an image&nbsp;HISTORY     History information recorded: None      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;histogram.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call multiplies each pixel value by      a factor of 2.0 with clipping at 255 */      cvipImage = gray_multiply(cvipImage,2.0);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     HISTOGRAM library, gray_multiply2&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","gray_multiply","scr\\CVIP_C_functions/gray_multiply.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  6  5  2004-06-04T23:16:00Z  2004-11-03T02:58:00Z  1  273  1557  SIUE  12  3  1827  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     gray_multiply2 - multiplies each pixel by a fixed ratio&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmatrix.h&gt;&nbsp;     Image *gray_multiply2(Image *input,float ratio)&nbsp;      &lt;input&gt; - pointer to an Image      &lt;ratio&gt; - multiplier&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\HISTOGRAM\\graylevel_mod.c&nbsp;DESCRIPTION\n\r\n\r     gray_multiply2 first casts the  input image  to  CVIP_FLOAT\n\r\n\r     image,  then  multiplies each pixel by a fixed valuewithout\n\r\n\r     clipping the image data, and returns a CVIP_FLOAT image.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to an image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE\n\r\n\r      #include &lt;CVIPtoolkit.h&gt;\n\r\n\r      #include &lt;CVIPimage.h&gt;\n\r\n\r      #include &lt;CVIPconvert.h&gt;\n\r\n\r      #include &lt;CVIPview.h&gt;\n\r\n\r      #include&quot;histogram.h&quot;\n\r\n\r      #defineVIEWER &quot;picture&quot;\n\r\n\r      #defineVIDEO_APP &quot;SunVideo &amp;&quot;\n\r\n\r&nbsp;\n\r\n\r      void main()\n\r\n\r      {\n\r\n\r      Image *cvipImage;\n\r\n\r      IMAGE_FORMATformat;\n\r\n\r      char *inputfile,*outputfile;\n\r\n\r&nbsp;\n\r\n\r      setDisplay_Image(VIEWER,&quot;Default&quot;);\n\r\n\r&nbsp;\n\r\n\r      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name: &quot;);\n\r\n\r      inputfile =(char *) getString_CVIP();\n\r\n\r      format = getFormat_CVIP(inputfile);\n\r\n\r      cvipImage = read_Image(inputfile, 1);\n\r\n\r      view_Image(cvipImage, inputfile);\n\r\n\r      free(inputfile);\n\r\n\r      /* thefollowing call multiplies each pixel value by\n\r\n\r      a factor of 2.0,without clipping at 255 */\n\r\n\r      cvipImage =gray_multiply2(cvipImage,2.0);\n\r\n\r      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);\n\r\n\r      outputfile = getString_CVIP();\n\r\n\r      view_Image(cvipImage,outputfile);\n\r\n\r      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);\n\r\n\r      free(outputfile);\n\r\n\r      }&nbsp;SEE ALSO     HISTOGRAM library, gray_multiply2&nbsp;AUTHOR\n\r\n\r     Copyright (C) 1996,2005 SIUE - by Scott E. Umbaugh and Yansheng\n\r\n\r     Wei.&nbsp;&nbsp;\n\r\n\r&nbsp;","gray_multiply2","scr\\CVIP_C_functions/gray_multiply2.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:17:00Z  2004-10-19T23:59:00Z  1  282  1608  SIUE  13  3  1887  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     gray_quant_segment - remaps to desired number of gray levels&nbsp;SYNOPSIS      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmatrix.h&gt;      #include &quot;CVIPsegment.h&quot;&nbsp;     Image * gray_quant_segment(Image *cvipImage, int num_bits)&nbsp;      &lt;cvipImage&gt; - pointer to an Image structure      &lt;num_bits&gt; - number of gray levels desired (2,4,8,...128)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\gray_quant.c&nbsp;DESCRIPTION     This  function  remaps  (quantizes)  an  image  to  a  user-     specified  number  of gray levels. The number of gray levels     used must be a power of 2, to a maximum of 128 levels.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     A quantized image on success, and NULL pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call remaps the desired number of      gray levels to 2 */      cvipImage = (Image *)gray_quant_segment(cvipImage,2);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,      format,1);      free(outputfile);      }&nbsp;SEE ALSO     SEGMENTATION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","gray_quant_segment","scr\\CVIP_C_functions/gray_quant_segment.htm","   ACADEMIC COMPUTING  Normal  P!Nk  5  85  2009-12-04T17:31:00Z  2009-12-07T23:22:00Z  2  423  2417  SIUE  20  5  2835  12.00    BestFit  Clean  Clean  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                            NAME     gvfsnake_segment - an active contour segmentation technique. &nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPsegment.h&quot;&nbsp;      Image *gvfsnake_segment(Image *inputImage, int num_iter, double alpha, double beta, double kappa)&nbsp;      &lt;inputImage&gt;     - pointer to an Image structure        &lt;num_iter&gt;     - number of iterations           &lt;alpha&gt;     - coefficient of the second derivative of the function in the energy equation            &lt;beta&gt;     - coefficient of the fourth derivative of the function in the energy equation           &lt;kappa&gt;     - coefficient of the external forces in the energy equation &nbsp;      PATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\gvfsnake.c&nbsp;DESCRIPTION\n\r\n\rThe gvf snake method canbe used for edge detection,\n\r\n\rsegmentation,shape modeling and motion tracking. \n\r\n\rA snake, is a curve defined within an image domain that \n\r\n\rcan move under the influence of internal forces within \n\r\n\rthe curve itself and external forces derived from the \n\r\n\rimage data. The internal and external forces are defined \n\r\n\rso that the snake will conform to an object boundaryor other desired features within an image. This functioncalculates the external forces by calculating the gradient vector flow fields in the image.The method works only on gray level images. Though thefunction itself converts the image even if the inputimage is a color image.      TYPES AND CONSTANTS        None.     RETURN VALUES     Returns an Image pointer upon successful completion, and     returns NULL on failure.&nbsp;EXAMPLE      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPsegment.h&quot;      #include &quot;CVIPimage.h&quot;&nbsp;           void main()           {               Image *cvipImage;               int num_iter;                double alpha, beta, kappa;                char *inputfile;&nbsp;\n\r\n\r                              print_CVIP(&quot;\\n\\t\\tEnter the Input File Name: &quot;);  \n\r\n\r               inputfile= getString_CVIP();\n\r\n\r               cvipImage = read_Image(inputfile ,1);&nbsp;               print_CVIP(&quot;\\n\\t\\tEnter the number of itearations:  &quot;);               num_iter = getInt_CVIP(1, 0, 1000);                           print_CVIP(&quot;\\n\\t\\tEnter the alpha coefficient:  &quot;);                alpha = getUInt_CVIP(0.01, 0, 0.2);                          print_CVIP(&quot;\\n\\t\\tEnter the beta coefficient:  &quot;);                beta = getUInt_CVIP(0.01, 0, 0.2);                               print_CVIP(&quot;\\n\\t\\tEnter the kappa coefficient:  &quot;);                kappa = getUInt_CVIP(0.01, 0, 0.2);                           cvipImage = gvfsnake_segment(cvipImage, num_iter, alpha, beta, kappa);&nbsp;               view_Image(cvipImage, \"GVF Snake\");&nbsp;               free(inputfile);                delete_Image (cvipImage);           }&nbsp;BUGS     None at this time.&nbsp;SEE ALSO    SEGMENTATION library&nbsp;AUTHOR     Copyright (C) 2010 SIUE - by Scott Umbaugh and Pelin Guvenc.&nbsp;\n\r\n\r&nbsp;","gvfsnake_segment","scr\\CVIP_C_functions/gvfsnake_segment.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  3  2004-06-04T23:32:00Z  2004-10-20T00:00:00Z  1  275  1572  SIUE  13  3  1844  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     h_image - create a mask image according to the size and type&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmatrix.h&gt;&nbsp;     Image *h_image(int type, unsigned int height,  unsigned  int     width)&nbsp;      &lt;type&gt;   - mask type: 1-Constant                            2-Center weighted                            3-Gaussian      &lt;height&gt; - height of the mask image      &lt;width&gt;  - width of the mask image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\h_image.c&nbsp;DESCRIPTION     Creates a single band mask image of size (width x height). A     constant  mask image has all the pixel values as 1; a center     weighted mask image is  the same as a  constant  mask  image     except  the  central value is (width x height); the Gaussian     mask is normalized to (width x height) at the central value.     The return Image data type is CVIP_FLOAT.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to a CVIP_FLOAT real image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      (void) setDisplay_Image(VIEWER,&quot;default&quot;);      /* the following call creates a gaussian mask of size 3 */      cvipImage=h_image(3,3,3);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh  and  Yansheng     Wei.&nbsp;\n\r\n\r&nbsp;","h_image","scr\\CVIP_C_functions/h_image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:18:00Z  2004-10-20T00:00:00Z  1  283  1619  SIUE  13  3  1899  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     haar_transform - performs a fast Haar transform&nbsp;SYNOPSIS      #include &quot;CVIPtools.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPtransform.h&quot;&nbsp;     Image  *haar_transform(Image  *in_Image,   int   ibit,   int     block_size)&nbsp;      &lt;in_Image&gt; - pointer to an Image structure      &lt;ibit&gt; - 1 (forward transform) or 0 (inverse transform)      &lt;block_size&gt; - block size (4,8,16,...largest_dimension/2)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\TRANSFORMS\\haar.c&nbsp;DESCRIPTION     This function performs a fast Haar transform. The image must     have dimensions that are a power of two.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A transformed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;CVIPtransform.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call  performs  a  haar_transform  on  the     input image with block size equal to 8 */      cvipImage = haar_transform(cvipImage, 1,8);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     TRANSFORMS library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Arve     Kjoelen.&nbsp;\n\r\n\r&nbsp;","haar_transform","scr\\CVIP_C_functions/haar_transform.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:19:00Z  2004-10-20T00:00:00Z  1  367  2098  SIUE  17  4  2461  10.3501    Clean  Clean                  MicrosoftInternetExplorer4      NAME     harmonic_filter -  a non-linear mean filter which is  better     at removing gaussian type noise and preserving edge features     than the mean filter. Good at removing positive outliers.&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;float.h&gt;&nbsp;     Image *harmonic_filter(Image *imageP, int mask_size)           &lt;imageP&gt; - pointer to Image structure.           &lt;mask_size&gt; - size of the filtering window  (e.g.,  3-     &gt;3x3).&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\spatial_filter.c&nbsp;OPTIONS     None.&nbsp;DESCRIPTION     Returns a value equal to N*N divided by the inverse  of  the     sum  of  the  pixels in the filter window.  The filter  size     should be an odd integer limited from &lt; 3 - 31&gt;.&nbsp;TIPS     Works best on short tailed types of noise such  as  Gaussian     noise.  Keep the filter mask small to minimize blurring.&nbsp;DIAGNOSTICS     Returns a pointer to the modified Image  structure  on  suc-     cess.  Returns a NULL pointer if the input Image datatype is     not CVIP_BYTE and can\'t be cast to CVIP_FLOAT.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs a harmonic filter      operation with the mask size equal to 3 */      cvipImage = harmonic_filter(cvipImage,3);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;BUGS     None&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE - by Scott E. Umbaugh and John     A Creighton.&nbsp; -  a non-linear mean filter which is  better     at removing gaussian type noise and preserving edge features     than the mean filter. Good at removing positive outliers.&nbsp;&nbsp;\n\r\n\r&nbsp;","harmonic_filter","scr\\CVIP_C_functions/harmonic_filter.htm","   Mounika  Normal  jhansi  69  56  2004-06-04T21:33:00Z  2010-01-06T21:55:00Z  1  366  2090  SIUE  17  4  2452  11.9999    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4        NAME&nbsp;&nbsp;&nbsp;&nbsp; harris_filter - a spatial- a corner detection filter.&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPtoolkit.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPconvert.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPdef.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPimage.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPspfltr.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image&nbsp;&nbsp;&nbsp; *harris_filter(Image&nbsp;&nbsp;&nbsp; *inputIMAGE,float&nbsp;&nbsp;&nbsp; alpha,int&nbsp;&nbsp;&nbsp;&nbsp; threshold, int border,float dmin)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;inputImage&gt; - pointer to an Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;alpha&gt; - sensitivity of the detector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;threshold&gt; - threshold value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;border&gt; -  the number of rows and colums along the image border&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dmin&gt; - radius of the circle to check for the corner&nbsp;&nbsp;PATH&nbsp;&nbsp;&nbsp;&nbsp; $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\harris_filter.c&nbsp;DESCRIPTION&nbsp;&nbsp;&nbsp;&nbsp; The Harris filter is a spatial-domain method for for corner detector developed by&nbsp;&nbsp;&nbsp;&nbsp; Harris and Stephens in 1988.In this filter corner response function to find the corners.&nbsp;\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Where CRF(r,c) represents the corners&nbsp; of&nbsp; the original&nbsp; image&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;And G(P1*P1) is the Gaussian of the vertical gradient. G(P2*P2)&nbsp;&nbsp;&nbsp;&nbsp; Is the Gaussian of horizontal gradient.&nbsp;&nbsp;&nbsp;&nbsp; TYPES AND CONSTANTS&nbsp;&nbsp;&nbsp;&nbsp; None&nbsp;RETURN VALUES&nbsp;&nbsp;&nbsp;&nbsp; Pointer to the processed image&nbsp;HISTORY&nbsp;&nbsp;&nbsp;&nbsp; History information recorded: None&nbsp;&nbsp;EXAMPLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPtoolkit.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPconvert.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPdef.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPimage.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPspfltr.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void main() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image *cvipImage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMAGE_FORMAT format;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *inputfile,*outputfile;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void) setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_CVIP(&quot;\\n\\t\\tEnter the&nbsp; Input File Name:&nbsp; &quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputfile =(char *) getString_CVIP();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; format = getFormat_CVIP(inputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvipImage = read_Image(inputfile,1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view_Image(cvipImage, inputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(inputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* the following call performs filter operation in a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With sensitivity alpha of 0.05, threshold 20000 , border value of 20 and&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the dmin value of 10*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvipImage = harris_filter(cvipImage, 0.05f, 20000, 20, 10.0f);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:&nbsp; &quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputfile = getString_CVIP();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view_Image(cvipImage,outputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(outputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;SEEALSO&nbsp;&nbsp;&nbsp;&nbsp; SPATIALFILTER library&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 2010 SIUE - by Scott Umbaugh and Mounika Mamidi.\n\r\n\r&nbsp;","harris_filter","scr\\CVIP_C_functions/harris_filter.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:20:00Z  2004-10-20T00:00:00Z  1  156  890  SIUE  7  2  1044  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     hexrotate - rotates a structuring element&nbsp;SYNOPSIS      #include &lt;stdio.h&gt;      #include &lt;string.h&gt;      #include &quot;CVIPimage.h&quot;      #include &lt;stdlib.h&gt;      #include &lt;stdarg.h&gt;      #include &quot;CVIPmorph.h&quot;&nbsp;     MATRIX *hexrotate(surMATRIX, connectedness, degrees)&nbsp;      &lt;surMATRIX&gt; - pointer to MATRIX structure      &lt;connnectedness&gt; - either SIX_NWSE or SIX_NESW      &lt;degrees&gt; -degrees to rotate (multiple of 60)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\MORPHOLOGICAL\\morphSET.c&nbsp;DESCRIPTION     This function rotates a (3x3) hexagonal structuring  element     (the  surround) by a user-specified number of degrees, which     must be a multiple of 60.&nbsp;TYPES AND CONSTANTS      #define SIX_NWSE 6      #define SIX_NESW 7&nbsp;     See also $CVIPHOME/include/CVIPmorph.h for surround definitions.&nbsp;RETURN VALUES     A pointer to the rotated surround.&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     MORPHOLOGICAL library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Greg     Hance.&nbsp;\n\r\n\r&nbsp;","hexrotate","scr\\CVIP_C_functions/hexrotate.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:21:00Z  2004-10-20T00:00:00Z  1  484  2760  SIUE  23  6  3238  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     High_Freq_Emphasis  -  performs  high   frequency   emphasis     filtering&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &lt;CVIPtransform.h&gt;      #include &lt;CVIPxformfilter.h&gt;&nbsp;     Image *High_Freq_Emphasis(Image *in_Image,int block_size,int     dc,int Cutoff,float alfa,int order)&nbsp;      &lt;in_Image&gt; - pointer to an Image structure      &lt;block_size&gt; - desired block size      &lt;dc&gt; - drop(0) or retain(1) dc component      &lt;Cutoff&gt; - cutoff frequency      &lt;alfa&gt; - a constant (typically 1.0 to 2.0)      &lt;order&gt; - filter order&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\filter.c&nbsp;DESCRIPTION     High_Freq_Emphasis() performs a  two-dimensional  high  fre-     quency  emphasis  filtering  in  transform  domain  on input     image.It is implemented by adding a constant  to  a  butter-     worth high pass filter transfer function. This preserves the     low frequency components of the image and at the same  time,     amplifies  the high-frequency components. The result of this     process is better tonality in the final image.  The  cut-off     frequency cutoff and filter order &lt;order&gt; is for the butter-     worth high pass filter used in this high frequency  emphasis     filter.  Experiment  revealed  that the constant alfa in the     range of 1.0 to 2.0 yields good result. If dc equals 1,  the     dc  component  will be retained, if it equals 0, the dc com-     penent will be dropped.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A filtered image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the fft_transform on the      input image with the block size equal to 256 */      cvipImage=(Image *)fft_transform(cvipImage,256);      /* the following call performs the high frequency emphasis      on the transformed image with the cut off frequency equal      to 64 and alpha equal to 1.2 */      cvipImage = (Image *)High_Freq_Emphasis(cvipImage,256,1,      64,1.2,2);      /* the following call performs the inverse fft_transform in      the filtered image with the block size equal to 256 */      cvipImage = (Image *)ifft_transform(cvipImage,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Simon Low.&nbsp;\n\r\n\r&nbsp;","High_Freq_Emphasis","scr\\CVIP_C_functions/High_Freq_Emphasis.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  5  6  2004-06-04T23:24:00Z  2005-12-02T04:43:00Z  1  532  3036  SIUE  25  7  3561  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     hist_feature - calculates histogram features: mean, standard     deviation, skew, energy and entropy&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPimage.h&quot;&nbsp;      double    *hist_feature(Image     *originalImage,     Image     *labeledImage, int r, int c)&nbsp;       &lt;originalImage&gt; - Pointer to the original image       &lt;labeledImage&gt; -  Pointer to the labeled image       &lt;r&gt; - row coordinate of a point on the labled image       &lt;c&gt; - column coordinate of a point on the labled image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\hist_feature.c&nbsp;DESCRIPTION          The program first calculates the histogram P(g) of the          object of interest in each band, then computes mean,          standard deviation, skew, energy and entropy. Those gray          level values whose P(g) equal to zero are filtered out.          Equations of these five measures are given in chapter 6          of the following book:&nbsp;          Computer Imaging: Digital Image Analysis and Processing&nbsp;             Scott E Umbaugh, A CRC Press Book, 2005&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES          A pointer to double, its value is equal to the initial          address of  a  one_dimensional  array,  which  contains     above          five histogram features of each band. If  the  original     image          is a color image, the first five values are for band 0,     the          next five data are for band 1, and so on.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE     #include   &quot;CVIPdef.h&quot;   #include   &quot;CVIPimage.h&quot;   #include     &quot;CVIPhisto.h&quot;  #include  &quot;CVIPmap.h&quot;  #include  &quot;CVIPview.h&quot;     #include &quot;math.h&quot; #include &quot;CVIPobject.h&quot; #include &quot;stdio.h&quot;     #include &quot;threshold.h&quot;&nbsp;      void  main()  {         Image  *inputImage,  *labeledImage,     *inputImage_dup;              int rows, cols, r, c;              char *inputfile;              double *result;&nbsp;              setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);              print_CVIP(&quot;0nter the Input File Name:  &quot;);              inputfile = (char *) getString_CVIP();              inputImage = read_Image( inputfile ,1);              view_Image(inputImage,inputfile);           inputImage_dup = duplicate_Image( inputImage );           labeledImage =  label(  threshold_segment(  inputImage     ,128, CVIP_NO) );&nbsp;              rows = getNoOfRows_Image(labeledImage);              cols = getNoOfCols_Image(labeledImage);&nbsp;              print_CVIP(&quot;0nter the row coordinate of a point  on     the labled image: &quot;);              r = getInt_CVIP(10, 0, rows);              print_CVIP(&quot;0nter the col coordinate of a point  on     the labled image: &quot;);              c = getInt_CVIP(10, 0, cols);&nbsp;              result =   hist_feature(inputImage_dup,  labeledIm-     age, r, c);&nbsp;              print_CVIP(&quot;Histogram feature:0);              print_CVIP(&quot; mean = %f00, result[0] );              print_CVIP(&quot; standard deviation = %f00, result[1] )     ;              print_CVIP(&quot; skew = %f00, result[2]) ;              print_CVIP(&quot; energy = %f00, result[3]) ;              print_CVIP(&quot; entropy = %f00, result[4]) ;&nbsp;              delete_Image ( inputImage );              delete_Image ( labeledImage );              delete_Image ( inputImage_dup );&nbsp;       }&nbsp;DIAGNOSTICS          The original image can be of any of these  data  types:     CVIP_BYTE,          CVIP_SHORT, CVIP_INTEGER, CVIP_FLOAT and CVIP_DOUBLE.&nbsp;SEE ALSO     FEATURE library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","hist_feature","scr\\CVIP_C_functions/hist_feature.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:25:00Z  2004-10-20T00:00:00Z  1  263  1501  SIUE  12  3  1761  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     hist_slide - performs histogram slide&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmatrix.h&gt;      #include &lt;CVIPhisto.h&gt;&nbsp;     Image* hist_slide(Image *input,int slide)&nbsp;      &lt;input&gt; - pointer to an Image      &lt;slide&gt; - amount of slide&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\HISTOGRAM\\hist_slide.c&nbsp;DESCRIPTION     This function slides a histogram up if &lt;slide&gt;  is  positive     or  down  if &lt;slide&gt; is negative. It requires CVIP_BYTE type     input, and clips at 0 or 255.&nbsp;TYPESAND CONSTANTS     None&nbsp;RETURNVALUES     Pointer to the modified image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;histogram.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call slides the histogram in the      positive direction by 50 */      cvipImage = hist_slide(cvipImage,50);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEEALSO     HISTOGRAM library&nbsp;AUTHOR     Copyright (C) 1996 SIUE - by Scott E. Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","hist_slide","scr\\CVIP_C_functions/hist_slide.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  0  2004-06-04T23:26:00Z  2004-10-20T00:01:00Z  1  542  3094  SIUE  25  7  3629  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     hist_spec - performs histogram specification on an image&nbsp;SYNOPSIS     #include &quot;histogram.h&quot;&nbsp;     Image *hist_spec(Image *imageP, int mode, char **input);&nbsp;      &lt;imageP&gt; - pointer to the input Image structure.  The  data               type of the image must be CVIP_BYTE or remapped to               CVIP_BYTE;      &lt;mode&gt; - if mode = 1, interactively get the histogram               if mode = 0, the histogram is specified by input;      &lt;input&gt; - expressions for the specified histogram&nbsp;     Image *histogram_spec(Image* imageP, float **histogram);      &lt;imageP&gt; - pointer to the input Image structure;      &lt;histogram&gt; - the specified histogram&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\HISTOGRAM\\histogram.c&nbsp;DESCRIPTION     The histogram_spec() function performs a histogram  specifi-     cation on an image pointer Image* using the histogram speci-     fied in the pointer to pointer to float  float**  passed  to     the function.  The specified histogram is computed by calcu-     lating the cumulative distrubution function of both the ori-     ginal  histogram and the desired histogram.  The cdf for the     original histogram is then mapped to the  desired  histogram     using  the inverse cdf.  If Pr(x) is the original histogram,     and Pz(x) is the desired histogram, then  the  cdf[Pr(x)]  =     T(r) = s, and cdf[Pz(x)] = G(z) = v.  The inverse of this is     z = inv[G(v)].  Therefore z = inv[G(T(r))].  Where r is  the     original  grey-level, and z is the new grey-level.&nbsp;     The histogram_spec can perform a different specification  on     each color band in the image.&nbsp;     hist_spec()   is   a    higher    level    function    above     histogram_spec().  The  difference  is that hist_spec() will     get a mathematical formula for  each  band  to  specify  the     desired  histogram,  create the specified the histogram, and     call histogram_spec(). Usually, the user  calls  hist_spec()     directly, and calls histogram_spec() indirectly.&nbsp;RETURN VALUES     Both functions return a valid Image pointer on success;  and     return a NULL pointer on failure.&nbsp;EXAMPLE       #include &lt;CVIPtoolkit.h&gt;       #include &lt;CVIPdef.h&gt;       #include &lt;CVIPimage.h&gt;       #include &lt;CVIPconvert.h&gt;       #include &quot;CVIPcolor.h&quot;       #include &quot;CVIPhisto.h&quot;&nbsp;       void main()       {         Image *cvipImage;         CVIP_TYPE data_type;         char *inputfile;         char *spec_func = &quot;exp(0.025*x)&quot;;         char *funcs[3];&nbsp;         setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;         print_CVIP(&quot;0Enter the Input File Name: &quot;);         inputfile = (char *)getString_CVIP();         cvipImage = read_Image(inputfile, 1);         view_Image(cvipImage, inputfile);         data_type = getDataType_Image(cvipImage);&nbsp;         /* remap the image to CVIP_BYTE so that hist_spec can            be used. */         if(data_type != CVIP_BYTE)           cvipImage = remap_Image(cvipImage, CVIP_BYTE, 0, 255);&nbsp;         /* If you have only 1 band image, you need to pass            \'NULL\' to funcs[1] and funcs[2]. */         funcs[0] = spec_func;         funcs[1] = spec_func;         funcs[2] = spec_func;&nbsp;         cvipImage = hist_spec(cvipImage, 0, funcs);&nbsp;         view_Image(cvipImage, &quot;output&quot;);&nbsp;         free(inputfile);       }&nbsp;BUGS     May not work with some gif images.&nbsp;SEE ALSO     makeHistogram_Image     define_histogram,     get_histogram,     get_histogram_Image,     histogram_show,     make_histogram,     showMax_histogram&nbsp;AUTHOR     Copyright (C) 1992, 2001, 2004 SIUE - by Scott E.  Umbaugh,  David     Lyons and Yansheng Wei.&nbsp;\n\r\n\r&nbsp;","hist_spec","scr\\CVIP_C_functions/hist_spec.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  5  0  2004-06-04T23:27:00Z  2006-03-30T05:20:00Z  1  347  1984  SIUE  16  4  2327  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     hist_stretch - stretches a histogram&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPimage.h&quot;&nbsp;     Image * hist_stretch(Image * inputImage, int low_limit,  int     high_limit, float low_clip, float high_clip)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;low_limit&gt; - lower limit for stretch      &lt;high_limit&gt; - high limit for stretch      &lt;low_clip&gt; - percentage of low values to clip                   before stretching      &lt;high_clip&gt; - percentage of high values to clip                    before stretching&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\HISTOGRAM\\hist_stretch.c&nbsp;DESCRIPTION     This function increases contrast in an image  by  stretching     the  histogram to span the range low_limit to high_limit. To     improve  performance  of  the  function  when  outliers  are     present, percentages low_clip and high_clip pixel values can     be removed before the stretch takes place.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to a stretched image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;histogram.h&quot;      #include &quot;CVIPhisto.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call ranges the histogram between 0      and 255.Before the ranging is done, the histogram is      clipped with the low level being 0.025 and the high level      being 0.025 */      cvipImage = hist_stretch(cvipImage,0,255,0.025,0.025);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     HISTOGRAM library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","hist_stretch","scr\\CVIP_C_functions/hist_stretch.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  3  2004-06-04T23:27:00Z  2004-10-20T00:01:00Z  1  327  1864  SIUE  15  4  2187  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     hist_thresh_segment - a thresholding-of-histogram  segmenta-     tion technique&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;hist_thresh.h&quot;&nbsp;      Image *hist_thresh_segment(Image *imgP)&nbsp;      &lt;imgP&gt; - pointer to Image structure&nbsp;      Image *hist_thresh_gray(Image *imgP)&nbsp;      &lt;imgP&gt; - pointer to Image structure&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\hist_thresh.c&nbsp;DESCRIPTION     hist_thresh_gray  segments  a  grayscale   image   using   a     thresholding-of-histogram  segmentation  technique  to split     image regions recursively.  hist_thresh_segment is a  driver     of  hist_thresh_gray.  Especially,  if  the  input  image is     multi-band, hist_thresh_segment  first  uses  the  Principal     Components  Transform  (PCT)  to map the maximum information     into one image plane, then calls hist_thresh_gray.&nbsp;TYPES AND CONSTANTS     typedef struct {          int  lower;          int  peak;          int  upper;     } PeakObject;&nbsp;RETURN VALUES     Returns  Image  pointer  upon  successful  completion,   and     returns NULL on failure.&nbsp;EXAMPLE      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;hist_thresh.h&quot;&nbsp;           void main()           {           Image *cvipImage;           IMAGE_FORMAT format;           char *inputfile, *outputfile;&nbsp;           setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;           print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);           inputfile =(char *) getString_CVIP();           format = getFormat_CVIP(inputfile);           cvipImage = read_Image(inputfile, 1);           view_Image(cvipImage, inputfile);           cvipImage = hist_thresh_segment(cvipImage);           print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);           outputfile = getString_CVIP();           view_Image(cvipImage, outputfile);           write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);           free(inputfile);           free(outputfile);           }&nbsp;BUGS     None at this time&nbsp;SEE ALSO    SEGMENTATION library&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Greg Hance.&nbsp;\n\r\n\r&nbsp;","hist_thresh_segment","scr\\CVIP_C_functions/hist_thresh_segment.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  0  2004-06-04T23:22:00Z  2004-10-20T00:02:00Z  1  399  2276  SIUE  18  5  2670  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     histeq - performs histogram equalization&nbsp;SYNOPSIS      #include &lt;stdio.h&gt;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPcolor.h&quot;      #include &quot;CVIPhisto.h&quot;&nbsp;     Image *histeq(Image *in, int band)      &lt;in&gt; - a pointer to an Image structure      &lt;band&gt; - which band (0,1, or 2) to operate on;  use  0  for     gray&nbsp;&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\HISTOGRAM\\histeq.cDESCRIPTION     This function performs a histogram equalization (histeq)  on     an  input  image.   Histeq distributes the gray level values     within an image as evenly as possible. The goal of histeq is     a flat histogram.&nbsp;     The function works with color or grayscale  images.  With  a     color  image, the user specifies band 0, 1, or 2 as the band     to use for histogram calculations.  For a  grayscale  image,     specify  band  \'0\'.  The  function  automatically  casts any     CVIP_INTEGER,   CVIP_FLOAT   or   CVIP_DOUBLE   image   into     CVIP_SHORT.   It   operates   directly  on  images  of  type     CVIP_SHORT and CVIP_BYTE.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Returns a histogram-equalized image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &quot;CVIPcolor.h&quot;      #include &quot;CVIPhisto.h&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile, *outputfile;      int mb=0;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);&nbsp;      if(cvipImage-&gt;bands&gt;1) {      printf(&quot;This function preserves relative      colors.\\n&quot;);      printf(&quot;Select the band on which to calculate\\n&quot;);      printf(&quot;the histogram (0=Red, 1=Green, 2=Blue)\\n&quot;);      mb=getInt_CVIP(10,0,2);      }      if(cvipImage-&gt;image_ptr[0]-&gt;data_type &gt; CVIP_SHORT){      cvipImage=condRemap_Image(cvipImage, CVIP_SHORT,      0, 32767);      }      cvipImage =(Image *)histeq(cvipImage,mb);      cvipImage = remap_Image(cvipImage, CVIP_BYTE,0,255);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage, outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(inputfile);      free(outputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Arve Kjoelen.&nbsp;\n\r\n\r&nbsp;","histeq","scr\\CVIP_C_functions/histeq.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:24:00Z  2004-10-20T00:02:00Z  1  180  1029  SIUE  8  2  1207  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     histogram_show - prints an ASCII representation of a  histo-     gram to stdout&nbsp;SYNOPSIS     #include &quot;histogram.h&quot;&nbsp;     void histogram_show(float **histogram)      &lt;histogram&gt; - a 2-D float arrary of the histogram data&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\HISTOGRAM\\histogram.c&nbsp;DESCRIPTION     histogram_show prints a  histogram  defined  by  the  double     pointer  to  float which is passed to the function to stdout     in ASCII representation.  The output will appear as such:          .          121***********          122*****************          123**************************          .&nbsp;     where the number represents the grey level  value,  and  the     asterisks  represent  the  probability of occurance for that     grey level.  The maximum probability to occur will occupy 75     asterisks.   The maximum probability will also be printed at     the end of the printout.&nbsp;RETURN VALUES     This function returns void&nbsp;BUGS     none&nbsp;SEE ALSO     get_histogram,        get_histogram_Image,        hist_spec,     histogram_show, histogram_spec, showMax_histogram&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and     David A. Lyons.&nbsp;\n\r\n\r&nbsp;","histogram_show","scr\\CVIP_C_functions/histogram_show.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:29:00Z  2004-10-20T00:02:00Z  1  395  2256  SIUE  18  5  2646  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     homomorphic - performs homomorphic  filtering  on  an  input     image&nbsp;SYNOPSIS     #include &quot;CVIPimage.h&quot;     #include &quot;CVIPtransform.h&quot;     #include &quot;CVIPxformfilter.h&quot;     #include &lt;limits.h&gt;&nbsp;     Image*  homomorphic(Image *cvipImage,float upper, float lower,int cutoff)&nbsp;      &lt;cvipImage&gt; - pointer to an Image      &lt;upper&gt; - upper limit, &gt; 1      &lt;lower&gt; - lower limit, &lt; 1      &lt;cutoff&gt; - cutoff frequencyPATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\homomorphic.c&nbsp;DESCRIPTION     Homomorphic filtering  is  used  to  reduce  the  effect  of     illumination  variations  in  a  scene while emphasizing the     reflectance components. This function has a  setup  routine,     called  by  CVIPtools,  to allow the user to input the upper     and lower limits and cutoff frequency  of  the  filter.  The     upper limit should be greater than 1; the lower limit should     be less than 1. Typical values range between 2.0 and 0.5.&nbsp;     There is another function, get_function, that will return  a     floating point array containing the distribution of a filter     mask created using a sine wave.&nbsp;&nbsp;  TYPES AND CONSTANTS     static float*  get_function(int size,int cutoff);&nbsp;EXAMPLE     The following is a brief example of the use  of  homomorphic     filtering:&nbsp;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtransform.h&quot;      #include &quot;CVIPxformfilter.h&quot;      #include &lt;limits.h&gt;&nbsp;      void main()      {       Image *cvipImage;       IMAGE_FORMAT format;       char *inputfile, *outputfile;       float uppercut, lowercut;       int cutoff;&nbsp;       setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;       print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);       inputfile =(char *) getString_CVIP();       format = getFormat_CVIP(inputfile);       cvipImage = read_Image(inputfile, 1);       view_Image(cvipImage, inputfile);       print_CVIP(&quot;\\n\\t\\tEnter the upper gain (1.0-3.0):  &quot;);       uppercut = (float)getFloat_CVIP(1.0, 3.0);       print_CVIP(&quot;\\n\\t\\tEnter the lower gain (.5 - 1.0):  &quot;);       lowercut = (float)getFloat_CVIP(0.5, 1.0);       print_CVIP(&quot;\\n\\t\\tEnter the cutoff frequency (32-128):  &quot;);       cutoff = (int)getInt_CVIP(10, 32, 128);       cvipImage = homomorphic(cvipImage, uppercut, lowercut, cutoff);       print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);       outputfile = getString_CVIP();       view_Image(cvipImage, outputfile);       write_Image(cvipImage, outputfile,CVIP_NO,CVIP_NO,format, 1);       free(inputfile);       free(outputfile);      }&nbsp;BUGS     None.&nbsp;SEE ALSO&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Kun Luo and Scott Umbaugh.\n\r\n\r&nbsp;","homomorphic","scr\\CVIP_C_functions/homomorphic.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:30:00Z  2004-10-20T00:02:00Z  1  324  1847  SIUE  15  4  2167  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     hough_transform,hough_inverse,  hough_filter   -   completes     lines in a binary image&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;&nbsp;     Image *hough_transform(Image* cvipImage,char  *interpret,int     num)&nbsp;      &lt;inputImage&gt; - pointer to a binary image      &lt;interpret&gt; - a string indicating angles of interest      &lt;num&gt; - length of the interpret string&nbsp;     Image  *hough_inverse(Image   *cvipImage,int   height,   int     width,int threshold)&nbsp;      &lt;cvipImage&gt;   -   pointer   to   an   Image   output   from     hough_transform      &lt;height&gt; - height of output image (usually  original  image     size)      &lt;width&gt; - width of output  image  (usually  original  image     size)      &lt;threshold&gt; - minimum number of pixels to define a line&nbsp;     char* parse_string(char *input)&nbsp;      &lt;input&gt; a character to be parsed&nbsp;     Image  *hough_filter(Image  *cvipImage,  char  *name,   char     *degree_string,  int threshold, int connection, int interac-     tive)&nbsp;      &lt;cvipImage&gt; - pointer to a binary image structure      &lt;name&gt; - name of the input image      &lt;degree_string&gt; - a string indicating angles of interest      &lt;threshold&gt; - minimum number of pixels to define a line      &lt;connection&gt; - maximum distance to link on a line      &lt;interactive&gt; - 0 = use above parameters                      1 = read degree_string, threshold, and                          connection from standard input&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\hough.c&nbsp;DESCRIPTION     The Hough transform is designed to find or complete lines in     an image.  It uses an edge-detected image as input and links     those points that fit user-defined  parameters  of  distance     and orientation angle.&nbsp;     For a detailed explanation of the required inputs,  see  the     header         description        in         the        file     &nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A transformed image&nbsp;HISTORY     History information recorded: None&nbsp;BUGS     None at this time&nbsp;SEE ALSO     SPATIALFILTER library, edge_link_filter&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","hough_transform,hough_inverse,hough_filter","scr\\CVIP_C_functions/hough_transform,hough_inverse, hough_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:31:00Z  2004-10-20T00:02:00Z  1  591  3370  SIUE  28  7  3954  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     huf_compress - performs lossless Huffman coding&nbsp;SYNOPSIS      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &lt;time.h&gt;      #include &lt;string.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;huffman.h&quot;&nbsp;     int huf_compress(Image *inputImage, char *filename)&nbsp;      &lt;filename&gt; - pointer to a character array      &lt;inputImage&gt; - pointer to the image&nbsp;     Image *huf_decompress(char *filename)&nbsp;      &lt;filename&gt; - pointer to a character array&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\huffman.c&nbsp;DESCRIPTION     huf_compress takes two parameters, they are a pointer to the     input  image  structure,  and  the  file  name  to which the     compressed image is to be stored.  The user doesn\'t have  to     provide  the filename extension &quot;huf&quot;. Even if the user for-     gets to enter the extension or enters a wrong extension  the     programme  takes  care  of it by appending or replacing with     the correct extension(&quot;huf&quot;). At the end of the compression,     this  routine automatically writes to the working window the     compression ratio. Series of steps are involved  in  huffman     coding.  First the input image is read. Then the array table     is built with the symbol(greylevel value) and  frequency  of     occurence.  Then  a  binary  tree  is  built  from the array     table(probability array). Using the  binary  tree  that  was     built each symbol(greylevel value) is encoded and written to     the user defined binary file.&nbsp;     huf_decompress takes a pointer to the  character  array  and     returns   a  pointer  to  the  image.  The  character  array     represents the filename to be  decoded  with  the  extension     &quot;huf&quot;.  It  returns  a  pointer to the decoded image. During     decompression process the encoded file is read. The  encoded     file  size, symbol frequency, are extracted from the encoded     file. A binary tree is built from the probability table that     was  stored  in  the  encoded  file.  The  original image is     recovered without any loss in information by parsing through     the binary tree.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     huf_compress: 0 on success, -1 on failure&nbsp;     huf_decompress: an uncompressed image pointer on success,  a     NULL pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;huffman.h&quot;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the huffman coding of      the input image */      huf_compress(cvipImage,&quot;file1&quot;);      /* the following call performs the huffman decoding      of the &quot;file1&quot; */      cvipImage=huf_decompress(&quot;file1&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     COMPRESSION library&nbsp;DIAGNOSTICS     The Huffman coding and decoding algorithms was  designed  to     work only on monochrome image(.pgm).&nbsp;AUTHOR     Implemented By: Mark Heffron SIUE&nbsp;     Ported By     : Muthu kumar, SIUE&nbsp;     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh.&nbsp;\n\r\n\r&nbsp;","huf_compress","scr\\CVIP_C_functions/huf_compress.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:33:00Z  2004-10-20T00:02:00Z  1  576  3285  SIUE  27  7  3854  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Ideal_Band_Pass - perform ideal bandpass filtering&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;&nbsp;     Image  *Ideal_Band_Pass(Image  *in_Image,int  block_size,int     dc,int inner,int  outer)&nbsp;      &lt;in_Image&gt; - pointer to an Image structure      &lt;block_size&gt; - desired block size      &lt;dc&gt; - drop(0) or retain(1) dc component      &lt;inner&gt; - inner cutoff frequency      &lt;outer&gt; - outer cutoff frequency&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\filter.c&nbsp;DESCRIPTION     Ideal_Band_Pass() performs  two-dimensional  ideal  bandpass     filtering in transform domain on input image.  All frequency     components that are in the band enclosed by the  circle  (or     1/4  circle if dc component is on the upper left-hand corner     of its transform plane) with radius  inner  and  the  circle     with  radius  outer  will be passed with no attenuation. All     frequencies outside the circular band (or 1/4 circular band)     are  completely attenuated. If dc equals 1, the dc component     will be retained, if dc equals 0, it will be dropped&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A filtered image&nbsp;HISTORY     History information recorded: None&nbsp;DIAGNOSTICS      The Ideal_Band_Pass filter will work for  both  real-valued     and   imaginary-valued  transform.  If  the  origin  of  the     transform is on the center of its frequency plane (shifted),     the  cutoff  frequencies can range from 1 to blocksize/2 and     the Ideal_Band_Pass function can  be  called  directly  with     correct parameters. If the origin of the transform is on the     upper   left-hand   corner   of   its    frequency    plane,     nonfft_xformfilter()  must be used to call Ideal_Band_Pass()     with filtertype=5.  The cutoff frequencies in this case  can     range  from  1  to  blocksize  since a block is treated as a     quarter of a regular block with its origin on the center. If     bpf_setup()  is  to  be  used to call Ideal_Band_Pass(), the     transform must be setup and recognized by bpf_setup(),  oth-     erwise   the   setup   program   automatically  assumes  the     transform\'s dc component is on the center (dcpos=1).&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the fft_transform on the      input image with the block size equal to 256 */      cvipImage=(Image *)fft_transform(cvipImage,256);      /* the following call performs the ideal band pass      filtering on the transformed image with the lower cut off      equal to 0 and the higher cut off equal to 64 */      cvipImage = (Image *)Ideal_Band_Pass(cvipImage,256,1,0,64);      /* the following call performs the inverse fft_transform in      the filtered image with the block size equal to 256 */      cvipImage = (Image *)ifft_transform(cvipImage,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Simon Low.&nbsp;\n\r\n\r&nbsp;","Ideal_Band_Pass","scr\\CVIP_C_functions/Ideal_Band_Pass.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:34:00Z  2004-10-20T00:03:00Z  1  429  2447  SIUE  20  5  2871  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Ideal_Band_Reject - perform ideal band reject filtering&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;&nbsp;     Image *Ideal_Band_Reject(Image *in_Image,int  block_size,int     dc,int inner,int  outer)&nbsp;      &lt;in_Image&gt; - pointer to an Image structure      &lt;block_size&gt; - desired block size      &lt;dc&gt; - drop(0) or retain(1) dc component      &lt;inner&gt; - inner cutoff frequency      &lt;outer&gt; - outer cutoff frequency&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\filter.c&nbsp;DESCRIPTION     Ideal_Band_Reject() performs two-dimensional  ideal  bandre-     ject filtering in transform domain on input image.  All fre-     quency components that are in the band enclosed by the  cir-     cle (or 1/4 circle if dc component is on the upper left-hand     corner of its transform plane) with  radius  inner  and  the     circle  with  radius outer will be filtered. All frequencies     outside the circular band (or 1/4 circular  band)  are  left     completely intact.  If dc equals 1, the dc component will be     retained, if dc equals 0, it will be dropped.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A filtered image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the fft_transform on the      input image with the block size equal to 256 */      cvipImage=(Image *)fft_transform(cvipImage,256);      /* the following call performs the ideal band reject      filtering  on the transformed image with the lower cut off      equal to 0 and the higher cut off equal to 64 */      cvipImage = (Image *)Ideal_Band_Reject(cvipImage,256,      1,0,64);      /* the following call performs the inverse fft_transform in      the filtered image with the block size equal to 256 */      cvipImage = (Image *)ifft_transform(cvipImage,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Simon Low.&nbsp;\n\r\n\r&nbsp;","Ideal_Band_Reject","scr\\CVIP_C_functions/Ideal_Band_Reject.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:35:00Z  2004-10-20T00:03:00Z  1  555  3169  SIUE  26  7  3717  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Ideal_High - perform ideal highpass filtering&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;&nbsp;     Image *Ideal_High(Image *in_Image,int block_size,int  dc,int     cutoff)&nbsp;      &lt;in_Image&gt; - pointer to an Image structure      &lt;block_size&gt; - desired block size      &lt;dc&gt; - drop(0) or retain(1) dc component      &lt;cutoff&gt; - cutoff frequency      .de Ss&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\filter.c&nbsp;DESCRIPTION     Ideal_High() performs two-dimensional ideal highpass filter-     ing  in transform domain on input image.  All frequency com-     ponents that are inside the circle (or 1/4 circle if dc com-     ponent  is  on  the  upper-left-hand corner of its transform     plane) of radius &quot;cutoff&quot; are filtered, while  all  frequen-     cies  outside the circle (or 1/4 circle) are left completely     intact. If dc equals 1, the dc component will  be  retained,     if it equals 0, it will be dropped.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A filtered image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER);      print_CVIP(&quot;0Enter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the fft_transform on the      input image with the block size equal to 256 */      cvipImage=(Image *)fft_transform(cvipImage,256);      /* the following call performs the ideal high pass      filtering on the transformed image with the cut off      frequency equal to 64 */      cvipImage = (Image *)Ideal_High(cvipImage,256,1,64);      /* the following call performs the inverse fft_transform      in the filtered image with the block size equal to 256 */      filtered image with the block size equal to 256 */      cvipImage = (Image *)ifft_transform(cvipImage,256);      print_CVIP(&quot;0Enter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;DIAGNOSTICS      The Ideal_High filter will work for  both  real-valued  and     imaginary-valued  transform.  If the origin of the transform     is on the center of its frequency plane (shifted), the  cut-     off  frequency  can  range  from  1  to  blocksize/2 and the     Ideal_High function can  be  called  directly  with  correct     parameters.  If  the origin of the transform is on the upper     left-hand     corner     of     its     frequency     plane,     nonfft_xformfilter()  must be used to call Ideal_High() with     filtertype=3.  The cutoff frequency in this case  can  range     from 1 to blocksize since a block is treated as a quarter of     a  regular  block  with  its  origin  on  the  center.    If     hpf_setup()   is  to  be  used  to  call  Ideal_High(),  the     transform must be setup and recognized by hpf_setup(),  oth-     erwise   the   setup   program   automatically  assumes  the     transform\'s dc component is on the center (dcpos=1).&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Simon Low.&nbsp;\n\r\n\r&nbsp;","Ideal_High","scr\\CVIP_C_functions/Ideal_High.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:35:00Z  2004-10-20T00:03:00Z  1  407  2321  SIUE  19  5  2723  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Ideal_Low - perform ideal lowpass filtering&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;&nbsp;     Image *Ideal_Low(Image *in_Image,int  block_size,int  dc,int     cutoff)&nbsp;      &lt;in_Image&gt; - pointer to an Image structure      &lt;block_size&gt; - desired block size      &lt;dc&gt; - drop(0) or retain(1) dc component      &lt;cutoff&gt; - cutoff frequency      .de Ss&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\filter.c&nbsp;DESCRIPTION     Ideal_Low() performs two-dimensional ideal lowpass filtering     in  transform  domain  on  input  image.  All frequency com-     ponents that are inside the circle (or 1/4 circle if dc com-     ponent  is  on  the  upper-left-hand corner of its transform     plane) of radius &quot;cutoff&quot; are passed  with  no  attenuation,     while all frequencies outside the circle (or 1/4 circle) are     completely attenuated. If dc equals 1, the dc component will     be  retained,  if  dc  equals  0,  the  dc component will be     dropped.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A filtered image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the fft_transform on the      input image with the block size equal to 256 */      cvipImage=(Image *)fft_transform(cvipImage,256);      /* the following call performs the ideal low pass      filtering  on the transformed image with the cut off      frequency equal to 64 */      cvipImage = (Image *)Ideal_Low(cvipImage,256,1,64);      /* the following call performs the inverse fft_transform      in the filtered image with the block size equal to 256 */      cvipImage = (Image *)ifft_transform(cvipImage,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Simon Low.&nbsp;\n\r\n\r&nbsp;","Ideal_Low","scr\\CVIP_C_functions/Ideal_Low.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:36:00Z  2004-10-20T00:03:00Z  1  403  2302  SIUE  19  5  2700  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     ifft_transform - performs an inverse fast Fourier transform&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPtools.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPtransform.h&quot;&nbsp;     Image *ifft_transform(Image *in_Image, int block_size)&nbsp;      &lt;in_Image&gt; - pointer to an Image structure      &lt;block_size&gt; - block size used for forward transform&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\TRANSFORMS\\inverse_fft.c&nbsp;DESCRIPTION     This function performs an inverse fast Fourier transform  on     an image that has previously had a forward FFT performed.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A transformed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;CVIPtransform.h&gt;      #include &lt;math.h&gt;      #include &lt;sys/file.h&gt;      #include &lt;float.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/uio.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs a fft_transform on the      input image with block size equal to 8 */      cvipImage = fft_transform(cvipImage, 8);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      /* the format is VIP because the output image type is      complex */      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,VIP,1);      free(outputfile);      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs a inverse fft_transform      on the input image with block size equal to 8 */      cvipImage = ifft_transform(cvipImage, 8);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     TRANSFORMS, fft_transform&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Simon Low.&nbsp;\n\r\n\r&nbsp;","ifft_transform","scr\\CVIP_C_functions/ifft_transform.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:37:00Z  2004-10-20T00:03:00Z  1  324  1853  SIUE  15  4  2173  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     igs_segment - improved gray-scale quantization&nbsp;SYNOPSIS     Image * igs_segment(Image * inputImage, int gray_level)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;gray_level&gt; - gray level of the output image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\igs_segment.c&nbsp;DESCRIPTION     This  function  remaps  (quantizes)  an  image  to  a  user-     specified  number  of gray levels to overcome the false con-     touring present in uniform quantization.  It  uses  improved     gray-scale (igs_segment) quantization introduced on page 318     of  the   following   book:    Digital   Image   Processing,     R.C.Gonzalez &amp; R.Woods, Addison-Wesley, 1992.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Upon successful completion, returns a non-NULL pointer; oth-     erwise, returns NULL.&nbsp;HISTORY     History information recorded: None&nbsp;DIAGNOSTICS     If the input image is not a  CVIP_BYTE  image,  it  will  be     remapped   to   CVIP_BYTE   before  processing.  It  can  be     multi_band and assumed to be real only.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call remaps the desired number of gray      levels to 2 */      cvipImage = (Image *)igs_segment(cvipImage,2);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO    SEGMENTATION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","igs_segment","scr\\CVIP_C_functions/igs_segment.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:38:00Z  2004-10-20T00:03:00Z  1  151  862  SIUE  7  2  1011  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     image_sharp - sharpens an image&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;image_enhance.h&quot;&nbsp;     void image_sharp( Image *inputImage)&nbsp;      &lt;inputImage&gt; - pointer to an Image structure&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\img_sharp.c&nbsp;DESCRIPTION     This function uses the Roberts gradient algorithm to enhance     edges in an image. For each pixel in the image, its gradient     is calculated as the difference in gray levels between adja-     cent pixels, and is added to the original pixel value. Since     the gradient assumes large values for prominent edges in the     image  and  small  values in regions that are fairly smooth,     the original pixel value is added to get a constrasted sharp     image.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     A pointer to the sharpened image&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh  and  Srinivas     Madiraju.&nbsp;\n\r\n\r&nbsp;","image_sharp","scr\\CVIP_C_functions/image_sharp.htm","   Hari  Normal  jhansi  33  26  2004-06-05T00:17:00Z  2010-01-06T21:50:00Z  1  406  2320  SIUE  19  5  2721  11.9999    120  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                             NAME     Improved_mmse_filter – Improved Adaptive Minimum Mean Squared Error Filter&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPimage.h&quot;&nbsp;     Image * improved_mmse_filter(Image * inputImage, float threshval, int kernel_size, float noise_var)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;threshval&gt;  - threshold for the noise to local variance ratio       &lt;noise_var&gt; - noise variance of input image      &lt;kernel_size&gt; - initial max window size (an odd number)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\improved_mmse_filter.c&nbsp;DESCRIPTION     The improved_mmse_filter makes use of the local variance to determine     if  a mean filter is to be applied to the local region of an     image.  It works best for short tail additive type noise. If the ratio     of noise variance to the local variance is less than the threshval then     it decreases the kernel size by 2 and gain performs the whole operation      till the ratio of noise variance to the local variance is greater than      the threshval&nbsp;     The improved adaptive MMSE filter is based on the following equation:&nbsp;                      (sigma_n)^2  /                  \\     MMSE = d(r,c) -  ------------ | d(r,c) - ml(r,c) |                      (sigma_l)^2  \\                  /&nbsp;     where ml is the local mean, sigma_n is the  noise  variance,     and sigma_l is the local variance.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs an improved adaptive mean squared      error filter operation with the kernel size equal to 3, threshval      equal to 0.6 and the noise variance equal to 100 */      cvipImage = improved_mmse_filter(cvipImage,0.6,3,100.0);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;RETURN VALUES     Pointer to the processed image&nbsp;BUGS     none&nbsp;SEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 2010, SIUE - by Scott Umbaugh and Hari Krishna Akkineni.&nbsp;\n\r\n\r&nbsp;","improved_mmse_filter","scr\\CVIP_C_functions/improved_mmse_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:46:00Z  2004-10-20T00:03:00Z  1  412  2354  SIUE  19  5  2761  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     inverse_xformfilter - performs inverse filtering&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtransform.h&quot;      #include &quot;CVIPxformfilter.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIParithlogic.h&quot;&nbsp;     Image *inverse_xformfilter(Image  *numP,  Image  *denP,  int     choice, float cutoff)&nbsp;      &lt;numP&gt; - pointer to the numerator, the degraded image      &lt;denP&gt; - pointer to the  denominator,  the  inverse  filter     (PSF)      &lt;choice&gt; - sets the maximum gain using the DC  value  as  a     baseline      &lt;cutoff&gt; - cutoff frequency&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\restore_xformfilter.c&nbsp;DESCRIPTION     This function performs an inverse filter, a frequency domain     filter defined:                                     G(u,v)                            F(u,v) = ------                                     H(u,v)     where F(u,v) is the Fourier transform of the restored image,     G(u,v)  is  the Fourier transform of the degraded image, and     H(u,v) is the Fourier transform of the degradation function.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A filtered image&nbsp;HISTORY     History information recorded:&nbsp;       parameter #1 = filter cutoff.       parameter #2 = method 1: F(u,v)=G(u,v) when H(u,v)=0                      method 2: F(u,v)=0 when H(u,v)=0&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage,*cvipImage1;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER,&quot;default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call creates a gaussian mask of size      3*3 */      cvipImage1 = (Image *)h_image(3,3,3);      /* the following call performs the inverse filter on the      input image with the gaussian mask and the cutoff      frequency equal to 32 (choice=1)*/      cvipImage=(Image *)inverse_xformfilter(cvipImage,      cvipImage1,1,32.0);      cvipImage=(Image *)ifft_transform(cvipImage,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh, Arve  Kjoelen     and Greg Hance.&nbsp;\n\r\n\r&nbsp;","inverse_xformfilter","scr\\CVIP_C_functions/inverse_xformfilter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:47:00Z  2004-10-20T00:04:00Z  1  318  1815  SIUE  15  4  2129  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     irregular - calculates irregularity ratio&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;&nbsp;     double irregular(Image * labeledImage, int r, int c)&nbsp;      &lt;labeledImage&gt; -  pointer to a labeled image      &lt;r&gt; - row coordinate of a point on a labeled image      &lt;c&gt; - column coordinate of a point on a labeled image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\binary_feature.c&nbsp;DESCRIPTION     This function calculates the irregularity ratio of an object     of interest on the labeled image. The formula used is:&nbsp;             irregularity ratio = (perimeter^2)/4*PI*area&nbsp;     where area is area of the binary object,  and  perimeter  is     the length of outer edge of the object.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A value of type double: irregularity ratio&nbsp;HISTORY     History information recorded: None      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;      #include &quot;CVIPfeatures.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;      void main() {         Image *inputImage, *labeledImage;         IMAGE_FORMAT format;         char *inputfile, *outputfile;         int rows, cols, r, c;         double result;&nbsp;         setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;         print_CVIP(&quot;\\nEnter the Input File Name:  &quot;);         inputfile = (char *) getString_CVIP();         inputImage = read_Image(inputfile, 1);         view_Image(inputImage,inputfile);         labeledImage = label(inputImage);&nbsp;         rows = getNoOfRows_Image(labeledImage);         cols = getNoOfCols_Image(labeledImage);&nbsp;         print_CVIP(&quot;\\nEnter the row coordinate of any pixel         on the labled image: &quot;);         r = getInt_CVIP(10, 0, rows);         print_CVIP(&quot;Enter the col coordinate of any pixel on         the labled image: &quot;);         c = getInt_CVIP(10, 0, cols);&nbsp;         result = irregular(labeledImage, r, c);         print_CVIP(&quot;\\nThe  irregularity ratio of the object         = %f\\n&quot;, result );&nbsp;         free(inputfile);       }&nbsp;SEE ALSO     FEATURE library, area, perimeter&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","irregular","scr\\CVIP_C_functions/irregular.htm","   ACADEMIC COMPUTING  Normal  P!Nk  22  34  2009-12-28T20:15:00Z  2009-12-28T20:53:00Z  1  247  1412  SIUE  11  3  1656  12.00    120  Clean  Clean  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                              NAME      jp2_compress, jp2_decompress - Joint  Photographic  Experts     Group(JPEG2000) image compression scheme&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPjpeg2000.h&quot;             int jp2_compress(Image *cvipImage, char *filename, int rate,     int quality, int numberoflayers, int blocksize)&nbsp;     &lt;rate&gt; -    Defines the compression ratio to be achieved.     Each value is a factor of compression, thus, 20 means 20 ti-     mes compressed.&nbsp;     &lt;quality&gt; -  Defines the quality level to be achieved during     the compression. &nbsp;     &lt;numberoflayers&gt;  -   Defines the number of resolution or     the number of decomposition for the discrete wavelet transf-     orm (DWT). &nbsp;     &lt;blocksize&gt; -     Defines the size of the code-block. The m-     mximum authorized value is 64x64.&nbsp;     Image   *jp2_decompress(char    *filename);&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\CONVERSION\\jp2_encode.c     $CVIPtoolsHOME\\CVIPC\\CONVERSION\\jp2_decode.c&nbsp;DESCRIPTIONJPEG2000 is a wavelet-based image compression standard andcoding system. It was created by the Joint Photographic Exp-ert Group committee in the year 2000 with the intention ofsupersending their original discrete cosine transform-basedJPEG standard. JPEG2000 can achieve both lossy and loselessimage compression.TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     jp2_compress: 0 on success, -1 on failure     jp2_decompress:  an   uncompressed   image   pointer   on     success, a NULL pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;BUGS     None.&nbsp;SEE ALSO     COMPRESSION library&nbsp;AUTHOR     Copyright (C) 2010 SIUE - by Scott Umbaugh, Serkan Kefel.&nbsp;\n\r\n\r&nbsp;","jp2_compress,jp2_decompress","scr\\CVIP_C_functions/jp2_compress, jp2_decompress.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:48:00Z  2004-10-20T00:04:00Z  1  948  5408  SIUE  45  12  6344  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME      jpg_compress, jpg_decompress - Joint  Photographic  Experts     Group(JPEG) image compression scheme&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;jinclude.h&quot;      #include &quot;jversion.h&quot;&nbsp;     int jpg_compress(Image *cvipImage, char *filename, int qual-     ity,  CVIP_BOOLEAN  grayscale,  CVIP_BOOLEAN  optimize,  int     smooth, CVIP_BOOLEAN verbose, char *qtablesFile)&nbsp;     &lt;quality&gt; -    Scale quantization  tables  to  adjust  image     quality.  Quality is 0 (worst) to 100 (best); default is 75.     (See below for more info.)&nbsp;     &lt;grayscale&gt; -  Create monochrome JPEG file from color input.     Be  sure to use this switch when compressing a grayscale GIF     file, because cjpeg isn\'t bright enough to notice whether  a     GIF  file  uses  only shades of gray.  By saying -grayscale,     you\'ll get a smaller JPEG file that takes less time to  pro-     cess.&nbsp;     &lt;optimize&gt;  -   Perform  optimization  of  entropy  encoding     parameters.  Without  this,  default encoding parameters are     used.  -optimize  usually  makes  the  JPEG  file  a  little     smaller,  but cjpeg runs somewhat slower and needs much more     memory.  Image quality and speed of decompression are  unaf-     fected by -optimize.&nbsp;     &lt;smooth&gt; -     Smooth the input image to eliminate dithering     noise.  N,  ranging from 1 to 100, indicates the strength of     smoothing.  0 (the default) means no smoothing.&nbsp;     &lt;verbose&gt; -    Enable debug printout.  More -v\'s  give  more     printout. Also, version information is printed at startup.&nbsp;     &lt;qtables file&gt; -     Use the quantization  tables  given  in     the  specified  file.  The  file  should contain one to four     tables (64 values each) as plain text.  Comments preceded by     \'#\'  may be included in the file.  The tables are implicitly     numbered 0,1,etc.  If -quality  N  is  also  specified,  the     values  in  the  file are scaled accordingto cjpeg\'s quality     scaling curve.&nbsp;     Image   *jpg_decompress(char    *filename,    int    colors,     CVIP_BOOLEAN     blocksmooth,     CVIP_BOOLEAN    grayscale,     CVIP_BOOLEAN nodither, CVIP_BOOLEAN verbose);&nbsp;     &lt;colors&gt; -     Reduce image  to  at  most  N  colors.   This     reduces  the  number  of colors used in the output image, so     that it can be displayed on a colormapped display or  stored     in   a colormapped file format.  For example, if you have an     8-bit display, you\'d need to reduce to 256  or  fewercolors.     (-colors is the recommended name, -quantize is provided only     for backwards compatibility.)&nbsp;     &lt;blocksmooth&gt; -Perform cross-block smoothing.  This is slow,     quite  memory-intensive, and only seems to improve the image     at very low quality settings (-quality 10 to 20 or  so).  At     normal quality settings it may make things worse.&nbsp;     &lt;grayscale&gt; -  Force gray-scale output even if JPEG file  is     color. Useful for viewing on monochrome displays.&nbsp;     &lt;nodither&gt; -   Do not use dithering in  color  quantization.     By  default, Floyd-Steinberg dithering is applied when quan-     tizing colors, but on some images dithering  may  result  in     objectionable  &quot;graininess&quot;.   If that happens, you can turn     off dithering with -nodither. -nodither  is  ignored  unless     you also say -colors N.&nbsp;     &lt;verbose&gt; -    Enable debug printout.  More -v\'s  give  more     printout. Also, version information is printed at startup.&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\jpeg.c&nbsp;DESCRIPTION     JPEG (pronounced &quot;jay-peg&quot;) is a standardized image compres-     sion  mechanism.  JPEG stands for Joint Photographic Experts     Group, the original name of the  committee  that  wrote  the     standard. JPEG is designed for compressing either full-color     or gray-scale images of natural, real-world scenes. JPEG  is     &quot;lossy,&quot; meaning that the decompressed image isn\'t quite the     same as the one  you  started  with.  JPEG  is  designed  to     exploit known limitations of the human eye, notably the fact     that small color changes are perceived less accurately  than     small  changes  in  brightness. A useful property of JPEG is     that the degree of lossiness  can  be  varied  by  adjusting     compression parameters.  This means that the image maker can     trade off file size against output image quality.&nbsp;     The function code is based on BETA TEST  release  6a  of  7-     Feb-96, the Independent JPEG Groups free JPEG software.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     jpg_compress: 0 on success, -1 on failure     jpg_decompression:  an   uncompressed   image   pointer   on     success,a NULL pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPcompress.h&quot;&nbsp;      void main() {        Image *cvipImage, *outImage;        IMAGE_FORMAT format;        char *inputfile, *outputfile;        int  returnVal;&nbsp;        setDisplay_Image(&quot;RamViewer&quot;, &quot;Default&quot;);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);        inputfile = getString_CVIP();&nbsp;        cvipImage = read_Image(inputfile, 1);        view_Image(cvipImage, inputfile);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the Compressed File Name:&quot;);        outputfile = getString_CVIP();&nbsp;        returnVal  =  jpg_compress(cvipImage,   outputfile,   75,     CVIP_NO, CVIP_NO, 0, CVIP_NO, NULL);        if (returnVal&lt;0) {            error_CVIP(&quot;jpg_compress&quot;, &quot;compression failed&quot;);            exit(1);        }&nbsp;        outImage  =  jpg_decompress(outputfile,   256,   CVIP_NO,     CVIP_NO, CVIP_YES, CVIP_YES);&nbsp;        if ((cvipImage)==NULL){            error_CVIP(&quot;jpg_decompress&quot;, &quot;decompression failed&quot;);            exit(1);        }        else            view_Image(outImage, outputfile);&nbsp;        free(inputfile);        free(outputfile);      }&nbsp;BUGS     jpg_compress: to create  monochrome  JPEG  file  from  color     input  by  set  input  argument  grayscale=CVIP_YES does not     work; jpg_decompress: to force  gray-scale  output  even  if     JPEG  file is color by set input argument grayscale=CVIP_YES     does not work;&nbsp;SEE ALSO     COMPRESSION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh, Kui Cai.&nbsp;\n\r\n\r&nbsp;","jpg_compress,jpg_decompress","scr\\CVIP_C_functions/jpg_compress, jpg_decompress.htm","   ACADEMIC COMPUTING  Normal  akharba  13  7  2005-07-02T19:03:00Z  2006-07-08T22:16:00Z  1  583  3324  SIUE  27  7  3900  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        k_nearest_neighbor – finds the kth nearest neighbor using a distance                              or similarity measure&nbsp;SYNOPSIS#include &quot;math.h&quot;#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;#include &quot;CVIPpattern.h&quot;     int k_nearest_neighbor(char *file_tt, char *file_tr, char *file_out, int option_normalize, int option_distance, int k, float s_min, float s_max, float r_softmax, int r_minkowski)      &lt;file_tt&gt; - pointer to a text file (test set)&lt;file_tr&gt; - pointer to a text file (training set)&lt;file_out&gt; - pointer to a text file (output)&lt;option_normalize&gt; - normalization method to be used&lt;option_distance&gt; - distance or similarity method to be used&lt;k&gt; - value of k to be used&lt;s_min&gt; - minimum value for the specified range (used with Min-max           normalization only; else use -1)&lt;s_max&gt; - maximum value for the specified range (used with Min-max           normalization only; else use -1)&lt;r_softmax&gt; - used with Softmax scaling only; else use -1&lt;r_minkowski&gt; - used with Minkowski generalized distance measure                only; else use -1&nbsp;&nbsp;&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\k_nearest_neighbor.c&nbsp;DESCRIPTION     This function finds the \'K\' (\'K\' is an integer) closest matches using      a given distance or similarity measure and then classifies the unknown      with the class that appears most often in this set of K samples.&nbsp;&nbsp;     Values to be used for:              option_normalize:                 0 – No Normalization        1 – Range-normalize        2 – Unit Vector normalization        3 – Standard Normal Density normalization        4 – Min-max normalization        5 – Softmax scaling              option_distance:                 1 – Euclidean Distance        2 – City block or Absolute value metric        3 – Maximum value metric        4 – Minkowski distance        5 – Vector inner product        6 – Tanimoto metric&nbsp;EXAMPLE#include       &quot;stdlib.h&quot;#include       &quot;CVIPtoolkit.h&quot;#include       &quot;CVIPpattern.h&quot;&nbsp;#define MAX_CASE 128&nbsp;void main(){        char    *test, *training, *output;        /*      Define all parameters, and initialize them to -1.               Change them afterwards, if they are required in the                application.        */        int     k=-1, r_minkowski=-1, option_normalize=-1,&nbsp;&nbsp;&nbsp; option_distance=0;        float   s_min=-1, s_max=-1, r_softmax=-1;&nbsp;        int     err_code;                /* Memory allocation */        test = malloc(MAX_CASE*sizeof(char));        training = malloc(MAX_CASE*sizeof(char));        output = malloc(MAX_CASE*sizeof(char));&nbsp;        /* Get the file names, and parameters. */        print_CVIP(&quot;\\t\\tPlease type in the file name for testing set: &quot;);        scanf(&quot;%s&quot;, test);        print_CVIP(&quot;\\t\\tPlease type in the file name for training set: &quot;);        scanf(&quot;%s&quot;, training);        print_CVIP(&quot;\\t\\tPlease type in the file name for output: &quot;);        scanf(&quot;%s&quot;, output);&nbsp;        /* Set required parameters */        k = 5;        option_normalize = 1;        option_distance = 0;&nbsp;        /* Call c function, and return the err_code */        err_code = k_nearest_neighbor(test, training, output, option_normalize, option_distance,         k, s_min, s_max, r_softmax, r_minkowski);                /* If err_code is not 0, print out the err_code */        if(err_code != 0)        {               printf(&quot;Error code: %d\\n&quot;, err_code);        }       &nbsp;        /* Free pointers */        free(test);        free(training);        free(output);}TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     An error code   Error Codes:&nbsp;1: The headers in the training and test files don\'t match 2: K is greater than the number of entries in the training setor K&lt;=0 3: s_min is greater than or equal to s_max 4: Data range is 0 and so the data can\'t be normalized 5: Divisor is 0 in Tanimoto similarity measure 7: Can\'t open, read or create file 9: Memory allocation error 10: Every entry in training set should have a class name 12: r in minkowski should be a positive integer 13: There is more than one header in the training or test feature file&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;\n\r\n\r&nbsp;","k_nearest_neighbor","scr\\CVIP_C_functions/k_nearest_neighbor.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:49:00Z  2004-10-20T00:04:00Z  1  187  1069  SIUE  8  2  1254  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     keyboard_to_mesh - create a mesh structure from the keyboard&nbsp;SYNOPSIS      #include &quot;mesh.h&quot;&nbsp;      struct mesh *keyboard_to_mesh();&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\warp.c&nbsp;DESCRIPTION     The keyboard_to_mesh() reads  data  from  the  keyboard  and     create  a  mesh  structure.  The  first  2  integers are the     numbers of columns and rows in the mesh.  And then the coor-     dinates  of each node in the mesh is input from the keyboard     node by node from the left to the right and row by row  from     the top to the bottom.&nbsp;TYPES AND CONSTANTS     struct mesh_node {          int x;          int y;     };&nbsp;     struct mesh {          int width;          int height;          struct mesh_node** nodes;     };&nbsp;     struct float_pair {          float x;          float y;     };&nbsp;RETURN VALUES     The keyboard_to_mesh() returns a pointer to the mesh  struc-     ture just created.&nbsp;EXAMPLE      #include &quot;mesh.h&quot;      #include &lt;CVIPio.h&gt;&nbsp;      void main()      {          struct mesh *inmesh;&nbsp;          inmesh = keyboard_to_mesh();      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     file_to_mesh(), mesh_to_file()&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Jianxin Tan.&nbsp;\n\r\n\r&nbsp;","keyboard_to_mesh","scr\\CVIP_C_functions/keyboard_to_mesh.htm","   Hari  Normal  jhansi  8  142  2009-12-03T01:25:00Z  2010-01-06T21:50:00Z  1  477  2722  SIUE  22  6  3193  11.9999    140  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                                                                  NAME     kirsch_filter - perform kirsch edge detection&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPfs.h&quot;      #include &lt;limits.h&gt;&nbsp;     Image *kirsch_filter(Image *inputImage,  Image *dirImage,         int mask_choice,  int mask_size, int keep_dc, int threshold)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;dirImage&gt; - pointer to direction Image      &lt;mask_choice&gt; - type of smoothing filter      &lt;mask_size&gt; - kernel size      &lt;keep_dc&gt; - 0 (no) or 1 (yes)      &lt;threshold&gt; - value for binary threshold&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\kirsch_filter.c&nbsp;DESCRIPTION     This function applies kirsch edge detection algorithm to     &lt;inputImage&gt;, and returns magnitude image, but for direction image,      a blank image is created using new_Image and is passed to      the function as direction image. After the function is     called direction image can be then viewed using view_Image     function. Data range of output direction image is -3pi/4 to +pi.     If a smoothing filter is desired as a preprocessing step,     set &lt;mask_choice&gt; to:                       1 = Gaussian blur                       2 = generic lowpass 1                       3 = generic lowpass 2                       4 = neighborhood average&nbsp;     For &lt;mask_size&gt;: Set mask_size to desired kernel size     For &lt;dirImage&gt; : direction image.&nbsp;     NOTE: for the parameters, mask_choice, mask_size, keepdc,      threshold, use the value -1 for any parameter not needed. &nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A kirsch edge-detected magnitude image and direction image.     &nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPfs.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *inputImage, *dirImage;      Image *outImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile,*outputfile1;              print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      inputImage = read_Image(inputfile, 1);      view_Image(inputImage, inputfile);            free(inputfile);&nbsp;\n\r\n\r      dirImage =new_Image(inputImage-&gt;image_format, \n\r\n\r      inputImage-&gt;color_space,inputImage-&gt;bands, getNoOfRows_Image(inputImage), \n\r\n\r      getNoOfCols_Image(inputImage),CVIP_FLOAT, REAL);      \n\r\n\r      outImage=kirsch_filter(inputImage,dirImage, -1, -1, -1, -1);            print_CVIP(&quot;\\n\\t\\tEnter the Output File Name of magnitude Image:  &quot;);      outputfile = getString_CVIP();      print_CVIP(“\\n\\t\\tEnter the Output File Name of direction Image: “);      outputfile1 = getString_CVIP();      view_Image(outImage,outputfile);      view_Image(dirImage, outputfile1);      delete_Image(outImage);      delete_Image(dirImage);      delete_Image(inputImage);      free(outputfile);      free(outputfile1);      }&nbsp;SEEALSO    SPATIALFILTER library      &nbsp;AUTHOR     Copyright (C) 2010, SIUE - by Scott Umbaugh, and Hari Krishna Akkineni. &nbsp;\n\r\n\r&nbsp;\n\r\n\r&nbsp;","kirsch_filter","scr\\CVIP_C_functions/kirsch_filter.htm","   Jhansi  Normal  jhansi  19  17  2004-06-04T21:33:00Z  2010-01-06T21:51:00Z  1  304  1739  SIUE  14  4  2039  11.9999    BestFit  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                             NAME     kuwahara_filter – an edge preserving filter.&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPmap.h&gt;      #include &lt;float.h&gt;      &nbsp;     Image *kuwahara_filter(Image *inputImage, int mask_size)     &lt;inputImage&gt; - pointer to Image structure.     &lt;mask_size&gt; - size of the filtering window (e.g.,3-&gt;3x3).&nbsp;&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\kuwahara_filter.c&nbsp;DESCRIPTION     Kuwahara Filter works by partitioning the N x N filter window      into four regions. In each of the four regions, the mean and     variance are measured. The center pixel value of the filter     window is replaced with the mean value of the region that      has the minimum variance.   &nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to the processed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE       #include &lt;CVIPtoolkit.h&gt;       #include &lt;CVIPimage.h&gt;       #include &lt;CVIPdef.h&gt;       #include &lt;CVIPspfltr.h&gt;       #include &lt;CVIPmap.h&gt;       #include &lt;CVIPconvert.h&gt;       #include &lt;CVIPview.h&gt;&nbsp;       void main()       {       Image *cvipImage;       IMAGE_FORMAT format;       char *inputfile,*outputfile;&nbsp;       setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;       print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);       inputfile =(char *) getString_CVIP();       format = getFormat_CVIP(inputfile);       cvipImage = read_Image(inputfile, 1);       view_Image(cvipImage, inputfile);       free(inputfile);       /* the following call performs the kuwahara filter       operation in every 3 x 3 window */       cvipImage = kuwahara_filter(cvipImage,3);       print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);       outputfile = getString_CVIP();       view_Image(cvipImage,outputfile);       write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);       free(outputfile);      }&nbsp;&nbsp;SEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 2010, SIUE - by Scott Umbaugh and Jhansi Lakshmi Akkineni.&nbsp;\n\r\n\r&nbsp;","kuwahara_filter","scr\\CVIP_C_functions/kuwahara_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:51:00Z  2004-10-20T00:04:00Z  1  141  806  SIUE  6  1  946  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Lab_inv_xform - L*a*b* inverse transform&nbsp;SYNOPSIS     void Lab_inv_xform(float **cvecP, unsigned long vdim,  float     Xo, float Yo, float Zo)&nbsp;      &lt;cvecP&gt; - pointer to an array of normalized band vectors      &lt;vdim&gt; - dimension of each vector (number of pixels)      &lt;Xo&gt; - reference white for red      &lt;Yo&gt; - reference white for green      &lt;Zo&gt; - reference white for blue&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COLOR\\cxform.c&nbsp;DESCRIPTION     This function  performs  LAB  to  RGB  color  transformation     according to the following equations:&nbsp;      For X(r): X = pow(((a / 500) + (L + 16)/116), 3) * Xo      For Y(g): Y = pow(((L + 16)/116), 3) * Yo      For Z(b): Z = pow(((L + 16)/116 - (b / 200)), 3) * Zo&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     None&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     COLOR library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Wenxng Li.&nbsp;\n\r\n\r&nbsp;","Lab_inv_xform","scr\\CVIP_C_functions/Lab_inv_xform.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:50:00Z  2004-10-20T00:04:00Z  1  192  1099  SIUE  9  2  1289  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     label - labels objects&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPobject.h&quot;&nbsp;     Image * label( const Image *imageP )&nbsp;      &lt;imageP&gt; - pointer to an Image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\label.c&nbsp;DESCRIPTION     This function calls the function label_Objects (from  libob-     ject).&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A labeled image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPobject.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;&nbsp;      void main() {         Image *inputImage, *labeledImage;         IMAGE_FORMAT format;         char *inputfile, *outputfile;         int rows, cols;         long lArea;&nbsp;         setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;         print_CVIP(&quot;0nter the Input File Name:  &quot;);         inputfile = (char *) getString_CVIP();         inputImage = read_Image(inputfile, format, TRUE);         view_Image(inputImage,inputfile);&nbsp;         labeledImage = label(inputImage);&nbsp;         free(inputfile);       }&nbsp;SEE ALSO     FEATURE library, Object library, setUpLabel_Objects&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh,  Greg  Hance,     Kun Luo, and Wenxing Li.&nbsp;\n\r\n\r&nbsp;","label","scr\\CVIP_C_functions/label.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  4  2004-06-04T23:51:00Z  2004-10-20T00:05:00Z  1  481  2744  SIUE  22  6  3219  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     least_squares - performs least_squares restoration filtering&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPxformfilter.h&quot;&nbsp;     Image  *least_squares(Image  *degr,  Image  *degr_fn,  Image     *snr_approx, float gamma, int choice, int cutoff)&nbsp;      &lt;degr&gt; - pointer to the degraded image      &lt;degr_fn&gt; - pointer to the degradation function      &lt;snr_approx&gt; - pointer  to  smoothness  criterion  function     image, P(u,v)      &lt;gamma&gt; - gamma in least_squares equation.      &lt;choice&gt; - sets the maximum gain using the DC  value  as  a     baseline      &lt;cutoff&gt; - cutoff frequency&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\restore_xformfilter.c&nbsp;DESCRIPTION     This function performs an inverse filter, a frequency domain     filter defined:                                            G(u,v)               F(u,v) = --------------------------------                                        2                 H(u,v) + gamma*(Pfn)&nbsp;     where F(u,v) is the Fourier transform of the restored image,     G(u,v)  is  the Fourier transform of the degraded image, and     H(u,v) is the Fourier transform of the degradation function.     Pfn is an approximation of the noise-to-power ratio.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to the restored image&nbsp;HISTORY     History information recorded:&nbsp;       parameter #1 = gamma&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;CVIPxformfilter.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage,*cvipImage1;      Image *cvipImage2;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      char *inputfile1;&nbsp;      (void) setDisplay_Image(VIEWER,&quot;default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the File Name of the      degraded image:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call creates a gaussian mask of size      3  * 3 */      cvipImage1 = (Image *)h_image(3,3,3);      print_CVIP(&quot;\\n\\t\\tEnter the File Name of the smooth      constraint image:  &quot;);      inputfile1 =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile1);      cvipImage2 = read_Image(inputfile1,1);      view_Image(cvipImage2, inputfile1);      free(inputfile1);      /* the following call performs the least squares filter      on the input image with the gaussian mask,gamma equal      to .5 and the cut off frequency equal to 32  */      cvipImage2=(Image *)least_squares(cvipImage,cvipImage1,      cvipImage2,.5,1,32);      cvipImage=(Image *)ifft_transform(cvipImage2,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Arve     Kjoelen.&nbsp;\n\r\n\r&nbsp;","least_squares","scr\\CVIP_C_functions/least_squares.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:53:00Z  2004-10-20T00:05:00Z  1  138  787  SIUE  6  1  924  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     linxform - linear transform on a set of band vectors&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPcolor.h&quot;&nbsp;      void  linxform(float  **cvecP,  unsigned  int   no_of_vecs,     unsigned int vdim, double **transmatrix)&nbsp;      &lt;cvecP&gt; - pointer to an array of band vectors      &lt;no_of_vecs&gt; - number of vectors      &lt;vdim&gt; - dimension of each vector (number of pixels)      &lt;transmatrix&gt; - transformation matrix&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COLOR\\cxform.c&nbsp;DESCRIPTION     Description: linearly  transforms  a  set  of  band  vectors     &lt;cvecP&gt;  through  a transformation matrix &lt;transmatrix&gt;. The     transformation  matrix  must  be   have   a   dimension   of     &lt;no_of_vecs&gt; by &lt;no_of_vecs&gt;.&nbsp;TYPES AND CONSTANTS     NONE&nbsp;RETURN VALUES     NONE&nbsp;HISTORY     History information recorded: None&nbsp;BUGS     NONE&nbsp;SEE ALSO     COLOR library, colorxform&nbsp;\n\r\n\r&nbsp;","linxform","scr\\CVIP_C_functions/linxform.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  5  1  2006-02-11T17:52:00Z  2006-02-14T06:25:00Z  1  284  1621  SIUE  13  3  1902  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     local_adaptive_zoom – Enlarges input image to its double sizeSYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPgeometry.h&quot;             Image *local_adaptive (Image *input_Image)&nbsp;      &lt;input&gt; - a pointer to an Image structure      PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\local_adaptive_zoom.c&nbsp;DESCRIPTIONTo the function this adaptive zoom, a pointer to  the  originalimage  is passed  as a parameter.  After performing the zoomingoperation, the pointer to the resultant image is returned to thecalling  function  to  display  the resultant image. It performsa nonlinear iterative procedure to zoom the image and hence it is implemented with limited computational resources.&nbsp;TYPES AND CONSTANTS  #define T1  200  #define T2  45RETURN VALUES      Pointer to the enlarged image&nbsp;HISTORY      History information copied from the old to the new      image&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPgeometry.h&gt;            void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /*the following call enlarges the image by factor of 2 */      cvipImage = local_adaptive_zoom(cvipImage);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     GEOMETRY library&nbsp;AUTHOR     Copyright (C) 1996, 2006 SIUE - by Scott E. Umbaugh and      Pradnya Deokar.&nbsp;\n\r\n\r&nbsp;\n\r\n\r&nbsp;","local_adaptive_zoom","scr\\CVIP_C_functions/local_adaptive_zoom.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:54:00Z  2004-10-20T00:05:00Z  1  327  1869  SIUE  15  4  2192  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     local_histeq - performs histogram equalization on  block-by-     block basis&nbsp;SYNOPSIS      #include &lt;stdio.h&gt;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPcolor.h&quot;      #include &quot;CVIPhisto.h&quot;&nbsp;     Image *local_histeq(Image *in, int size, int mb)&nbsp;      &lt;in&gt; - pointer to an Image structure      &lt;size&gt; - desired blocksize      &lt;mb&gt; - RGB band on which to calculate histogram (0,1,2)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\HISTGRAM\\local_histeq.c&nbsp;DESCRIPTION     This function performs histogram equalization on local areas     of  an  image  rather than on the image as a whole. The user     may specify the size of blocks to use. By  performing  local     rather  than  global histeq, detail can often be enhanced in     large uniform areas of an image.&nbsp;     The function will  remap  any  CVIP_INTEGER,  CVIP_FLOAT  or     CVIP_DOUBLE  image  into CVIP_SHORT. It operates directly on     images of type CVIP_SHORT and CVIP_BYTE.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A histogram-equalized image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &quot;CVIPcolor.h&quot;      #include &quot;CVIPhisto.h&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile, *outputfile;      int rows, cols;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);&nbsp;      cvipImage =(Image *) local_histeq(cvipImage,16,0);      cvipImage=remap_Image(cvipImage,CVIP_BYTE,0,255);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage, outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(inputfile);      free(outputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Arve Kjoelen.&nbsp;\n\r\n\r&nbsp;","local_histeq","scr\\CVIP_C_functions/local_histeq.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:54:00Z  2004-10-20T00:05:00Z  1  388  2214  SIUE  18  5  2597  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     log_ace_filter - an Adaptive Contrast Enhancement filter&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPspfltr.h&gt;&nbsp;     Image   *log_ace_filter(Image   *inputIMAGE,int   size,float     alpha,float beta)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;size&gt; - mask size (3,5,7,9,...)      &lt;alpha&gt; - local mean      &lt;beta&gt; - local gain factor&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\lee_filter.c&nbsp;DESCRIPTION     log_ACE\'s algorithms are able to enhance  the  contrast  and     dynamic  range of the image. log_ACE\'s algorithm uses linear     brightness stretching to modify  the  dynamic  range  of  an     image.  For  more  detail, see reference &quot;The Study of Loga-     rithmic Image Processing Model and Its Application to  Image     Enhancement&quot; by G.Deng, L.W. Cahill and G.R. Tobin.&nbsp;      output = k1*[ln(Ibar(r,c)-ln(m_lbar(r,c))] + k2*m_lbar(r,c)&nbsp;      where:      m_lbar = 1-m_l(r,c)/M, normalized complement of local mean      Ibar = 1 - I(r,c)/M, normalized complement of image      M = number of gray levels (255)      k1 = Local gain factor (multiplier), between 0 and 1      k2 = Local mean factor (multiplier), between 0 and 1      kernel size = size of local window&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to the processed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPspfltr.h&gt;&nbsp;      void main() {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs filter operation in a      kernel size of 5 with the local gain factor 0.5 multiplier      and local mean multiplier equal to 1.0 */      cvipImage = log_ace_filter(cvipImage, 5, 1.0, 0.5);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Lingwei     Sun.&nbsp;\n\r\n\r&nbsp;","log_ace_filter","scr\\CVIP_C_functions/log_ace_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:56:00Z  2004-10-20T00:05:00Z  1  257  1468  SIUE  12  3  1722  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     lum_average - creates a grayscale from a multiband image&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPcolor.h&quot;&nbsp;     Image * lum_average(Image * input_Image)&nbsp;      &lt;input_Image&gt; - pointer to an Image structure&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COLOR\\lum_average.c&nbsp;DESCRIPTION     Performs a luminance transform according to the formula                P = (band_1 + band_2 + ... + band_n)/n&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to a transformed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPcolor.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      /* The input image should be a COLOR one */      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call creates a gray scale from a      multiband image */      cvipImage=lum_average(cvipImage);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,VIP,1);      free(outputfile);      }&nbsp;SEE ALSO     COLOR library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","lum_average","scr\\CVIP_C_functions/lum_average.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:55:00Z  2004-10-20T00:05:00Z  1  294  1679  SIUE  13  3  1970  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     luminance_Image - creates a grayscale  image  from  a  color     image&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &lt;stdio.h&gt;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPluminance.h&quot;&nbsp;     Image *luminance_Image(Image *inIm)&nbsp;      &lt;inIm&gt; - a pointer to an Image structure&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COLOR\\luminance.c&nbsp;DESCRIPTION     Performs an  RGB to luminance  transform  according  to  the     formula                   P = 0.299 r + 0.587 g + 0.114 b.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to luminance transformed image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE           #include &lt;CVIPtoolkit.h&gt;           #include &lt;CVIPdef.h&gt;           #include &lt;CVIPimage.h&gt;           #include &lt;CVIPconvert.h&gt;           #include &lt;CVIPimage.h&gt;&nbsp;           #include &lt;math.h&gt;           #include &lt;stdio.h&gt;           #include &quot;CVIPluminance.h&quot;&nbsp;           void main()           {           Image *cvipImage;           IMAGE_FORMAT format;           char *inputfile, *outputfile;           setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;           print_CVIP(&quot;\\n\\n\\t\\tThis function requires&quot;);           print_CVIP(&quot;\\n\\t\\ta color image.\\n\\n&quot;);           print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);           inputfile =(char *) getString_CVIP();           format = getFormat_CVIP(inputfile);           cvipImage = read_Image(inputfile, 1);&nbsp;           print_CVIP(&quot;\\n&quot;);           cvipImage = (Image *)luminance_Image(cvipImage);           fflush(stdin);&nbsp;           print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);           outputfile = getString_CVIP();           write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);           display_Image(outputfile,format);           free(inputfile);           free(outputfile);           }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     COLOR library, lum_average&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Arve Kjoelen.&nbsp;\n\r\n\r&nbsp;","luminance_Image","scr\\CVIP_C_functions/luminance_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T23:57:00Z  2004-10-20T00:05:00Z  1  150  856  SIUE  7  2  1004  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Luv_inv_xform - L*u*v* inverse transform&nbsp;SYNOPSIS     void Luv_inv_xform(float **cvecP, unsigned long vdim,  float     Xo, float Yo, float Zo)&nbsp;      &lt;cvecP&gt; - pointer to an array of normalized band vectors      &lt;vdim&gt; - dimension of each vector (number of pixels)      &lt;Xo&gt; - reference white for red      &lt;Yo&gt; - reference white for green      &lt;Zo&gt; - reference white for blue&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COLOR\\cxform.c&nbsp;DESCRIPTION     This function  performs  LUV  to  RGB  color  transformation     according to the following equations:&nbsp;     For Y(g):            when L &gt; 8.0,  L  = 116*pow((Y/Yn), 1/3) - 16;            when L &lt;= 8.0, Lm = 903.3 * (Y/Yn).&nbsp;     For X(r) and Z(b):            X = (Y*(9*u\'))/(4*v\')            Z = (3*Y)/v\' - X/3 - 5*Y&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     None&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     COLOR library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","Luv_inv_xform","scr\\CVIP_C_functions/Luv_inv_xform.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  3  2004-06-04T23:58:00Z  2004-10-20T00:06:00Z  1  148  844  SIUE  7  1  991  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     mag_Matrix - calculate the magnitude of a matrix.&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPmatrix.h&quot;&nbsp;     Matrix *mag_Matrix(Matrix *in)&nbsp;      &lt;in&gt; - input Matrix;&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\MatrixAlgebra\\m_magnitude.c&nbsp;DESCRIPTION     This function calculates the magnitude of the passed  matrix     structure and returns the result in a new Matrix structure.&nbsp;TYPES AND CONSTANTS     See libmatrix.3&nbsp;RETURN VALUES     Pointer to matrix structure containing themagnitude  of  the     Matrix  at  each point.  This Matrix is REAL.  If the passed     Matrix is REAL, it is left untouched.  Otherwise, the return     matrix is of type CVIP_DOUBLE if the input Matrix is of type     CVIP_DOUBLE, and of type CVIP_FLOAT otherwise.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE&nbsp;BUGS     None at this time&nbsp;SEE ALSO     MatrixAlgebra library, square_mag_Matrix()&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Arve Kjoelen&nbsp;\n\r\n\r&nbsp;","mag_Matrix","scr\\CVIP_C_functions/mag_Matrix.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-04T23:58:00Z  2004-10-20T00:06:00Z  1  174  995  SIUE  8  2  1167  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     make_histogram - creates an image from a histogram&nbsp;SYNOPSIS     #include &quot;histogram.h&quot;&nbsp;     Image   *make_histogram(float   **histogram,    IMAGE_FORMAT     image_format, COLOR_FORMAT color_format);      &lt;histogram&gt; - a 2-D float array of the histogram data;      &lt;image_format&gt; - the Image format of the resulting image;      &lt;color_format&gt; - the Color format of the resulting image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\HISTOGRAM\\histogram.cDESCRIPTION     make_histogram generates an image of a histogram.  The image     type   and  color  space  is  defined  by  image_format  and     image_format.  The Image* returned is that of  a  histogram,     which  is  passwd  to  the  function  in  a variable of type     float**.&nbsp;RETURN VALUES     make_histogram returns a valid Image pointer on success, and     returns a NULL pointer on failure.&nbsp;BUGS     May fail with multi-band gif images&nbsp;SEE ALSO     define_histogram,    get_histogram,     get_histogram_Image,     hist_spec, histogram_show, histogram_spec, showMax_histogram&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE - by Scott E.  Umbaugh,  David     A. Lyons and Yansheng Wei.&nbsp;\n\r\n\r&nbsp;","make_histogram","scr\\CVIP_C_functions/make_histogram.htm","   Jhansi  Normal  jhansi  23  31  2004-07-03T22:35:00Z  2010-01-06T21:51:00Z  1  140  802  SIUE  6  1  941  11.9999    BestFit  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                             NAME     marr_hildreth_filter – performs a Marr Hildreth edge detection on the image&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPspfltr.h&gt;&nbsp;     Image * marr_hildreth_filter (Image* inputImage, float sigma)&nbsp;      &lt;inputImage&gt; - pointer to the input Image structure      &lt;sigma&gt; - Sigma value&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\ marr_hildreth_filter.c&nbsp;DESCRIPTION\n\r\n\rMarr-Hildreth Filter works by performing three steps:\n\r\n\r1. Convolve theimage with a Gaussian smoothing filter\n\r\n\r2. Convolve theimage with a Laplacian mask\n\r\n\r3. Find the zerocrossings of the image from Step 2.TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Returns the edge detected image&nbsp;HISTORY     History information recorded: NoneSEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 2010, SIUE - by Scott Umbaugh and Jhansi Lakshmi Akkineni.\n\r\n\r&nbsp;","marr_hildreth_filter","scr\\CVIP_C_functions/marr_hildreth_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T00:00:00Z  2004-10-20T00:06:00Z  1  329  1876  SIUE  15  4  2201  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     maximum_filter - typically applied to  an  image  to  remove     negative outlier noise.&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;float.h&gt;&nbsp;     Image *maximum_filter(Image *imageP, int mask_size)           &lt;imageP&gt; - pointer to Image structure.           &lt;mask_size&gt; - NxN is the size of the filtering window.&nbsp;&nbsp;OPTIONS     None.&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\spatial_filter.cDESCRIPTION     Returns the maximum value of the set of pixels contained  in     the   N  x  N filter window. Size of filter should be an odd     integer limited from &lt; 3 - 31 &gt;.&nbsp;TIPS     Works best on  images  containing  negative  outlier  noise.     This filter will brighten the appearance of the image.  Keep     mask size small to minimize blurring.&nbsp;DIAGNOSTICS     Returns a pointer to the modified Image  structure  on  suc-     cess.  Returns a NULL pointer if the input Image datatype is     not CVIP_BYTE and can\'t be cast to CVIP_FLOAT.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call replaces each pixel value      by the maximum pixel value in a 3 x 3 window */      cvipImage = maximum_filter(cvipImage,3);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;BUGS     None.&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE - by Scott E. Umbaugh and John     A Creighton.&nbsp;\n\r\n\r&nbsp;","maximum_filter","scr\\CVIP_C_functions/maximum_filter.htm","   ACADEMIC COMPUTING  Normal  akharba  13  4  2005-07-02T19:46:00Z  2006-07-08T22:24:00Z  1  271  1548  SIUE  12  3  1816  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        maximum_value_metric – calculates the maximum value metric value metric&nbsp;SYNOPSIS#include &quot;math.h&quot;     float maximum_value_metric(float *vector1, float *vector2, int n)      &lt;vector1&gt; - pointer to an input array&lt;vector2&gt; - pointer to an input array&lt;n&gt; - number of elements (features) in the array&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\maximum_value_metric.c&nbsp;DESCRIPTION     This function calculates the maximum value metric distance      measure from the elements of the two arrays. The formula      used for the calculation is given in chapter 6 of the      following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 3\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       float  *vector1;\n\r\n\r       float  *vector2;\n\r\n\r       float  result;\n\r\n\r       int           i;\n\r\n\r&nbsp;\n\r\n\r       vector1 = malloc(MAX_CASE*sizeof(float));\n\r\n\r       vector2 = malloc(MAX_CASE*sizeof(float));\n\r\n\r&nbsp;\n\r\n\r       /* Get the vectors. The items should beseparated by &quot;,&quot; */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector1: &quot;);\n\r\n\r       for(i=0;i&lt;MAX_CASE;i++)\n\r\n\r       {\n\r\n\r              scanf(&quot;%f,&quot;,&amp;vector1[i]);\n\r\n\r       }\n\r\n\r       \n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector1: &quot;);\n\r\n\r       for(i=0;i&lt;MAX_CASE;i++)\n\r\n\r       {\n\r\n\r              scanf(&quot;%f,&quot;,&amp;vector2[i]);\n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       result = maximum_value_metric (vector1,vector2, MAX_CASE);\n\r\n\r       \n\r\n\r       /* Print out the result */\n\r\n\r       printf(&quot;result=%f\\n&quot;,result);\n\r\n\r&nbsp;\n\r\n\r       /* Free the pointers */\n\r\n\r       free(vector1);\n\r\n\r       free(vector2);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A float number representing the maximum value metric distance measure&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","maximum_value_metric","scr\\CVIP_C_functions/maximum_value_metric.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  0  2004-06-05T00:00:00Z  2004-10-20T00:06:00Z  1  337  1923  SIUE  16  4  2256  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     mean_filter - filtering operation used on an image to remove     short tailed noise such as uniform and gaussian noises.&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;float.h&gt;&nbsp;     Image *mean_filter(Image *imageP, int mask_size)           &lt;imageP&gt; - pointer to Image structure.           &lt;mask_size&gt; - size of the filtering window (e.g.,  3-&gt;     3x3).&nbsp;&nbsp;OPTIONS     None.PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\spatial_filter.c&nbsp;DESCRIPTION     Returns the average value of the set of pixels contained  in     the N x N filter window.  The filter  size  should be an odd     integer limited from &lt; 3 - 31&gt;.&nbsp;TIPS     Works best on short-tailed noise like uniform  and  Gaussian     noise.  Keep the mask size small to minimize blurring.&nbsp;DIAGNOSTICS     Returns a pointer to the modified Image  structure  on  suc-     cess.  Returns a NULL pointer if the input Image datatype is     not CVIP_BYTE and can\'t be cast to CVIP_FLOAT.&nbsp;RETURN VALUES     Pointer to an image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the averaging      operation in every 3 x 3 window */      cvipImage = mean_filter(cvipImage,3);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;BUGS     None.&nbsp;AUTHOR     Copyright (C) 1992, 1996 SIUE - by Scott E. Umbaugh and John     A Creighton.&nbsp;\n\r\n\r&nbsp;","mean_filter","scr\\CVIP_C_functions/mean_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  0  2004-06-05T00:02:00Z  2004-10-20T00:06:00Z  1  191  1094  SIUE  9  2  1283  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     mean_test   -   function   used   to   set   criteria    for     split_and_merge routine&nbsp;SYNOPSIS      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;split_merge.h&quot;      #include &quot;CVIPtexture.h&quot;&nbsp;     static CVIP_BOOLEAN mean_test(Image  *srcImage,  QUAD  *qua-     dROI, void *paramP)&nbsp;      &lt;srcImage&gt; - pointer to Image structure      &lt;quadROI&gt; - pointer to QUAD structure      &lt;paramP&gt; - pointer to any other parameters needed                 (none in this case)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\split_merge.c&nbsp;DESCRIPTION     An  example  mean  test  module  to   be   used   with   the     split_merge_segment(...)   routine.  This test function will     return a value of CVIP_YES if the local mean of  the  region     pointed  to  by &lt;quadROI&gt; is greater than the global mean of     &lt;srcImage&gt;, and will return a value of CVIP_NO if the  local     mean is less than or equal to the global mean.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     CVIP_YES or CVIP_NO.&nbsp;EXAMPLE     see split_and_merge&nbsp;BUGS     None at this time&nbsp;SEE ALSO     SEGMENTATION library, split_and_merge, predicate_test&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Greg Hance.&nbsp;\n\r\n\r&nbsp;","mean_test","scr\\CVIP_C_functions/mean_test.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  3  2004-06-05T00:03:00Z  2004-10-20T00:06:00Z  1  363  2074  SIUE  17  4  2433  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     median_cut_segment  -  function  to  map   24-bits-per-pixel     images to 2-bits-per-pixel&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;median_cut.h&quot;&nbsp;     Image   *median_cut_segment(Image  *imgP,   int   newcolors,     CVIP_BOOLEAN is_bg, Color bg)&nbsp;      &lt;impP&gt; - pointer to Image structure      &lt;newcolors&gt; - desired number of colors      &lt;is_bg&gt; - is background color?      &lt;bg&gt; - background color&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\median_cut.cDESCRIPTION     This function is usually used in conjunction with the  Prin-     cipal Components Transform (PCT) in segmenting color images.     It performs data compression from 24  bits-per-pixel  to  an     average  of  2 bits-per-pixel. Median cut attempts to make a     histogram of the  original  image  without  clustering.  New     colormaps  are generated iteratively until at most 15 colors     have been chosen.  When is_bg is  CVIP_YES,  the  background     color  specified in &quot;bg&quot; is not considered in the median_cut     process.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     An Image pointer upon success; a NULL pointer upon failure&nbsp;EXAMPLE      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPcolor.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;median_cut.h&quot;&nbsp;      void main()      {      Image  *cvipImage;      IMAGE_FORMAT   format;      char  *inputfile, *outputfile;      unsigned newcolors;      Color bg = {0, 0, 0};&nbsp;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      print_CVIP(&quot;0lease enter the number of desired colors: &quot;);      newcolors = getUInt_CVIP(10, 2, 1000);      cvipImage   =   median_cut_segment(cvipImage,    newcolors,     CVIP_NO, bg);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage, outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(inputfile);      free(outputfile);      }&nbsp;BUGS     Sometimes the function does\'t  work  properly  when  the  bg     color is specified.&nbsp;SEE ALSO     SEGMENTATION library&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Greg Hance.&nbsp;\n\r\n\r&nbsp;","median_cut_segment","scr\\CVIP_C_functions/median_cut_segment.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  1  2004-06-05T00:12:00Z  2004-10-20T00:06:00Z  1  299  1708  SIUE  14  4  2003  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     median_filter - a fast median  filter  using  the  histogram     method.&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;stdio.h&gt;      #include &lt;math.h&gt;&nbsp;     Image *median_filter(Image *inputImage, int size)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;size&gt; - mask size (3,5,7,9,...)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\median_hist.c&nbsp;DESCRIPTION     The function median_filter uses a histogram method  to  per-     form  a fast median filter on an input image, using a square     mask of user-determined dimension.  The filter  operates  on     the  histogram  of the masked area, rather than on the image     directly.&nbsp;RETURN VALUES     The function returns an image that has been median filtered.&nbsp;HISTORY     History information recorded: filter window size&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;stdio.h&gt;      #include &lt;math.h&gt;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile, *outputfile;&nbsp;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      cvipImage = (Image *)median_filter(cvipImage, 3);      /* example size 3 */      fflush(stdin);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage, outputfile);      write_Image(cvipImage,   outputfile,CVIP_NO,CVIP_NO,format,     1);      free(inputfile);      free(outputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Frank Smith and Scott Umbaugh.&nbsp;\n\r\n\r&nbsp;","median_filter","scr\\CVIP_C_functions/median_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  5  2  2004-06-05T00:14:00Z  2004-10-20T00:07:00Z  1  221  1263  SIUE  10  2  1482  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     mesh_to_file - save a mesh structure to a file&nbsp;SYNOPSIS      #include &quot;mesh.h&quot;&nbsp;      void   mesh_to_file(struct   mesh    *mesh_matrix,    char*     mesh_file);&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\warp.c&nbsp;DESCRIPTION     The mesh_to_file() saves a mesh structure  to  a  file.  The     first  2  integers saved are the numbers of columns and rows     of the mesh.  And then the coordinates of each node  in  the     mesh  is  saved  node by node from the left to the right and     row by row from the top to the bottom.  The character string     &quot;mesh_file&quot; holds the mesh file name.&nbsp;TYPES AND CONSTANTS     struct mesh_node {          int x;          int y;     };&nbsp;     struct mesh {          int width;          int height;          struct mesh_node** nodes;     };&nbsp;     struct float_pair {          float x;          float y;     };&nbsp;RETURN VALUES     none&nbsp;EXAMPLE      #include &quot;mesh.h&quot;      #include &lt;CVIPio.h&gt;&nbsp;      void main()      {          char           *inputfile;          struct mesh    *inmesh;          inmesh = keyboard_to_mesh();   /*This is optional;                                    one way to create a mesh*/          print_CVIP(&quot;0Input the mesh file name: &quot;);          inputfile = getString_CVIP();          mesh_to_file(inmesh,inputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     file_to_mesh(), keyboard_to_mesh()&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Jianxin Tan.&nbsp;\n\r\n\r&nbsp;","mesh_to_file","scr\\CVIP_C_functions/mesh_to_file.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:15:00Z  2004-10-20T00:07:00Z  1  793  4526  SIUE  37  10  5309  10.3501                    MicrosoftInternetExplorer4 NAME     mesh_warping,    mesh_warping_ri,    mesh_warping_setup    -     mesh_warp an image, with regular or irregular input and out-     put mesh.&nbsp;SYNOPSIS      #include &quot;CVIPmesh.h&quot;&nbsp;      Image *mesh_warping(Image *inputImage,struct              mesh *inmesh,int method);      Image *mesh_warping_ri(Image *inputImage,struct              mesh *inmesh, int method, CVIP_BOOLEAN zero_out);&nbsp;      int mesh_warping_setup();&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\warp.c&nbsp;DESCRIPTION     The mesh_warping() performs: 1. a spatial transformation.        The function takes the usually (not necessarily)  irregu-     lar  input  mesh  structure and creates a regular mesh.  The     regular mesh consists of the same number of columns and same     number  of  rows as the input mesh, and all the cells of the     regular mesh are rectangulars.  The regular mesh covers  the     whole output image.        The function goes through the rectangular regions one  by     one.  For  each of the rectangular region, the function gets     the corresponding quadrilateral region in the  input  image.     The  4  corners  of the current rectangular region and the 4     corners  of  the  corresponding  quadrilateral  region   are     tiepoints.  The geometric distortion process within the qua-     drilateral regions is modeled by a pair  of  bilinear  equa-     tions:  r(x,y)  =  c1*x + c2*y + c3*x*y + c4 s(x,y) = c5*x +     c6*y + c7*x*y + c8        If (x,y) is a pixel in the output image, (r,s) is (x,y)\'s     corresponding   pixel  in  the  input  image.  Using  the  8     tiepoints, the equations can be solved  for  the  8  coeffi-     cients ci, i = 1,2, ...,8 for the current set of tiepoints.        Using the set of 8 coefficients, for each  (x,y)  in  the     current  rectangular  region,  the function can computes its     corresponding pixel (r,s) in the input image.  If both  &quot;r&quot;,     &quot;s&quot;  are integers, then (r,s)\'s gray value is given to (x,y)     in the output image.  If any one  of  &quot;r&quot;,  &quot;s&quot;  is  not  an     integer,  (x,y)\'s gray value is determined with a gray-level     interpolation method.&nbsp;     2. a gray-level interpolation:        The integer &quot;method&quot; specifies 1 of 3 gray value interpo-     lation methods:        1. nearest neighbor        2. bilinear        3. average of neighbors&nbsp;        The input mesh structure is pointed to by &quot;inmesh&quot;.&nbsp;     The mesh_warping_ri() is similar to the mesh_warping(),  but     the  mesh  for  the  output image can be a irregular one and     from this irregular mesh a regular mesh is generated for the     input  image.   The function finds out if each pixel is in a     certain quadilateral region in  the  output  image  or  not.     Spatial  transformations  and  gray-level interpolations are     performed between each quadrilateral region  in  the  output     image and its corresponding region in the input image.&nbsp;     In the output image, if one pixel can\'t find a corresponding     pixel  from the input image, zero_out determines whether the     output pixel will use zero or just copy the same  row/column     pixel from the input image.&nbsp;TYPES AND CONSTANTS     struct mesh_node {          int x;          int y;     };&nbsp;     struct mesh {          int width;          int height;          struct mesh_node** nodes;     };&nbsp;     struct float_pair {          float x;          float y;     };&nbsp;RETURN VALUES     The mesh_warping() and mesh_warping_ri() both create  a  new     image  and  return  a  pointer points to the new image.  The     mesh_warping_setup() returns 1 when succeeded and returns  0     when failed.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &quot;CVIPmesh.h&quot;&nbsp;      void main ()      {          Image     *inputImage, *outputImage;          IMAGE_FORMAT    format;          int       method,source;          char      *mesh_file,*outputfile, *inputfile;          struct mesh  *inmesh;&nbsp;          setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);          print_CVIP(&quot;The input image file, please: &quot;);          inputfile = getString_CVIP();          format = getFormat_CVIP(inputfile);          inputImage= (Image *)read_Image(inputfile,0);          view_Image(inputImage, outputfile);          print_CVIP(&quot;Gray value interpolation method: 0);          print_CVIP(&quot;1.Nearest neighbor 0);          print_CVIP(&quot;2.Bilinear interpolation0);          print_CVIP(&quot;3.Neighbor average0);          print_CVIP(&quot;0hoice&gt;&gt;&quot;);          method = getInt_CVIP(10, 1, 3);          print_CVIP(&quot;The mesh file name, please: &quot;);          mesh_file = getString_CVIP();          inmesh = file_to_mesh(mesh_file);          outputImage = mesh_warping(inputImage,inmesh,method);          print_CVIP(&quot;0Enter the Output File Name:  &quot;);          outputfile = getString_CVIP();          view_Image(outputImage, outputfile);          write_Image(outputImage, outputfile, CVIP_NO,  CVIP_NO,     format, 1);      }&nbsp;     /*The usage of  mesh_warping_ri()  is  similar  to  that  of     mesh_warping.*/&nbsp;BUGS     None at this time&nbsp;SEE ALSO     display_mesh, file_to_mesh, keyboard_to_mesh,  mesh_to_file,     print_mesh&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Jianxin Tan.&nbsp;\n\r\n\r&nbsp;","mesh_warping,mesh_warping_ri,mesh_warping_setup","scr\\CVIP_C_functions/mesh_warping,    mesh_warping_ri,    mesh_warping_setup.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T00:16:00Z  2004-10-20T00:07:00Z  1  354  2023  SIUE  16  4  2373  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     midpoint_filter - typically used to filter images containing     short tailed noise such as Gaussian and uniform noises.&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;float.h&gt;&nbsp;     Image *midpoint_filter(Image *imageP, int mask_size)           &lt;imageP&gt; - pointer to Image structure.           &lt;mask_size&gt; - size of the filtering window           (e.g., 3-&gt;3x3).&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\spatial_filter.c&nbsp;OPTIONS     None.&nbsp;DESCRIPTION     Returns the midpoint value of the set of pixels contained in     the   N x N filter window. The filter calculates the maximum     and minimum values in  the  window  and  returns  their  sum     divided  by 2.  Size of filter should be an odd integer lim-     ited from &lt; 3 - 31 &gt;.&nbsp;TIPS     Works best on images containing short tailed noise  such  as     uniform  and  Gaussian  noise.   Keep  filter  mask small to     minimize blurring.&nbsp;DIAGNOSTICS     Returns a pointer to the modified Image  structure  on  suc-     cess.  Returns a NULL pointer if the input Image datatype is     not CVIP_BYTE and can\'t be cast to CVIP_FLOAT.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call replaces each pixel value      by the average of the maximum and minimum in a      3 x 3 window */      cvipImage = midpoint_filter(cvipImage,3);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;BUGS     None.&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE - by Scott E. Umbaugh and John     A Creighton.&nbsp;\n\r\n\r&nbsp;","midpoint_filter","scr\\CVIP_C_functions/midpoint_filter.htm","   ACADEMIC COMPUTING  Normal  akharba  8  5  2005-07-02T21:09:00Z  2006-07-08T22:24:00Z  1  537  3061  SIUE  25  7  3591  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        min_max_normalization – normalizes a 2D matrix using min-max                                normalization method&nbsp;SYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;stdlib.h&quot;&nbsp;float **min_max_normalization(float **vector, int i, int j, float s_min, float s_max, int option, int *err_code)&nbsp;&lt;vector&gt; - 2D pointer to a matrix&lt;i&gt; - number of columns in the matrix      &lt;j&gt; - number of rows in the matrix&lt;s_min&gt; - minimum value for the specified range      &lt;s_max&gt; - maximum value for the specified range      &lt;option&gt; - 0 – to normalize the training set                 1 – to normalize the test set      &lt;err_code&gt; - pointer to the error code; use 0 for no error&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\min_max_normalization.c&nbsp;DESCRIPTION     This function normalizes a matrix using min-max normalization     method. The formula used for min-max normalization is given in      chapter 6 of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineno_of_col 2\n\r\n\r#defineno_of_row 3\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       float  **vector;\n\r\n\r       float  s_min=1,s_max=4;\n\r\n\r       int           i,j;\n\r\n\r       int           option= 0;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r&nbsp;\n\r\n\r       /* Memory allocation. The size of vectoris (no_of_row+2)*no_of_col */\n\r\n\r       vector =malloc((no_of_row+2)*sizeof(float *));\n\r\n\r&nbsp;\n\r\n\r       for(i=0;i&lt;(no_of_row+2);i++)\n\r\n\r       {\n\r\n\r              vector[i] =malloc(no_of_col*sizeof(float));           \n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Get the vectors. The items should beseparated by &quot;,&quot;. vector[0][0],vector[0][1],...vector[row][col] */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector: &quot;);\n\r\n\r       for(j=0;j&lt;no_of_row;j++)\n\r\n\r       {\n\r\n\r              for(i=0;i&lt;no_of_col;i++)\n\r\n\r              {\n\r\n\r                     scanf(&quot;%f,&quot;,&amp;vector[j][i]);\n\r\n\r              }\n\r\n\r              \n\r\n\r       }\n\r\n\r       \n\r\n\r       /* Call c function, and return thevector. option is 0, means the vector comes from training set */\n\r\n\r       vector = min_max_normalization(vector,no_of_col, no_of_row, s_min, s_max, option, err_code);\n\r\n\r&nbsp;\n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }\n\r\n\r       else\n\r\n\r       {\n\r\n\r              /* Print out the result */\n\r\n\r              for(j=0;j&lt;no_of_row+2;j++)\n\r\n\r              {\n\r\n\r                     for(i=0;i&lt;no_of_col;i++)\n\r\n\r                     {\n\r\n\r                           printf(&quot;%f&quot;, vector[j][i]);\n\r\n\r                     }\n\r\n\r                     printf(&quot;%s\\n&quot;,&quot;&quot;);\n\r\n\r              }\n\r\n\r       }      \n\r\n\r       /* The last two rows in the vector is fornormalize another vector. Typically, from test set. */\n\r\n\r&nbsp;\n\r\n\r       /* Get another vectors. The items shouldbe separated by &quot;,&quot;. vector[0][0],vector[0][1],...vector[row][col] */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in another vector: &quot;);\n\r\n\r       for(j=0;j&lt;no_of_row;j++)\n\r\n\r       {\n\r\n\r              for(i=0;i&lt;no_of_col;i++)\n\r\n\r              {\n\r\n\r                     scanf(&quot;%f,&quot;,&amp;vector[j][i]);\n\r\n\r              }\n\r\n\r              \n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       option = 1;\n\r\n\r       /* Call c function, and return thevector. option is 1, means the vector comes from test set */\n\r\n\r       vector = min_max_normalization(vector,no_of_col, no_of_row+2, s_min, s_max, option, err_code);\n\r\n\r&nbsp;\n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }\n\r\n\r       else\n\r\n\r       {\n\r\n\r              /* Print out the result */\n\r\n\r              for(j=0;j&lt;no_of_row+2;j++)\n\r\n\r              {\n\r\n\r                     for(i=0;i&lt;no_of_col;i++)\n\r\n\r                     {\n\r\n\r                           printf(&quot;%f&quot;, vector[j][i]);\n\r\n\r                     }\n\r\n\r                     printf(&quot;%s\\n&quot;,&quot;&quot;);\n\r\n\r              }\n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Free the pointers */\n\r\n\r       for(i=0;i&lt;(no_of_row+2);i++)\n\r\n\r       {\n\r\n\r              free(vector[i]);\n\r\n\r       }\n\r\n\r       free(vector);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A min-max normalized matrix pointer&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","min_max_normalization","scr\\CVIP_C_functions/min_max_normalization.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T00:16:00Z  2004-10-20T00:07:00Z  1  312  1780  SIUE  14  4  2088  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     minimum_filter - typically applied to  an  image  to  remove     positive outlier noise.&nbsp;SYNOPSIS      #include &lt;CVIPtoolk.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;float.h&gt;&nbsp;     Image *minimum_filter(Image *imageP, int mask_size)         &lt;imageP&gt; - pointer to an Image structure.         &lt;mask_size&gt; - size of the filtering  window  (e.g.,  3-&gt;     3x3).&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\spatial_filter.c&nbsp;OPTIONS     None.&nbsp;DESCRIPTION     Returns the minimum value of the set of pixels contained  in     the  N x N filter window.&nbsp;TIPS     Works best on images containing positive outlier noise. This     filter  will  darken the appearance of the image.  Keep mask     size small to minimize blurring.&nbsp;DIAGNOSTICS     Returns error message if invalid  filter  size  is  entered.     Size of filter is to be an odd integer limited from &lt; 3 - 31     &gt;.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call replaces each pixel value by the      minimum pixel value in a 3 x 3 window */      cvipImage = minimum_filter(cvipImage,3);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;BUGS     None.&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE - by Scott E. Umbaugh and John     A Creighton.&nbsp;\n\r\n\r&nbsp;","minimum_filter","scr\\CVIP_C_functions/minimum_filter.htm","   ACADEMIC COMPUTING  Normal  akharba  5  5  2005-07-02T19:51:00Z  2006-07-08T22:25:00Z  1  332  1895  SIUE  15  4  2223  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        minkowski_distance – calculates the minkowski distance&nbsp;SYNOPSIS#include &quot;math.h&quot;#include &quot;stdio.h&quot;     float minkowski_distance(float *vector1, float *vector2, int r, int n, int *err_code)      &lt;vector1&gt; - pointer to an input array&lt;vector2&gt; - pointer to an input array&lt;r&gt; - positive integer      &lt;n&gt; - number of elements (features) in the array      &lt;err_code&gt; - pointer to the error code; use 0 for no error     &nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\minkowski_distance.c&nbsp;DESCRIPTION     This function calculates the Minkowski distance      measure from the elements of the two arrays. The formula      used for the calculation is given in chapter 6 of the      following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 3\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       float  *vector1;\n\r\n\r       float  *vector2;\n\r\n\r       float  result;\n\r\n\r       /* Set r to 3 */\n\r\n\r       int           r=3;\n\r\n\r       int           i;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r&nbsp;\n\r\n\r       vector1 = malloc(MAX_CASE*sizeof(float));\n\r\n\r       vector2 = malloc(MAX_CASE*sizeof(float));\n\r\n\r&nbsp;\n\r\n\r       /* Get the vectors. The items should beseparated by &quot;,&quot; */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector1: &quot;);\n\r\n\r       for(i=0;i&lt;MAX_CASE;i++)\n\r\n\r       {\n\r\n\r              scanf(&quot;%f,&quot;,&amp;vector1[i]);\n\r\n\r       }\n\r\n\r       \n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector1: &quot;);\n\r\n\r       for(i=0;i&lt;MAX_CASE;i++)\n\r\n\r       {\n\r\n\r              scanf(&quot;%f,&quot;, &amp;vector2[i]);\n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       result = minkowski_distance(vector1,vector2, r, MAX_CASE, err_code);\n\r\n\r&nbsp;\n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }\n\r\n\r       else\n\r\n\r       {\n\r\n\r              /* Print out the result */\n\r\n\r              printf(&quot;result=%f\\n&quot;,result);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free the pointers */\n\r\n\r       free(vector1);\n\r\n\r       free(vector2);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A float number representing the Minkowski distance measure&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","minkowski_distance","scr\\CVIP_C_functions/minkowski_distance.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:17:00Z  2004-10-20T00:07:00Z  1  339  1933  SIUE  16  4  2268  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     mmse_filter - Adaptive Minimum Mean Squared Error Filter&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPimage.h&quot;&nbsp;     Image * mmse_filter(Image  *  inputImage,  float  noise_var,     unsigned int kernel_size)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;noise_var&gt; - noise variance of input image      &lt;kernel_size&gt; - kernel size (an odd number)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\mmse_filter.c&nbsp;DESCRIPTION     The mmse_filter makes use of the local variance to determine     if  a mean filter is to be applied to the local region of an     image.  It works best for short tail additive type noise.&nbsp;     The adaptive MMSE filter is based on the following equation:&nbsp;                      (sigma_n)^2  /                  \\     MMSE = d(r,c) -  ------------ | d(r,c) - ml(r,c) |                      (sigma_l)^2  \\                  /&nbsp;     where ml is the local mean, sigma_n is the  noise  variance,     and sigma_l is the local variance.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs a adaptive mean squared      error filter operation with the kernel size equal to 3      and the noise variance equal to 100 */      cvipImage = mmse_filter(cvipImage,100,3);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;RETURN VALUES     Pointer to the processed image&nbsp;BUGS     none&nbsp;SEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Wenxing Li.&nbsp;\n\r\n\r&nbsp;","mmse_filter","scr\\CVIP_C_functions/mmse_filter.htm","   Mounika  Normal  jhansi  56  26  2004-06-04T21:33:00Z  2010-01-06T21:57:00Z  1  294  1682  SIUE  14  3  1973  11.9999    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4        NAME     moravec_filter - a spatial- an edge detecting filter&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPspfltr.h&gt;&nbsp;     Image    *moravec_filter(Image    *inputIMAGE, float threshval)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;threshval&gt; - threshold valuePATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\moravec_filter.cDESCRIPTION     The Moravec Detector is the simplest corner detector. This is used      to find the points of maximum contrast, which corresponds to potential     corners and sharp edges. This is defined as                                                                                                    It finds the average difference between a pixel and its neighbors in all      directions.Then the threshold operation is applied on the image.&nbsp;     &nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to the processed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPspfltr.h&gt;&nbsp;      void main() {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs filter operation of threshold value of 100*/      cvipImage = moravec_filter(cvipImage,100);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 2010 SIUE - by Scott Umbaugh and Mounika Mamidi.&nbsp;\n\r\n\r&nbsp;","moravec_filter","scr\\CVIP_C_functions/moravec_filter.html","   Mounika  Normal  jhansi  40  49  2004-06-04T21:33:00Z  2010-01-06T21:57:00Z  1  365  2087  SIUE  17  4  2448  11.9999    125  Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME     Morph_hitmiss-morphological operation&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmorph.h&gt;&nbsp;     Image    *morph_hitmiss((longImage* inputImage, int MaskSize, char* HitmissFilter)&nbsp;      &lt;inputImage&gt; - pointer to an Image                                                  &lt;MaskSize&gt; - mask size (3,5,7,9,...)      &lt;HitmissFilter&gt; - Filter values&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\MORPHOLOGICAL\\morph_hitmiss.c&nbsp;DESCRIPTIONThe Morph_Hitmiss transform is a morphological operation used for shape detection or pattern recognition. The Hit or Miss operation is performed by translating the center of the structuring element to all points in the image, and then comparing the pixels of the structuring element with the underlying image pixels. If the pixels in the structuringelement is set to foreground color, indicating a ‘hit’ otherwise ‘miss’.The structuring element contains 0’s, 1’s and x’s or “don’t care”.Don’t care elements in the structuring element match with either 0s or 1s.ND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to the processed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmorph.h&gt;&nbsp;      void main() {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      char *HitmissFilter;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      for(int i=0;i&lt;25(5*5);i++)      HitmissFilter[i] =(char *) getString_CVIP();      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs mask operation on binary image in a      kernel size of 5 with the filter values of 0’s, 1’s and don’t care’s      in HitmissFilter*/      cvipImage = morph_hitmiss(cvipImage, 5, HitmissFilter);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     MORPHOLOGICAL library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Mounika Mamidi.&nbsp;\n\r\n\r&nbsp;","morph_hitmiss","scr\\CVIP_C_functions/morph_hitmiss.html","   Mounika  Normal  Mounika  44  20  2004-06-04T21:33:00Z  2010-02-05T18:10:00Z  1  447  2549  SIUE  21  5  2991  11.5606    125  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME     morph_skeleton-morphological operation&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmorph.h&gt;&nbsp;     Image    morph_skeleton(Image* inputImage, int  FilterDimension, char*         SkeletonFilter, int Iterations, int four_eight_mask, int method);&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;FilterDimension&gt; - mask size (3,5,7,9,...)      &lt;SkeletonFilter&gt; - Filtervalues      &lt;Iterations&gt; - number of iterations      &lt;four_eight_mask&gt; - 0- for four directional mask1-&nbsp;&nbsp;&nbsp; for eight directional mask&nbsp;      &lt;method&gt;   -        0- for AND method                          1- for Sequential Method&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\MORPHOLOGICAL\\morph_skeleton.c&nbsp;DESCRIPTIONSleletonization is nothing but repeated thinning. One of the most common uses of skeletonization is to reduce the thresholdedoutput of an edge detector such as the Sobel operator to lines of a single pixel thickness.&nbsp;Skeletonization is implemented in two steps. The first step is&nbsp;normal thinning. In this the pixels are marked to remove. In&nbsp;the second step the pixels are removed with out destroying the&nbsp;connectivity. Skeletonization preserves the topology. The&nbsp;skeleton should be 8 connected. The skeleton is use ful&nbsp;because it provides a simple and compact representation of&nbsp;the shape of an object.&nbsp;The structuring element contains 0’s, 1’s and x’s or “don’t care”. Don’t care elements in the structuring element match with either 0s or 1s. morph_skeleton transform works only on binary images.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to the processed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmorph.h&gt;&nbsp;      void main() {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      char *SkeletonFilter;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      for(int i=0;i&lt;25;i++)      SkeletonFilter[i] =(char *) getString_CVIP();      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs mask operation on binary image in a      kernel size of 5 with the filter values of 0’s, 1’s and don’t care’s      in SkeletonFilter, for 10 times*/      cvipImage = morph_skeleton(cvipImage, 5, SkeletonFilter, 10);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     MORPHOLOGICAL library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Mounika Mamidi.&nbsp;\n\r\n\r&nbsp;","morph_skeleton","scr\\CVIP_C_functions/morph_skeleton.html","   Mounika  Normal  jhansi  42  161  2004-06-04T21:33:00Z  2010-01-06T21:58:00Z  1  370  2111  SIUE  17  4  2477  11.9999    125  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME     morph_thinning-morphological operation&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmorph.h&gt;&nbsp;     Image    *morph_thinning(Image    *inputImage ,int    MaskSize,char     *ThinningFilter)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;MaskSize&gt; - mask size (3,5,7,9,...)      &lt;ThinningFilter&gt; - Filter values(single dimension)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\MORPHOLOGICL/morph_thinning.c&nbsp;DESCRIPTIONThinning is a morphological operation. This successfully erodes awayforeground pixels from the boundary images, while preserving the endpoints of the line segment. Thinning is related to hit or miss transform and can be expressed as&nbsp;Thinning(I,J)=I-HitMiss(I,J)&nbsp;I-Original ImageHitMiss(I,J) –hit and miss transform of the original image with structuringelement JThe structuring element contains 0’s, 1’s and x’s or “don’t care”. Don’t care elements in the structuring element match with either 0s or 1s.morph_thinning transform works only on binary images.&nbsp;&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to the processed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmorph.h&gt;&nbsp;      void main() {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      char *ThinningFilter;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      for(int i=0;i&lt;25;i++)      ThinningFilter[i] =(char *) getString_CVIP();      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs mask operation on binary image in a      kernel size of 5 with the filter values of 0’s, 1’s and don’t care’s      in ThinningFilter*/      cvipImage = morph_thinning(cvipImage, 5, ThinningFilter );      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     MORPHOLOGICAL library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Mounika Mamidi.&nbsp;\n\r\n\r&nbsp;","morph_thinning","scr\\CVIP_C_functions/morph_thinning.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  3  2004-06-05T00:18:00Z  2004-10-20T00:07:00Z  1  388  2218  SIUE  18  5  2601  10.3501    Clean  Clean                  MicrosoftInternetExplorer4    NAME     MorphClose_Image - performs morphological closing&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPmatrix.h&quot;      #include &quot;CVIPmorph.h&quot;&nbsp;     Image *MorphClose_Image(Image *inputImage, Matrix  *kernelP,     CVIP_BOOLEAN user_org, int row, int col)      &lt;inputImage&gt; - a pointer to an Image structure      &lt;kernelP&gt; - a pointer to a Matrix structure      &lt;user_org&gt; - define center of kernel      &lt;row&gt; - user-defined row of kernel center      &lt;col&gt; - user-defined column of kernel center&nbsp;     Image* MorphClose(Image *inputImage, int k_type, int  ksize,     int height, int width)&nbsp;      &lt;inputImage&gt; - pointer to an Input      &lt;k_type&gt;  -  kernel  type  (1=disk   2=square   3=rectangle     4=cross)      &lt;ksize&gt; - size of kernal (height and width of mask)      &lt;height&gt; - height for square and  rectangle,  thickness  of     lines for cross      &lt;width&gt; - width for rectangle, size of crossPATH     $CVIPtoolsHOME\\CVIPC\\MORPHOLOGICAL\\morphCODE.c&nbsp;DESCRIPTION     Morphologic closing consists of morphological dilation  fol-     lowed by morphological erosion of an image. It is often used     to fill in small gaps or holes in objects.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Returns a modified image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE           #include &lt;CVIPtoolkit.h&gt;           #include &lt;CVIPdef.h&gt;           #include &lt;CVIPimage.h&gt;           #include &lt;CVIPconvert.h&gt;           #include &lt;CVIPimage.h&gt;&nbsp;           #include &lt;CVIPmatrix.h&gt;           #include &lt;CVIPmorph.h&gt;&nbsp;           void main()           {           Image *cvipImage;           IMAGE_FORMAT format;           char *inputfile, *outputfile;           (void) setDisplay_Image(&quot;RamViewer&quot;, &quot;Default&quot;);&nbsp;           print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);           inputfile =(char *) getString_CVIP();           format = getFormat_CVIP(inputfile);           cvipImage = read_Image(inputfile, 1);&nbsp;           print_CVIP(&quot;\\n&quot;);           cvipImage = (Image *)MorphClose(cvipImage,1,3,3,3);           fflush(stdin);&nbsp;           print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);           outputfile = getString_CVIP();           write_Image(cvipImage,     outputfile,CVIP_NO,CVIP_NO,format, 1);           display_Image(outputfile,format);           free(inputfile);           free(outputfile);           }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     MorphDilate_Image, MorphErode_Image, MorphOpen_Image&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh, Greg Hance,  and     Kun Luo.&nbsp;\n\r\n\r&nbsp;","MorphClose_Image","scr\\CVIP_C_functions/MorphClose_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  0  2004-06-05T00:20:00Z  2004-10-20T00:07:00Z  1  414  2365  SIUE  19  5  2774  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     MorphDilate_Image - performs morphological dilation&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPmatrix.h&quot;      #include &quot;CVIPmorph.h&quot;&nbsp;     Image *MorphDilate_Image(Image *inputImage, Matrix *kernelP,     CVIP_BOOLEAN user_org, int row, int col)      &lt;inputImage&gt; - a pointer to an Image structure      &lt;kernelP&gt; - a pointer to a Matrix structure      &lt;user_org&gt; - define center of kernel      &lt;col&gt; - user-defined column of kernel center      &lt;row&gt; - user-defined row of kernel center&nbsp;     Image *MorphDilate(Image *inputImage, int k_type, int ksize,     int height, int width)&nbsp;      &lt;inputImage&gt; - pointer to an Input      &lt;k_type&gt;  -  kernel  type  (1=disk   2=square   3=rectangle     4=cross)      &lt;ksize&gt; - size of kernal (height and width of mask)      &lt;height&gt; - height for square and  rectangle,  thickness  of     cross lines      &lt;width&gt; - for rectangle, size of cross&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\MORPHOLOGICAL\\morphCODE.c&nbsp;DESCRIPTION     Morphologic dilation is a process in which objects within an     image  are  expanded. The degree of object expansion is con-     trolled through the use of a  structuring  element  that  is     convolved with the original image to yield a desired image.&nbsp;     Dilation is used to fill in small holes in an object, or  to     connect disjoint objects.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Returns a modified image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE           #include &lt;CVIPtoolkit.h&gt;           #include &lt;CVIPdef.h&gt;           #include &lt;CVIPimage.h&gt;           #include &lt;CVIPconvert.h&gt;           #include &lt;CVIPimage.h&gt;&nbsp;           #include &lt;CVIPmatrix.h&gt;           #include &lt;CVIPmorph.h&gt;&nbsp;           void main()           {           Image *cvipImage;           IMAGE_FORMAT format;           char *inputfile, *outputfile;           (void) setDisplay_Image(&quot;RamViewer&quot;, &quot;Default&quot;);&nbsp;           print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);           inputfile =(char *) getString_CVIP();           format = getFormat_CVIP(inputfile);           cvipImage = read_Image(inputfile, 1);&nbsp;           print_CVIP(&quot;\\n&quot;);           cvipImage = (Image *)MorphDilate(cvipImage, 2,3,3,3 );           fflush(stdin);&nbsp;           print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);           outputfile = getString_CVIP();           write_Image(cvipImage,     outputfile,CVIP_NO,CVIP_NO,format, 1);           display_Image(outputfile,format);           free(inputfile);           free(outputfile);           }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     MorphErode_Image, MorphClose_Image, MorphOpen_Image&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh, Greg Hance,  and     Kun Luo.&nbsp;\n\r\n\r&nbsp;","MorphDilate_Image","scr\\CVIP_C_functions/MorphDilate_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T00:21:00Z  2004-10-20T00:08:00Z  1  411  2347  SIUE  19  5  2753  10.3501    Clean                  MicrosoftInternetExplorer4 NAME     MorphErode_Image - performs morphological erosion&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPmatrix.h&quot;      #include &quot;CVIPmorph.h&quot;&nbsp;     Image *MorphErode_Image(Image *inputImage, Matrix  *kernelP,     CVIP_BOOLEAN user_org, int row, int col)      &lt;inputImage&gt; - a pointer to an Image structure      &lt;kernelP&gt; - a pointer to a Matrix structure      &lt;user_org&gt; - define center of kernel      &lt;row&gt; - user-defined row of kernel center      &lt;col&gt; - user-defined column of kernel center&nbsp;     Image *MorphErode(Image *inputImage, int k_type, int  ksize,     int height, int width)&nbsp;      &lt;inputImage&gt; - pointer to an Input      &lt;k_type&gt;  -  kernel  type  (1=disk   2=square   3=rectangle     4=cross)      &lt;ksize&gt; - size of kernal (height and width of mask)      &lt;height&gt; - height for square and  rectangle,  thickness  of     lines of cross      &lt;width&gt; - width for rectangle, size of cross&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\MORPHOLOGICAL\\morphCODE.c&nbsp;DESCRIPTION     Morphologic erosion is a process in which an image is shrunk     by  etching  away its borders. The degree of image reduction     is controlled through the use of a structuring element  that     is  convolved  with  the  original  image to yield a desired     image.&nbsp;     Erosion is used disconnect loosely-attached objects.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Returns a modified image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE           #include &lt;CVIPtoolkit.h&gt;           #include &lt;CVIPdef.h&gt;           #include &lt;CVIPimage.h&gt;           #include &lt;CVIPconvert.h&gt;           #include &lt;CVIPimage.h&gt;&nbsp;           #include &lt;CVIPmatrix.h&gt;           #include &lt;CVIPmorph.h&gt;&nbsp;           void main()           {           Image *cvipImage;           IMAGE_FORMAT format;           char *inputfile, *outputfile;           (void) setDisplay_Image(&quot;RamViewer&quot;, &quot;Default&quot;);&nbsp;           print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);           inputfile =(char *) getString_CVIP();           format = getFormat_CVIP(inputfile);           cvipImage = read_Image(inputfile, 1);&nbsp;           print_CVIP(&quot;\\n&quot;);           cvipImage = (Image *)MorphErode(cvipImage,2,5,3,3);           fflush(stdin);&nbsp;           print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);           outputfile = getString_CVIP();           write_Image(cvipImage,     outputfile,CVIP_NO,CVIP_NO,format, 1);           display_Image(outputfile,format);           free(inputfile);           free(outputfile);           }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     MorphClose_Image, MorphDilate_Image, MorphOpen_Image&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh, Greg Hance,  and     Kun Luo.&nbsp;\n\r\n\r&nbsp;","MorphErode_Image","scr\\CVIP_C_functions/MorphErode_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T00:21:00Z  2004-10-20T00:08:00Z  1  387  2212  SIUE  18  5  2594  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     morphIterMod_Image - performs iterative morphological modif-     ication&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPmorph.h&quot;&nbsp;     Image  *morphIterMod_Image(const  Image   *binImage,   const     Matrix         **surMATS,        CVIP_BOOLEAN        (*const     boolFUNC)(CVIP_BOOLEAN a,CVIP_BOOLEAN b), int no_of_sur, int     connectedness, int no_of_iter, int f)&nbsp;      &lt;binImage&gt; - pointer to Image structure (binary image)      &lt;surMATS&gt; - pointer to set S (surrounds) for which a_ij = 1      &lt;boolFUNC&gt; - pointer to Boolean  function  of  form  L(a,b)     (c_ij = L(a_ij,b_ij))      &lt;no_of_sur&gt; - number of surrounds      &lt;connectedness&gt; - the connectivity scheme being  used;  one     of...FOUR,EIGHT,SIX_NWSE,SIX_NESW.      &lt;no_of_iter&gt; - number of iterations to perform      &lt;f&gt; - number of subfields into which the image  tesselation     will be divided&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\MORPHOLOGICAL\\morph.c&nbsp;DESCRIPTION     Consider a_ij to have value one when the neighborhood of the     picture cell at (i, j) is in this set. Next consider b_ij to     denote the value of the picture cell itself. At  each  point     of the tessellated image a new binary value is computed that     is the result for that point of the  iterative  modification     algorithm.  The  new  value c_ij is to be computed from a_ij     and b_ij. Here a, b, c are Boolean variables,  in  that  the     they  can  only  take  on values of 0 or 1. Computation of c     from a and b can thus be specified by a Boolean function  of     two variables -- &lt;boolFUNC&gt;. We can uniquely define the mor-     phological iterative modification  algorithm  by  specifying     four  things...  (1)  The  set S of surrounds &lt;surMATS&gt; (for     which a_ij = 1), (2) The Boolean function L(a,b) (where c_ij     =  L(a_ij,b_ij)), (3) The number of iterations &lt;no_of_iter&gt;,     n. (4) The number of subfields, &lt;f&gt;, into  which  the  image     tessellation is divided. There are several Boolean functions     provided for the user (see functions zero, not_b,  and,  or,     not_and,  or_not_and,  xor.)  In addition a set of hexagonal     lattices are provided and declared as HEXLAT1, HEXLAT2, ...,     HEXLAT14.  The  function  array2Matrix can be used to form a     Matrix structure that can then be passed to morphomod(...).&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     A modified image&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     MORPHOLOGICAL library, morpho&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Greg     Hance.&nbsp;\n\r\n\r&nbsp;","morphIterMod_Image","scr\\CVIP_C_functions/morphIterMod_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:22:00Z  2004-10-20T00:08:00Z  1  606  3460  SIUE  28  8  4058  10.3501    Clean                  MicrosoftInternetExplorer4 NAME     morpho - higher level function performing iterative  morpho-     logical modification based on morphIterMod_Image&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPmorph.h&quot;&nbsp;     Image * morpho(const  Image   *binImage,        const char * surround_str, CVIP_BOOLEAN rotate,        int boolFUNC, int connectedness,        unsigned no_of_iter, int fields)&nbsp;      &lt;binImage&gt; - pointer to Image structure (binary image)      &lt;surround_str&gt; - pointer to a string  holding  the  set  of     surrounds, such as &quot;1, 7, 8&quot;.      &lt;rotate&gt; - rotate or not (CVIP_YES, CVIP_NO)      &lt;boolFUNC&gt; - integer number for the  Boolean  function  (1-     6):          1: 0          2: !a          3: ab          4: a+b          5: a^b          6: (!a)b      &lt;connectedness&gt;  -  the  connectivity  scheme  being   used     (FOUR,EIGHT,SIX_NWSE,SIX_NESW)      &lt;no_of_iter&gt; - number of iterations to perform      &lt;fields&gt; - number of subfields into which the image  tesse-     lation will be divided&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\MORPHOLOGICAL\\morph.c&nbsp;DESCRIPTION     This is a wrapper function for morphIterMod_Image, for  more     information, see morphIterMod_Image.&nbsp;TYPES AND CONSTANTS     none&nbsp;RETURN VALUES     A pointer to the modified image&nbsp;EXAMPLE      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPmorph.h&quot;&nbsp;      main () {         Image *cvipImage, *out_img;         IMAGE_FORMAT  format;         char *inputfile,           *surround_str = (char *) malloc(sizeof(char) * 80),            temp;         CVIP_BOOLEAN rotate;         int boolFUNC,            connectedness,            fields;            unsigned no_of_iter;&nbsp;         print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);         inputfile = getString_CVIP();&nbsp;         /* read in the input image */         cvipImage = (Image *) read_Image(inputfile, 1);         if(cvipImage == NULL) {            error_CVIP(&quot;init_Image&quot;,               &quot;could not read image file&quot;);            free(inputfile);            exit(1);          } else view_Image(cvipImage,inputfile);&nbsp;         print_CVIP(&quot;Please input the surrounds:&quot;);         fgets(surround_str, 80, stdin);&nbsp;         print_CVIP(&quot;Rotate? (y/n)&quot;);         scanf(&quot;%1s&quot;, &amp;temp);         rotate = (temp == \'y\') ? CVIP_YES : CVIP_NO;&nbsp;         print_CVIP(&quot;The boolean funciton number (1-6):&quot;);         scanf(&quot;%d&quot;, &amp;boolFUNC);            if (boolFUNC &lt; 0 || boolFUNC &gt; 6) {               error_CVIP(&quot;main&quot;,                &quot;The boolean funciton number should be 1 to 6&quot;);            exit(1);         }&nbsp;         print_CVIP(&quot;Connectedness  (1-FOUR;2-EIGHT;3-SIX_NWSE;4-     SIX_NESW):&quot;);         scanf(&quot;%1s&quot;, &amp;temp);         switch (temp) {            case \'1\': connectedness = FOUR; break;            case \'2\': connectedness = EIGHT; break;            case \'3\': connectedness = SIX_NWSE; break;            case \'4\': connectedness = SIX_NESW; break;            default:               error_CVIP(&quot;main&quot;,                 &quot;The connectedness  number should be 1 to 4&quot;);               exit(1);         }         print_CVIP(&quot;Number of iterations (0 for infinity):&quot;);         scanf(&quot;%d&quot;, &amp;no_of_iter);&nbsp;         print_CVIP(&quot;Number of subfields (1-3):&quot;);         scanf(&quot;%d&quot;, &amp;fields);&nbsp;         if (fields &lt; 1 || fields &gt; 3) {            error_CVIP(&quot;main&quot;,             &quot;The number of subfields should be 1 to 3&quot;);            exit(1);         }&nbsp;         if ( (out_img = morpho(cvipImage, surround_str,               rotate, boolFUNC, connectedness, no_of_iter,               fields)) == (Image *)NULL) {            error_CVIP(&quot;main&quot;, &quot;Iterative modification  error&quot;);            exit(1);         } else {            view_Image(out_img,&quot;Iterative modification&quot;);         }&nbsp;      }      /*      ** end of function main      */&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     MORPHOLOGICAL library, morphIterMod_Image&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh  and  Yansheng     Wei.&nbsp;\n\r\n\r&nbsp;","morpho","scr\\CVIP_C_functions/morpho.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T00:23:00Z  2004-10-20T00:08:00Z  1  388  2217  SIUE  18  5  2600  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     MorphOpen_Image - performs morphological opening&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPmatrix.h&quot;      #include &quot;CVIPmorph.h&quot;&nbsp;     Image  *MorphOpen_Image(Image  *imageP,   Matrix   *kernelP,     CVIP_BOOLEAN user_org, int row, int col)      &lt;inputImage&gt; - a pointer to an Image structure      &lt;kernelP&gt; - a pointer to a Matrix structure      &lt;user_org&gt; - define center of kernel      &lt;row&gt; - user-defined row of kernel center      &lt;col&gt; - user-defined column of kernel center&nbsp;     Image *MorphOpen(Image *inputImage, int k_type,  int  ksize,     int height, int width)&nbsp;      &lt;inputImage&gt; - pointer to an Input      &lt;k_type&gt;  -  kernel  type  (1=disk   2=square   3=rectangle     4=cross)      &lt;ksize&gt; - kernel size (height and width of mask)      &lt;height&gt; height for  square  and  rectangle,  thickness  of     lines for cross      &lt;width&gt; - width for rectangle, size of cross&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\MORPHOLOGICAL\\morphCODE.c&nbsp;DESCRIPTION     Morphologic opening consists of morphological  erosion  fol-     lowed  by  morphological  dilation  of an image. It is often     used to eliminate small objects from an image.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Returns a modified image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE           #include &lt;CVIPtoolkit.h&gt;           #include &lt;CVIPdef.h&gt;           #include &lt;CVIPimage.h&gt;           #include &lt;CVIPconvert.h&gt;           #include &lt;CVIPimage.h&gt;&nbsp;           #include &lt;CVIPmatrix.h&gt;           #include &lt;CVIPmorph.h&gt;&nbsp;           void main()           {           Image *cvipImage;           IMAGE_FORMAT format;           char *inputfile, *outputfile;           (void) setDisplay_Image(&quot;RamViewer&quot;, &quot;Default&quot;);&nbsp;           print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);           inputfile =(char *) getString_CVIP();           format = getFormat_CVIP(inputfile);           cvipImage = read_Image(inputfile, 1);&nbsp;           print_CVIP(&quot;\\n&quot;);           cvipImage = (Image *)MorphOpen(cvipImage, 1,3,3,3);           fflush(stdin);&nbsp;           print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);           outputfile = getString_CVIP();           write_Image(cvipImage,     outputfile,CVIP_NO,CVIP_NO,format, 1);           display_Image(outputfile,format);           free(inputfile);           free(outputfile);           }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     MorphDilate_Image, MorphErode_Image, MorphClose_Image&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh, Greg Hance,  and     Kun Luo.&nbsp;\n\r\n\r&nbsp;","MorphOpen_Image","scr\\CVIP_C_functions/MorphOpen_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:24:00Z  2004-10-20T00:08:00Z  1  274  1563  SIUE  13  3  1834  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     multiply_Image - multiplies two images&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIParithlogic.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;     Image *multiply_Image(Image *inputImage1,Image *inputImage2)&nbsp;      &lt;inputImage1&gt; - pointer to an Image structure      &lt;inputImage2&gt; - pointer to an Image structure&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\ARITHLOGIC\\arithlogic.c&nbsp;DESCRIPTION     This function uses the CVIP function  \'multPWise_Matrix\'  to     perform  bitwise  multiplication  of  two  images.   Complex     matrices are supported.&nbsp;TYPES AND CONSTANTS     #define MATPWISE_DEFINED&nbsp;RETURN VALUES     A multiplied image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &quot;CVIPimage.h&quot;      #include &quot;CVIParithlogic.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;      void main() {        Image *inputImage1, *inputImage2, *outputImage;        IMAGE_FORMAT format;        char *inputfile1, *inputfile2, *outputfile;&nbsp;        setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;        print_CVIP(&quot;\\n\\tEnter the first Input File Name:  &quot;);        inputfile1 =(char *) getString_CVIP();        inputImage1 = read_Image(inputfile1, 1);        view_Image(inputImage1,inputfile1);        free(inputfile1);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the second Input File Name:  &quot;);        inputfile2 =(char *) getString_CVIP();        inputImage2 = read_Image(inputfile2, 1);        view_Image(inputImage2,inputfile2);        free(inputfile2);&nbsp;        outputImage = multiply_Image(inputImage1, inputImage2);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);        outputfile = getString_CVIP();        view_Image(outputImage,outputfile);        free(outputfile);&nbsp;      }&nbsp;SEE ALSO     ARITHLOGIC library &nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Greg     Hance.&nbsp;\n\r\n\r&nbsp;","multiply_Image","scr\\CVIP_C_functions/multiply_Image.htm","   ACADEMIC COMPUTING  Normal  akharba  9  7  2005-07-02T19:11:00Z  2006-07-08T22:25:00Z  1  587  3351  SIUE  27  7  3931  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        nearest_centroid – finds the nearest centroid using a distance                            or similarity measure&nbsp;SYNOPSIS#include &quot;math.h&quot;#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;#include &quot;CVIPpattern.h&quot;     int nearest_centroid(char *file_tt, char *file_tr, char *file_out, int option_normalize, int option_distance, float s_min, float s_max, float r_softmax, int r_minkowski)      &lt;file_tt&gt; - pointer to a text file (test set)&lt;file_tr&gt; - pointer to a text file (training set)&lt;file_out&gt; - pointer to a text file (output)&lt;option_normalize&gt; - normalization method to be used&lt;option_distance&gt; - distance or similarity method to be used&lt;s_min&gt; - minimum value for the specified range (used with Min-max           normalization only; else use -1)&lt;s_max&gt; - maximum value for the specified range (used with Min-max           normalization only; else use -1)&lt;r_softmax&gt; - used with Softmax scaling only; else use -1&lt;r_minkowski&gt; - used with Minkowski generalized distance measure                only; else use -1&nbsp;&nbsp;&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\nearest_centroid.c&nbsp;DESCRIPTION     This function uses the selected distance or similarity measure     to find the closest match in the training set to every entry in      the test set. It uses the training set to generate the centroid      for all the classes in the training file and then uses this      new training file as the main training file.&nbsp;     Values to be used for:              option_normalize:                 0 – No Normalization        1 – Range-normalize        2 – Unit Vector normalization        3 – Standard Normal Density normalization        4 – Min-max normalization        5 – Softmax scaling              option_distance:                 1 – Euclidean Distance        2 – City block or Absolute value metric        3 – Maximum value metric        4 – Minkowski distance        5 – Vector inner product        6 – Tanimoto metric&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 128\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       char   *test,*training, *output;\n\r\n\r       /*     Defineall parameters, and initialize them to -1.\n\r\n\r              Change them afterwards, if theyare required in the \n\r\n\r              application.\n\r\n\r       */\n\r\n\r       int           r_minkowski=-1,option_normalize=-1, option_distance=0;\n\r\n\r       float  s_min=-1,s_max=-1, r_softmax=-1;\n\r\n\r&nbsp;\n\r\n\r       int           err_code;\n\r\n\r       \n\r\n\r       /* Memory allocation */\n\r\n\r       test = malloc(MAX_CASE*sizeof(char));\n\r\n\r       training = malloc(MAX_CASE*sizeof(char));\n\r\n\r       output = malloc(MAX_CASE*sizeof(char));\n\r\n\r&nbsp;\n\r\n\r       /* Get the file names, and parameters. */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for testing set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, test);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for trainning set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, training);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for output: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, output);\n\r\n\r&nbsp;\n\r\n\r       /* Set required parameters */\n\r\n\r       option_normalize = 1;\n\r\n\r       option_distance = 0;\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\rerr_code = nearest_centroid(test, training, output,option_normalize, option_distance, s_min, s_max, r_softmax, r_minkowski);\n\r\n\r       \n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, err_code);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free pointers */\n\r\n\r       free(test);\n\r\n\r       free(training);\n\r\n\r       free(output);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     An error code&nbsp; Error Codes:&nbsp;1: The headers in the training and test files don\'t match 2: K is greater than the number of entries in the training setor K&lt;=0 3: s_min is greater than or equal to s_max 4: Data range is 0 and so the data can\'t be normalized 5: Divisor is 0 in Tanimoto similarity measure 7: Can\'t open, read or create file 9: Memory allocation error 10: Every entry in training set should have a class name 12: r in minkowski should be a positive integer 13: There is more than one header in the training or test feature file&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","nearest_centroid","scr\\CVIP_C_functions/nearest_centroid.htm","   ACADEMIC COMPUTING  Normal  akharba  3  10  2005-07-02T22:35:00Z  2006-07-08T22:25:00Z  1  342  1951  SIUE  16  4  2289  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        nearest_centroid_set – calculates the centroid for all the                                classes in the training file&nbsp;SYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;float.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;&nbsp;#define MAX_CASE 128&nbsp;int *nearest_centroid_set(char *file_tr, int *err_code)      &lt;file_tr&gt; - pointer to a text file (training set)      &lt;err_code&gt; - pointer to the error code&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\nearest_centroid_set.c&nbsp;DESCRIPTION     This function uses the training file to calculate a new training file with     centroid values for all the classes. This new training file is then used as     the training file in the nearest_centroid function for classification.EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 128\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       char   *training;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r       \n\r\n\r       /* Memory allocation */\n\r\n\r       training = malloc(MAX_CASE*sizeof(char));\n\r\n\r&nbsp;\n\r\n\r       /* Get the file names, and parameters. */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for training  set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, training);\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       err_code = nearest_centroid_set(training,err_code);\n\r\n\r       \n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free pointers */\n\r\n\r       free(training);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to the error code&nbsp; Error Codes:&nbsp;1: The headers in the training and test files don\'t match 2: K is greater than the number of entries in the training setor K&lt;=0 3: s_min is greater than or equal to s_max 4: Data range is 0 and so the data can\'t be normalized 5: Divisor is 0 in Tanimoto similarity measure 7: Can\'t open, read or create file 9: Memory allocation error 10: Every entry in training set should have a class name 12: r in minkowski should be a positive integer 13: There is more than one header in the training or test feature file&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","nearest_centroid_set","scr\\CVIP_C_functions/nearest_centroid_set.htm","   ACADEMIC COMPUTING  Normal  akharba  19  32  2005-07-02T18:29:00Z  2006-07-08T22:25:00Z  1  563  3210  SIUE  26  7  3766  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        nearest_neighbor – finds the nearest neighbor using a distance                            or similarity measure&nbsp;SYNOPSIS#include &quot;math.h&quot;#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;#include &quot;CVIPpattern.h&quot;     &nbsp;int nearest_neighbor(char *file_tt, char *file_tr, char *file_out, int option_normalize, int option_distance, float s_min, float s_max, float r_softmax, int r_minkowski)      &lt;file_tt&gt; - pointer to a text file (test set)&lt;file_tr&gt; - pointer to a text file (training set)&lt;file_out&gt; - pointer to a text file (output)&lt;option_normalize&gt; - normalization method to be used&lt;option_distance&gt; - distance or similarity method to be used&lt;s_min&gt; - minimum value for the specified range (used with Min-max           normalization only; else use -1)&lt;s_max&gt; - maximum value for the specified range (used with Min-max           normalization only; else use -1)&lt;r_softmax&gt; - used with Softmax scaling only; else use -1&lt;r_minkowski&gt; - used with Minkowski generalized distance measure                only; else use -1&nbsp;&nbsp;&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\nearest_neighbor.c&nbsp;DESCRIPTION     This function uses the selected distance or similarity measure     to find the closest match in the training set to every entry in      the test set.&nbsp;     Values to be used for:              option_normalize:                 0 – No Normalization        1 – Range-normalize        2 – Unit Vector normalization        3 – Standard Normal Density normalization        4 – Min-max normalization        5 – Softmax scaling              option_distance:                 1 – Euclidean Distance        2 – City block or Absolute value metric        3 – Maximum value metric        4 – Minkowski distance        5 – Vector inner product        6 – Tanimoto metric&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 128\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       char   *test,*training, *output;\n\r\n\r       /*     Defineall parameters, and initialize them to -1.\n\r\n\r              Change them afterwards, if theyare required in the \n\r\n\r              application.\n\r\n\r       */\n\r\n\r       int    r_minkowski=-1,option_normalize=-1, option_distance=0;\n\r\n\r       float  s_min=-1,s_max=-1, r_softmax=-1;\n\r\n\r&nbsp;\n\r\n\r       int           err_code;\n\r\n\r       \n\r\n\r       /* Memory allocation */\n\r\n\r       test = malloc(MAX_CASE*sizeof(char));\n\r\n\r       training = malloc(MAX_CASE*sizeof(char));\n\r\n\r       output = malloc(MAX_CASE*sizeof(char));\n\r\n\r&nbsp;\n\r\n\r       /* Get the file names, and parameters. */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for testing set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, test);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for trainning set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, training);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for output: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, output);\n\r\n\r&nbsp;\n\r\n\r       /* Set required parameters */\n\r\n\r       option_normalize = 1;\n\r\n\r       option_distance = 0;\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       err_code = nearest_neighbor(test,training, output,\n\r\n\roption_normalize, option_distance, s_min, s_max,r_softmax, \n\r\n\rr_minkowski);\n\r\n\r       \n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, err_code);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free pointers */\n\r\n\r       free(test);\n\r\n\r       free(training);\n\r\n\r       free(output);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     An error code &nbsp; Error Codes:&nbsp;1: The headers in the training and test files don\'t match 2: K is greater than the number of entries in the training setor K&lt;=0 3: s_min is greater than or equal to s_max 4: Data range is 0 and so the data can\'t be normalized 5: Divisor is 0 in Tanimoto similarity measure 7: Can\'t open, read or create file 9: Memory allocation error 10: Every entry in training set should have a class name 12: r in minkowski should be a positive integer 13: There is more than one header in the training or test feature file&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","nearest_neighbor","scr\\CVIP_C_functions/nearest_neighbor.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:25:00Z  2004-10-20T00:08:00Z  1  326  1860  SIUE  15  4  2182  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     neg_exp_noise - Add Negative Exponential noise to an image&nbsp;SYNOPSIS     #include &quot;CVIPnoise.h&quot;&nbsp;     Image *neg_exp_noise(Image *imageP,float *var);&nbsp;      &lt;imageP&gt; - pointer to Image structure      &lt;var&gt; - variance of noise distribution&nbsp;&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\NOISE\\noise.cDESCRIPTION     Negative Exponential type noise is the result  of  acquiring     an image illuminated with a coherent laser.  The optics com-     munity refers to this type of noise as laser speckle. It has     a histogram as indicated by the following equation:&nbsp;                 1          hi = ----exp(-Gi/a)                 a&nbsp;     where Gi is the grey-level value of the ith  pixel,  a*a  is     the variance.&nbsp;RETURN VALUES     The neg_exp_noise()  function  returns  the  modified  Image     pointer on success, and returns a NULL pointer on failure&nbsp;BUGS     none&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;CVIPnoise.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      float var=100.0;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call adds negative exponential noise      to the input image with the variance equal to 100.0.      We can use the function neg_exp_noise_setup so      that the user can specify the inputs  */      cvipImage = neg_exp_noise(cvipImage,&amp;var);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      free(outputfile);;      }&nbsp;SEE ALSO     gamma_noise(3),    gaussian_noise(3),     rayleigh_noise(3),     speckle_noise(3), uniform_noise(3)&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and     David Lyons.&nbsp;\n\r\n\r&nbsp;","neg_exp_noise","scr\\CVIP_C_functions/neg_exp_noise.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-05T00:26:00Z  2004-10-20T00:09:00Z  1  187  1066  SIUE  8  2  1251  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     new_ext - replaces a file extension&nbsp;SYNOPSIS      #include &lt;stdlib.h&gt;      #include &lt;string.h&gt;      #include &lt;stdio.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #include &lt;unistd.h&gt;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPhalftone.h&quot;      #include &quot;CVIPluminance.h&quot;      #include &quot;CVIPconutils.h&quot;      #include &quot;CVIPgif.h&quot;      #include &quot;CVIPras.h&quot;      #include &quot;CVIPpnm.h&quot;      #include &quot;CVIPccc.h&quot;      #include &quot;CVIPtiff.h&quot;      #include &quot;CVIPitex.h&quot;      #include &quot;CVIPeps.h&quot;      #include &quot;CVIPbin.h&quot;      #include &quot;CVIPmagic.h&quot;      #include &quot;CVIPvip.h&quot;      #include &quot;pnm.h&quot;      #include &quot;CVIPcompress.h&quot;&nbsp;     new_ext(const char *src, const char *ext)&nbsp;      &lt;src&gt; - pointer to a character string      &lt;ext&gt; - pointer to a character string in  the  form  of  an     extension (e.g. .ppm)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\CONVERSION\\convert.c&nbsp;DESCRIPTION     Replace the last occuring extension of &lt;src&gt; with &lt;des&gt;&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     Pointer to newly allocated character string src.ext&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     CONVERSION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Greg     Hance.\n\r\n\r&nbsp;","new_ext","scr\\CVIP_C_functions/new_ext.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:27:00Z  2004-10-20T00:09:00Z  1  363  2073  SIUE  17  4  2432  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     nonfft_xformfilter - arrange frequency filter for  use  with     various transforms&nbsp;SYNOPSIS      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPxformfilter.h&quot;&nbsp;     Image *nonfft_xformfilter(Image *imgP, int  block_size,  int     dc, FILTER_TYPE filtertype, int p1, float p2, int order)&nbsp;      &lt;imgP&gt; - pointer to an image      &lt;block_size&gt; - block size used in transform      &lt;dc&gt; - 1 = keep DC, 2 = discard DC      &lt;filtertype&gt; - one of:                 IDEAL_LOW                 BUTTER_LOW                 IDEAL_HIGH                 BUTTER_HIGH                 IDEAL_BAND                 BUTTER_BAND                 IDEAL_REJECT                 BUTTER_REJECT                 HIGH_FREQ_EMPHASIS      &lt;p1&gt; - for IDEAL_LOW, BUTTER_LOW, IDEAL_HIGH,             BUTTER_HIGH: cutoff frequency           - for IDEAL_BAND, BUTTER_BAND, IDEAL_REJECT,             BUTTER_REJECT: inner cutoff frequency      &lt;p2&gt; - for IDEAL_LOW, BUTTER_LOW, IDEAL_HIGH,             BUTTER_HIGH: set to -1           - for IDEAL_BAND, BUTTER_BAND, IDEAL_REJECT,             BUTTER_REJECT: outer cutoff frequency           - for HIGH_FREQ_EMPHASIS: emphasis offset      &lt;order&gt; - Butterworth filter order, otherwise -1&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\nonfft_filter.c&nbsp;DESCRIPTION     This function is an internal function called  by  frequency-     domain  filters  to  arrange frequency filter values for use     with various transforms. For example, the dc  value  of  the     FFT  transform  is  placed in the center of the image, while     the dc value of the DCT transform is placed  in  the  upper-     left  corner  of  the image. The nonfft_xformfilter function     places the center of the filter in the appropriate location.&nbsp;     Not normally called directly by a user.&nbsp;TYPES AND CONSTANTS      typedef enum {          IDEAL_LOW = 1,          BUTTER_LOW = 2,          IDEAL_HIGH =3 ,          BUTTER_HIGH = 4,          IDEAL_BAND = 5,          BUTTER_BAND = 6,          IDEAL_REJECT = 7,          BUTTER_REJECT = 8,          HIGH_FREQ_EMPHASIS = 9      } FILTER_TYPE;&nbsp;RETURN VALUES     Pointer to an appropriate filter image&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh, Simon  Low,  and     Greg Hance.&nbsp;\n\r\n\r&nbsp;","nonfft_xformfilter","scr\\CVIP_C_functions/nonfft_xformfilter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:29:00Z  2004-10-20T00:09:00Z  1  254  1454  SIUE  12  3  1705  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     not_Image - performs logical NOT on an image&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIParithlogic.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;     Image *not_Image(Image *inputImage)&nbsp;      &lt;inputImage&gt; - pointer to an Image structure&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\ARITHLOGIC\\arithlogic.c&nbsp;DESCRIPTION     This function performs a logical NOT on  an  image.  Complex     data is NOT supported. Also known as complementing an image.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A comlemented image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &quot;CVIPimage.h&quot;      #include &quot;CVIParithlogic.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;      void main() {        Image *inputImage1, *inputImage2, *outputImage;        IMAGE_FORMAT format;        char *inputfile1, *inputfile2, *outputfile;&nbsp;        setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;        print_CVIP(&quot;\\n\\tEnter the first Input File Name:  &quot;);        inputfile1 =(char *) getString_CVIP();        inputImage1 = read_Image(inputfile1, 1);        view_Image(inputImage1,inputfile1);        free(inputfile1);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the second Input File Name:  &quot;);        inputfile2 =(char *) getString_CVIP();        inputImage2 = read_Image(inputfile2, 1);        view_Image(inputImage2,inputfile2);        free(inputfile2);        outputImage = not_Image(inputImage1, inputImage2);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);        outputfile = getString_CVIP();        view_Image(outputImage,outputfile);        free(outputfile);&nbsp;      }&nbsp;SEE ALSO     ARITHLOGIC library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Jianxin     Tan.&nbsp;\n\r\n\r&nbsp;","not_Image","scr\\CVIP_C_functions/not_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T00:28:00Z  2004-10-20T00:09:00Z  1  359  2049  SIUE  17  4  2404  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     notch - performs a selective notch filter&nbsp;SYNOPSIS      #include &lt;CVIPmatrix.h&gt;      #include &lt;CVIPmap.h&gt;      #include &lt;CVIPxformfilter.h&gt;      #include &lt;string.h&gt;&nbsp;     Image*  notch(Image  *cvipImage,  char   *name,   NOTCH_ZONE     *zone,int number, CVIP_BOOLEAN interactive)&nbsp;      &lt;cvipImage&gt; - input image data      &lt;name&gt; - the name of the image      &lt;zone&gt; - a data structure containing information about                which part of the image  to remove      &lt;number&gt; - number of notches to perform (ignored if                 interactive = CVIP_YES)      &lt;interactive&gt; - ask for input from keyboard&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\notch.cDESCRIPTION     Notch is a function to  perform  selective  filtering  on  a     user-defined  area  of  an  image  or  spectrum. It is often     applied to frequency  domain  images  to  eliminate  regular     sinusoidal interference.&nbsp;TYPES AND CONSTANTS     NOTCH_ZONE *zone&nbsp;     typedef struct {             int x;             int y;             int radius;     } NOTCH_ZONE&nbsp;RETURN VALUES     Returns a notch-filtered image.&nbsp;EXAMPLE            #include &lt;CVIPtoolkit.h&gt;            #include &lt;CVIPimage.h&gt;            #include &lt;CVIPconvert.h&gt;            #include &lt;CVIPxformfilter.h&gt;            #include &lt;CVIPmap.h&gt;            #include &lt;string.h&gt;&nbsp;           void main()           {           Image *cvipImage;           IMAGE_FORMAT format;           char *inputfile, *outputfile;&nbsp;           setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;           print_CVIP(&quot;Enter the Input File Name:  &quot;);           inputfile =(char *) getString_CVIP();           format = getFormat_CVIP(inputfile);           cvipImage = read_Image(inputfile, 1);           view_Image(cvipImage, inputfile);           /* first do a transform */           cvipImage = fft_transform(cvipImage, 256)           cvipImage = (Image *)notch(cvipImage, inputfile,           NULL, NULL, CVIP_YES);           print_CVIP(&quot;Enter the Output File Name:  &quot;);           outputfile = getString_CVIP();           view_Image(cvipImage, outputfile);           write_Image(cvipImage, outputfile,CVIP_NO,CVIP_NO,           format, 1);           free(inputfile);           free(outputfile);           }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     CVIPxforfilter.h&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","notch","scr\\CVIP_C_functions/notch.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  2  1  2004-06-05T00:30:00Z  2004-06-09T20:38:00Z  1  358  2044  SIUE  17  4  2398  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     object_crop - Crops an object defind by a list of  surround-     ing coordinates.&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPgeometry.h&quot;      #include &lt;stdio.h&gt;&nbsp;     Image  *object_crop(Image  *imgP,  int   no_of_coords,   int     *rcList)&nbsp;      &lt;imgP&gt; - pointer to an Image structure      &lt;no_of_coords&gt; - the number  of  (row,col)  coordinates  in     rclist      &lt;rcList&gt; - pointer to  an  array  of  alternating  [0]=row,     [1]=col positions that create a pixel position in the image&nbsp;OPTIONS     None&nbsp;DESCRIPTION     This function was developed to take a coordinate  list  gen-     erated from the TclViewer by drawing objects on the image to     be cropped. To use this function out of  that  context  will     require an array of row then col positions to be stored in a     consecutive array.&nbsp;RETURN VALUES     The desired subimage&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPgeometry.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {&nbsp;      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      int *coordlist, coords[10];&nbsp;      coords[0] = 1;  coords[1] = 10; /* Pixel (1,10) */      coords[2] = 10; coords[3] = 1;  /* Pixel (10,1) */      coords[4] = 10; coords[4] = 20; /* Pixel (10,20) */      coordlist = coords;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call selects a subimage of size 10x10 from     location 10,10 of the original image */      cvipImage = object_crop(cvipImage,6, *coordlist);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;FILES          None&nbsp;BUGS     &lt;&gt;&nbsp;SEE ALSO      GEOMETRY library, crop(3)&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by  Scott  E.  Umbaugh  and  Craig     Pohl.&nbsp;\n\r\n\r&nbsp;","object_crop","scr\\CVIP_C_functions/object_crop.htm","   ACADEMIC COMPUTING  Normal  akharba  4  3  2004-06-05T00:34:00Z  2006-07-08T22:38:00Z  1  271  1548  SIUE  12  3  1816  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME     or_Image - performs logical OR of two images&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPmatrix.h&quot;      #include &quot;CVIParithlogic.h&quot;      #include &quot;CVIPdef.h&quot;           Image *or_Image(Image *inputImage1,Image *inputImage2)&nbsp;           &lt;inputImage1&gt; - pointer to an Image structure           &lt;inputImage2&gt; - pointer to an Image structure&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\ARITHLOGIC\\arithlogic.c&nbsp;DESCRIPTION     This function performs a bitwise OR of two  images.  Complex     data is NOT supported.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     An ORed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &quot;CVIPimage.h&quot;      #include &quot;CVIParithlogic.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;      void main() {        Image *inputImage1, *inputImage2, *outputImage;        IMAGE_FORMAT format;        char *inputfile1, *inputfile2, *outputfile;&nbsp;        setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;        print_CVIP(&quot;\\n\\tEnter the first Input File Name:  &quot;);        inputfile1 =(char *) getString_CVIP();        inputImage1 = read_Image(inputfile1, 1);        view_Image(inputImage1,inputfile1);        free(inputfile1);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the second Input File Name:  &quot;);        inputfile2 =(char *) getString_CVIP();        inputImage2 = read_Image(inputfile2, 1);        view_Image(inputImage2,inputfile2);        free(inputfile2);&nbsp;        outputImage = or_Image(inputImage1, inputImage2);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);        outputfile = getString_CVIP();        view_Image(outputImage,outputfile);        free(outputfile);&nbsp;      }&nbsp;SEE ALSO     ARITHLOGIC libraries&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh, Jainxin  Tan,     and Kun Luo.&nbsp;\n\r\n\r&nbsp;","or_Image","scr\\CVIP_C_functions/or_Image.htm","	   dduck  ACADEMIC COMPUTING  10  13  2004-10-19T23:01:00Z  2004-11-23T20:40:00Z  1  327  1870  SIUE  15  4  2193  10.3501    Clean                     MicrosoftInternetExplorer4    false  false  false         	NAME&nbsp;&nbsp;&nbsp;&nbsp; orientation - calculates axis of least second moment&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;math.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include \"ObjectContour.h\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double orientation(Image * labeledImage, int r, int c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;labeledImage&gt; -&nbsp; pointer to a labeled image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;r&gt; - row coordinate of a point on a labeled image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;c&gt; - column coordinate of a point on a labeled image&nbsp;PATH&nbsp;&nbsp;&nbsp;&nbsp; $CVIPtoolsHOME\\CVIPC\\FEATURE\\binary_feature.c&nbsp;DESCRIPTIONThe function calculates the axis of least second moment ofan object of interest on a labeled image. The origin is thecenter of area&nbsp; of that object and&nbsp; the&nbsp; angle&nbsp; is&nbsp; measuredfrom&nbsp; the&nbsp; r-axis&nbsp; counterclockwise. Equation of the axis is      &nbsp;&nbsp;&nbsp;&nbsp; TYPES AND CONSTANTS&nbsp;&nbsp;&nbsp;&nbsp; None&nbsp;RETURN VALUES&nbsp;&nbsp;&nbsp;&nbsp; A&nbsp; value&nbsp; of&nbsp; type&nbsp; double:&nbsp; axis&nbsp; of&nbsp; least&nbsp; second&nbsp; moment&nbsp;&nbsp;&nbsp;&nbsp; represented by a radian angle&nbsp;HISTORY&nbsp;&nbsp;&nbsp;&nbsp; History information recorded: None&nbsp;EXAMPLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;math.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include \"ObjectContour.h\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include \"CVIPconvert.h\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void main() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image *inputImage, *labeledImage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMAGE_FORMAT format;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *inputfile, *outputfile;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int rows, cols, r, c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double result;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setDisplay_Image(\"picture\", \"Default\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_CVIP(\"\\nEnter the Input File Name:&nbsp; \");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputfile = (char *) getString_CVIP();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputImage = read_Image(inputfile, 1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view_Image(inputImage,inputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labeledImage = label(inputImage);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = getNoOfRows_Image(labeledImage);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cols = getNoOfCols_Image(labeledImage);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_CVIP(\"\\nEnter the row coordinate of any&nbsp; pixel&nbsp; on&nbsp;&nbsp;&nbsp;&nbsp; the labled image: \");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = getInt_CVIP(10, 0, rows);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_CVIP(\"0nter the col coordinate of any pixel on the&nbsp;&nbsp;&nbsp;&nbsp; labled image: \");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = getInt_CVIP(10, 0, cols);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = orientation(labeledImage, r, c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_CVIP(\"The orientation of the object (r, c) =&nbsp; %f\",&nbsp;&nbsp;&nbsp;&nbsp; result );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_CVIP(\"\\n\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(inputfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;DIAGNOSTICS&nbsp;&nbsp;&nbsp;&nbsp; The labeled image can only of data type CVIP_INTEGER&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; FEATURE library&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1996, 2004 SIUE - by Scott E.&nbsp; Umbaugh&nbsp; and&nbsp; Wenxing&nbsp;&nbsp;&nbsp;&nbsp; Li.&nbsp;\n\r\n\r&nbsp;\n\r\n\r&nbsp;","orientation","scr\\CVIP_C_functions/orientation.htm","   Jhansi  Normal  jhansi  27  15  2004-06-04T23:27:00Z  2010-01-06T21:52:00Z  1  267  1528  SIUE  12  3  1792  11.9999    BestFit  Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME     otsu_segment - a histogram shape based segmentation technique. &nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPsegment.h&quot;&nbsp;      Image *otsu_segment(Image *imgP)&nbsp;      &lt;imgP&gt; - pointer to Image structure&nbsp;      PATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\otsu.c&nbsp;DESCRIPTION     Otsu method is used to automatically perform histogram shape      based thresholding. Otsu method works best with bimodal     histogram, a histogram with two major peaks. It assumes each      peak has a Gaussian shape and the peaks are fairly separated.     TYPES AND CONSTANTS     RETURN VALUES     Returns  Image  pointer  upon  successful  completion,   and     returns NULL on failure.&nbsp;EXAMPLE      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPsegment.h&quot;&nbsp;           void main()           {           Image *cvipImage;           IMAGE_FORMAT format;           char *inputfile, *outputfile;&nbsp;           setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;           print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);           inputfile =(char *) getString_CVIP();           format = getFormat_CVIP(inputfile);           cvipImage = read_Image(inputfile, 1);           view_Image(cvipImage, inputfile);           cvipImage = otsu_segment(cvipImage);           print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);           outputfile = getString_CVIP();           view_Image(cvipImage, outputfile);           write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);           free(inputfile);           free(outputfile);           }&nbsp;BUGS     None at this time&nbsp;SEE ALSO    SEGMENTATION library&nbsp;AUTHOR     Copyright (C) 2010, SIUE - by Scott Umbaugh and Jhansi Lakshmi Akkineni.&nbsp;\n\r\n\r&nbsp;","otsu_segment","scr\\CVIP_C_functions/otsu_segment.htm","   ACADEMIC COMPUTING  Normal  P!Nk  12  44  2009-12-04T16:51:00Z  2009-12-04T16:59:00Z  1  341  1946  SIUE  16  4  2283  12.00    120  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                              NAME      param_ad_filter – parametric anisotropic diffusion filter&nbsp;SYNOPSIS      #include &quot;CVIPImage.h&quot;&nbsp;      Image *param_ad_filter(Image *inputImage, int iteration_num, int speed, int edge_height, int block_size)&nbsp;      &lt;inputImage&gt; - pointer to Image structure      &lt;iteration_num&gt; - maximum number of complete iterations      &lt;speed&gt; - number of diffusion that is to be applied at each iteration      &lt;edge_height&gt; - minimum strength of edges that is to be preserved by the filter      &lt;block_size&gt; - size of blocks that is to be used during calculation of variancePATH      $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\param_ad_filter.c&nbsp;DESCRIPTION\n\r\n\r     Improvedversion of anisotropic diffusion filter. Parametric anisotropic diffusionfilter also iteratively removes noise from the &lt;inputImage&gt;, whilecalculating diffusion coefficient, in other words amount of diffusion, duringrun-time, at each iteration. Using the blocks whose size is specified by&lt;block_size&gt;, variance is calculated, and from there, the mosthomogeneous region is selected to calculate the diffusion coefficient.RETURN VALUES     Pointer to an Image structure on success and NULL pointer     on failure.BUGS     None at this time&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;&nbsp;      void main()      {      Image *inputImage;      Image *outputImage;      IMAGE_FORMAT format;      char *inputfile, *outputfile;              setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      inputImage = read_Image(inputfile, 1);      view_Image(inputImage, inputfile);      free(inputfile);\n\r\n\r      \n\r\n\r      outputImage = param_ad_filter(inputImage,20, 1, 5, 64);            print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(outputImage, outputfile);      write_Image(outputImage, outputfile, CVIP_NO, CVIP_NO, format, 1);      free(outputfile);&nbsp;      }&nbsp;SEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 2010 SIUE - by Scott Umbaugh and Serkan Kefel\n\r\n\r&nbsp;","param_ad_filter.htm","scr\\CVIP_C_functions/param_ad_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:36:00Z  2004-10-20T00:10:00Z  1  656  3744  SIUE  31  8  4392  10.3501    Clean                  MicrosoftInternetExplorer4 NAME     parametric_wiener - performs a parametric wiener filter&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtransform.h&quot;      #include &quot;CVIPxformfilter.h&quot;      #include &quot;CVIPdef.h&quot;&nbsp;     Image *parametric_wiener(Image *degr, Image *degr_fn,  Image     *p_noise,  Image  *p_orig, float gamma, int choice, int cut-     off)&nbsp;      &lt;degr&gt;    - pointer to the degraded image      &lt;degr_fn&gt; - pointer to the degradation function      &lt;p_noise&gt; - pointer to the noise power spectral density      &lt;p_orig&gt;  - pointer to the original  image  power  spectral     density      &lt;gamma&gt;   - \'gamma\' in the parametric wiener  filter  equa-     tion      &lt;choice&gt;  - sets the maximum gain using the DC value  as  a     baseline      &lt;cutoff&gt;  - cutoff frequency for filtering&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\restore_xformfilter.c&nbsp;DESCRIPTION     This function performs a parametric wiener filter.  See  any     image processing textbook for info on Wiener Filters.&nbsp;     The function does its own memory management, freeing  every-     thing  passed to it, so if you need your images intact, make     a copy of them before calling this function.&nbsp;     The function tries to determine whether an FFT has been per-     formed on the passed images.  If not, the function will per-     form the FFT.  This is especially important to note for  the     power  images.   If  the  power  images  are  in the spatial     domain, they will have an FFT performed on them, before  the     squared  magnitude  is calculated.  If an FFT is detected in     the history of any  of  the  power  images,  that  image  is     assumed  to  be  representing  a power image, and no squared     magnitude is calculated.&nbsp;     The function will also extend the sizes of the passed images     as best it can when they are of unequal size.&nbsp;     Also note that the passed images must have the  same  number     of (color) bands.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to the restored (filtered) image&nbsp;HISTORY     History information recorded:&nbsp;       parameter #1 = filter cutoff.       parameter #2 = method 1: F(u,v)=G(u,v) when H(u,v)=0                      method 2: F(u,v)=0 when H(u,v)=0&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;CVIPxformfilter.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage,*cvipImage1;      Image *cvipImage2,*cvipImage3;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      char *inputfile1,*inputfile2;&nbsp;      (void) setDisplay_Image(VIEWER,&quot;default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the File Name of the degraded      image:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call creates a gaussian mask of size      3  * 3 */      cvipImage1 = (Image *)h_image(3,3,3);      print_CVIP(&quot;\\n\\t\\tEnter the File Name of the original      power spectrum image:  &quot;);      inputfile1 =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile1);      cvipImage2 = read_Image(inputfile1,1);      view_Image(cvipImage2, inputfile1);      free(inputfile1);      print_CVIP(&quot;\\n\\t\\tEnter the File Name of the noise power      spectrum image:  &quot;);      inputfile2 =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile2);      cvipImage3 = read_Image(inputfile2,1);      view_Image(cvipImage3, inputfile2);      free(inputfile2);      /* the following call performs the parametric wiener      filter on the input image with the gaussian      mask and the cut off frequency equal to 32  */      cvipImage3=(Image *)parametric_wiener(cvipImage,      cvipImage1,cvipImage2,cvipImage3,.5,1,32);      cvipImage=(Image *)ifft_transform(cvipImage3,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Arve     Kjoelen.&nbsp;\n\r\n\r&nbsp;","parametric_wiener","scr\\CVIP_C_functions/parametric_wiener.htm","   ACADEMIC COMPUTING  Normal  akharba  3  5  2005-07-02T21:44:00Z  2006-07-08T22:26:00Z  1  332  1898  SIUE  15  4  2226  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        pattern_city_block – calculates the city block distance&nbsp;SYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;float.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;      #define MAX_CASE 128&nbsp;      int pattern_city_block(char *file_tt, char *file_tr, int *err_code)      &nbsp;&lt;file_tt&gt; - pointer to the test text file&lt;file_tr&gt; - pointer to the training text file&lt;err_code&gt; - pointer to the error code; if no error use 0&nbsp;&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\pattern_city_block.c&nbsp;DESCRIPTION     This function calculates the city block distance measure from     the elements of the two text files. The results are saved in a      temporary file named CVIPtemp. This temporary file can be found in the      system TEMP folder. The formula used for the calculation is      given in chapter 6 of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 128\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       char   *test,*training;\n\r\n\r&nbsp;\n\r\n\r       /* pattern_city_block will return numberof entries in training set */\n\r\n\r       int           no_of_entries_tr;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r       \n\r\n\r       /* Memory allocation */\n\r\n\r       test = malloc(MAX_CASE*sizeof(char));\n\r\n\r       training = malloc(MAX_CASE*sizeof(char));\n\r\n\r&nbsp;\n\r\n\r       /* Get the file names, and parameters. */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for testing set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, test);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for training set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, training);\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       no_of_entries_tr = pattern_city_block(test,training, err_code);\n\r\n\r       \n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free pointers */\n\r\n\r       free(test);\n\r\n\r       free(training);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Number of entries in the training set&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","pattern_city_block","scr\\CVIP_C_functions/pattern_city_block.htm","   ACADEMIC COMPUTING  Normal  akharba  6  10  2005-07-02T21:30:00Z  2006-07-08T22:26:00Z  1  331  1889  SIUE  15  4  2216  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        pattern_euclidean – calculates the euclidean distance&nbsp;SYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;float.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;      #define MAX_CASE 128&nbsp;int pattern_euclidean(char *file_tt, char *file_tr, int *err_code)      &nbsp;&lt;file_tt&gt; - pointer to the test text file&lt;file_tr&gt; - pointer to the training text file&lt;err_code&gt; - pointer to the error code; if no error use 0&nbsp;&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\pattern_euclidean.c&nbsp;DESCRIPTION     This function calculates the Euclidean distance measure from     the elements of the two text files. The results are saved in a      temporary file named CVIPtemp. This temporary file can be found in the      system TEMP folder. The formula used for the calculation is      given in chapter 6 of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLES\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 128\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       char   *test,*training;\n\r\n\r&nbsp;\n\r\n\r       /* pattern_euclidean will return numberof entries in training set */\n\r\n\r       int           no_of_entries_tr;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r       \n\r\n\r       /* Memory allocation */\n\r\n\r       test = malloc(MAX_CASE*sizeof(char));\n\r\n\r       training = malloc(MAX_CASE*sizeof(char));\n\r\n\r&nbsp;\n\r\n\r       /* Get the file names, and parameters. */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for testing set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, test);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for training  set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, training);\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       no_of_entries_tr =pattern_euclidean(test, training, err_code);\n\r\n\r       \n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free pointers */\n\r\n\r       free(test);\n\r\n\r       free(training);\n\r\n\r}\n\r\n\r&nbsp;\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Number of entries in the training set&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","pattern_euclidean","scr\\CVIP_C_functions/pattern_euclidean.htm","   ACADEMIC COMPUTING  Normal  akharba  3  3  2005-07-02T21:49:00Z  2006-07-08T22:26:00Z  1  329  1880  SIUE  15  4  2205  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        pattern_maximum – calculates the maximum value metric&nbsp;SYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;float.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;      #define MAX_CASE 128&nbsp;int pattern_maximum(char *file_tt, char *file_tr, int *err_code)&nbsp;&lt;file_tt&gt; - pointer to the test text file&lt;file_tr&gt; - pointer to the training text file&lt;err_code&gt; - pointer to the error code; if no error use 0&nbsp;&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\pattern_maximum.c&nbsp;DESCRIPTION     This function calculates the maximum value distance metric from     the elements of the two text files. The results are saved in a      temporary file named CVIPtemp. This temporary file can be found in the      system TEMP folder. The formula used for the calculation is      given in chapter 6 of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLES\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 128\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       char   *test,*training;\n\r\n\r&nbsp;\n\r\n\r       /* pattern_maximum will return number ofentries in training set */\n\r\n\r       int           no_of_entries_tr;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r       \n\r\n\r       /* Memory allocation */\n\r\n\r       test = malloc(MAX_CASE*sizeof(char));\n\r\n\r       training = malloc(MAX_CASE*sizeof(char));\n\r\n\r&nbsp;\n\r\n\r       /* Get the file names, and parameters. */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for testing set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, test);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for training  set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, training);\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       no_of_entries_tr = pattern_maximum(test,training, err_code);\n\r\n\r       \n\r\n\r       /* If err_code is not 0, print out the err_code*/\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free pointers */\n\r\n\r       free(test);\n\r\n\r       free(training);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Number of entries in the training set&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;\n\r\n\r&nbsp;","pattern_maximum","scr\\CVIP_C_functions/pattern_maximum.htm","   ACADEMIC COMPUTING  Normal  akharba  3  4  2005-07-02T22:21:00Z  2006-07-08T22:26:00Z  1  419  2391  SIUE  19  5  2805  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        pattern_min_max_normalization – uses the min-max normalization         method to normalize the training and test files&nbsp;SYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;float.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;&nbsp;#define MAX_CASE 128&nbsp;int *pattern_min_max_normalization(char *file_tr, char *file_tt,float s_min, float s_max, int *err_code)&nbsp;&lt;file_tr&gt; - pointer to the training text file&lt;file_tt&gt; - pointer to the test text file&lt;s_min&gt; - minimum value for the specified range&lt;s_max&gt; - maximum value for the specified range      &lt;err_code&gt; - pointer to the error code; use 0 for no error&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\pattern_min_max_normalization.c&nbsp;DESCRIPTION     This function uses the min-max normalization method to normalize     the training and test files. The formula used for min-max      normalization is given in chapter 6 of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 128\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       char   *test,*training;\n\r\n\r&nbsp;\n\r\n\r       /* Initialize the parameters */\n\r\n\r       float  s_min=2,s_max=5;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r       \n\r\n\r       /* Memory allocation */\n\r\n\r       test = malloc(MAX_CASE*sizeof(char));\n\r\n\r       training = malloc(MAX_CASE*sizeof(char));\n\r\n\r&nbsp;\n\r\n\r       /* Get the file names, and parameters. */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for testing set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, test);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for training  set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, training);\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       err_code = pattern_min_max_normalization(training,test, s_min, s_max, err_code);\n\r\n\r       \n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free pointers */\n\r\n\r       free(test);\n\r\n\r       free(training);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to the error code&nbsp; Error Codes:&nbsp;1: The headers in the training and test files don\'t match 2: K is greater than the number of entries in the training setor K&lt;=0 3: s_min is greater than or equal to s_max 4: Data range is 0 and so the data can\'t be normalized 5: Divisor is 0 in Tanimoto similarity measure 7: Can\'t open, read or create file 9: Memory allocation error 10: Every entry in training set should have a class name 12: r in minkowski should be a positive integer 13: There is more than one header in the training or test feature file  &nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.","pattern_min_max_normalization","scr\\CVIP_C_functions/pattern_min_max_normalization.htm","   ACADEMIC COMPUTING  Normal  akharba  3  3  2005-07-02T21:52:00Z  2006-07-08T22:27:00Z  1  339  1938  SIUE  16  4  2273  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        pattern_minkowski – calculates the minkowski distance measure&nbsp;SYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;float.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;      #define MAX_CASE 128&nbsp;int pattern_minkowski(char *file_tt, char *file_tr, int r_minkowski, int *err_code)&nbsp;&lt;file_tt&gt; - pointer to the test text file&lt;file_tr&gt; - pointer to the training text file&lt;r_minkowski&gt; - r is a positive integer&lt;err_code&gt; - pointer to the error code; if no error use 0&nbsp;&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\pattern_minkowski.c&nbsp;DESCRIPTION     This function calculates the minkowski distance metric from     the elements of the two text files. The results are saved in a      temporary file named CVIPtemp. This temporary file can be found in the      system TEMP folder. The formula used for the calculation is      given in chapter 6 of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLES\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 128\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       char   *test,*training;\n\r\n\r&nbsp;\n\r\n\r       /* pattern_minkowski will return numberof entries in training set */\n\r\n\r       int           no_of_entries_tr;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r       \n\r\n\r       /* Memory allocation */\n\r\n\r       test = malloc(MAX_CASE*sizeof(char));\n\r\n\r       training = malloc(MAX_CASE*sizeof(char));\n\r\n\r&nbsp;\n\r\n\r       /* Get the file names, and parameters. */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for testing set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, test);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for training  set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, training);\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       no_of_entries_tr = pattern_minkowski(test,training, err_code);\n\r\n\r       \n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free pointers */\n\r\n\r       free(test);\n\r\n\r       free(training);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Number of entries in the training set&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","pattern_minkowski","scr\\CVIP_C_functions/pattern_minkowski.htm","   ACADEMIC COMPUTING  Normal  akharba  3  8  2005-07-02T22:03:00Z  2006-07-08T22:27:00Z  1  378  2160  SIUE  18  5  2533  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        pattern_range_normalize – range normalizes the training                                   and test filesSYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;float.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;      #define MAX_CASE 128&nbsp;int *pattern_range_normalize(char *file_tr, char *file_tt, int *err_code)      &nbsp;&lt;file_tr&gt; - pointer to the training text file&lt;file_tt&gt; - pointer to the test text file      &lt;err_code&gt; - pointer to the error code; use 0 for no error&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\pattern_range_normalize.c&nbsp;DESCRIPTION     This function range normalizes the training and test files.     The formula used for range normalization is given in chapter 6      of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 128\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       char   *test,*training;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r       \n\r\n\r       /* Memory allocation */\n\r\n\r       test = malloc(MAX_CASE*sizeof(char));\n\r\n\r       training = malloc(MAX_CASE*sizeof(char));\n\r\n\r&nbsp;\n\r\n\r       /* Get the file names, and parameters. */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for testing set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, test);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for training  set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, training);\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       err_code = pattern_range_normalize(training,test, err_code);\n\r\n\r       \n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free pointers */\n\r\n\r       free(test);\n\r\n\r       free(training);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to the error code&nbsp; Error Codes:&nbsp;1: The headers in the training and test files don\'t match 2: K is greater than the number of entries in the training setor K&lt;=0 3: s_min is greater than or equal to s_max 4: Data range is 0 and so the data can\'t be normalized 5: Divisor is 0 in Tanimoto similarity measure 7: Can\'t open, read or create file 9: Memory allocation error 10: Every entry in training set should have a class name 12: r in minkowski should be a positive integer 13: There is more than one header in the training or test feature file  &nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","pattern_range_normailze","scr\\CVIP_C_functions/pattern_range_normalize.htm","   ACADEMIC COMPUTING  Normal  akharba  3  4  2005-07-02T22:26:00Z  2006-07-08T22:27:00Z  1  412  2355  SIUE  19  5  2762  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        pattern_softmax_scaling_normalization – uses the softmax scaling         method to normalize the training and test files&nbsp;SYNOPSIS&nbsp;#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;float.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;      #define MAX_CASE 128&nbsp;int *pattern_softmax_scaling_normalization(char *file_tr, char *file_tt, float r_softmax, int *err_code)&nbsp;&lt;file_tr&gt; - pointer to the training text file&lt;file_tt&gt; - pointer to the test text file&lt;r_softmax&gt; - parameter used for softmax scaling      &lt;err_code&gt; - pointer to the error code; use 0 for no error&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\pattern_softmax_scaling_normalization.c&nbsp;DESCRIPTION     This function uses the softmax scaling method to normalize     the training and test files. The formula used for softmax      scaling is given in chapter 6 of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 128\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       char   *test,*training;\n\r\n\r&nbsp;\n\r\n\r/* Initialize the parameters */\n\r\n\r       float  r_softmax=2;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r       \n\r\n\r       /* Memory allocation */\n\r\n\r       test = malloc(MAX_CASE*sizeof(char));\n\r\n\r       training = malloc(MAX_CASE*sizeof(char));\n\r\n\r&nbsp;\n\r\n\r       /* Get the file names, and parameters. */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for testing set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, test);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for training  set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, training);\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       err_code =pattern_softmax_scaling_normalization(training, test, r_softmax, err_code);\n\r\n\r       \n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free pointers */\n\r\n\r       free(test);\n\r\n\r       free(training);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to the error code&nbsp; Error Codes:&nbsp;1: The headers in the training and test files don\'t match 2: K is greater than the number of entries in the training setor K&lt;=0 3: s_min is greater than or equal to s_max 4: Data range is 0 and so the data can\'t be normalized 5: Divisor is 0 in Tanimoto similarity measure 7: Can\'t open, read or create file 9: Memory allocation error 10: Every entry in training set should have a class name 12: r in minkowski should be a positive integer 13: There is more than one header in the training or test feature file  &nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;\n\r\n\r&nbsp;","pattern_softmax_scaling_normalization","scr\\CVIP_C_functions/pattern_softmax_scaling_normalization.htm","   ACADEMIC COMPUTING  Normal  akharba  7  6  2005-07-02T22:14:00Z  2006-07-08T22:27:00Z  1  407  2321  SIUE  19  5  2723  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        pattern_standard_normal_density_normalization – uses the standard         normal density method to normalize the training and test filesSYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;float.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;      #define MAX_CASE 128&nbsp;int * pattern_standard_normal_density_normalization (char *file_tr, char *file_tt, int *err_code)      &nbsp;&lt;file_tr&gt; - pointer to the training text file&lt;file_tt&gt; - pointer to the test text file      &lt;err_code&gt; - pointer to the error code; use 0 for no error&nbsp;&nbsp;PATH$CVIPtoolsHOME\\CVIPC\\FEATURE\\pattern_standard_normal_density_normalization.c&nbsp;DESCRIPTION     This function uses the standard normal density normalization method to      normalize the training and test files. The formula used for standard      normal density normalization is given in chapter 6 of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 128\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       char   *test,*training;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r       \n\r\n\r       /* Memory allocation */\n\r\n\r       test = malloc(MAX_CASE*sizeof(char));\n\r\n\r       training = malloc(MAX_CASE*sizeof(char));\n\r\n\r&nbsp;\n\r\n\r       /* Get the file names, and parameters. */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for testing set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, test);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for training  set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, training);\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       err_code =pattern_standard_normal_density_normalization(training, test, err_code);\n\r\n\r       \n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free pointers */\n\r\n\r       free(test);\n\r\n\r       free(training);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to the error code&nbsp; Error Codes:&nbsp;1: The headers in the training and test files don\'t match 2: K is greater than the number of entries in the training setor K&lt;=0 3: s_min is greater than or equal to s_max 4: Data range is 0 and so the data can\'t be normalized 5: Divisor is 0 in Tanimoto similarity measure 7: Can\'t open, read or create file 9: Memory allocation error 10: Every entry in training set should have a class name 12: r in minkowski should be a positive integer 13: There is more than one header in the training or test feature file  &nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;\n\r\n\r&nbsp;","pattern_standard_normal_density_normailzation","scr\\CVIP_C_functions/pattern_standard_normal_density_normalization.htm","   ACADEMIC COMPUTING  Normal  akharba  3  4  2005-07-02T22:32:00Z  2006-07-08T22:28:00Z  1  330  1887  SIUE  15  4  2213  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        pattern_tanimoto – calculates the tanimoto similarity measure&nbsp;SYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;float.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;      #define MAX_CASE 128&nbsp;int pattern_tanimoto(char *file_tt, char *file_tr, int *err_code)&nbsp;&lt;file_tt&gt; - pointer to the test text file&lt;file_tr&gt; - pointer to the training text file&lt;err_code&gt; - pointer to the error code; if no error use 0&nbsp;&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\pattern_tanimoto.c&nbsp;DESCRIPTION     This function calculates the tanimoto similarity measure from     the elements of the two text files. The results are saved in a      temporary file named CVIPtemp. This temporary file can be found in the      system TEMP folder. The formula used for the calculation is      given in chapter 6 of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 128\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       char   *test,*training;\n\r\n\r&nbsp;\n\r\n\r       /* pattern_tanimoto will return number ofentries in training set */\n\r\n\r       int           no_of_entries_tr;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r       \n\r\n\r       /* Memory allocation */\n\r\n\r       test = malloc(MAX_CASE*sizeof(char));\n\r\n\r       training = malloc(MAX_CASE*sizeof(char));\n\r\n\r&nbsp;\n\r\n\r       /* Get the file names, and parameters. */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for testing set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, test);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for training  set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, training);\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       no_of_entries_tr = pattern_tanimoto(test,training, err_code);\n\r\n\r       \n\r\n\r       /* If err_code is not 0, print out the err_code*/\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free pointers */\n\r\n\r       free(test);\n\r\n\r       free(training);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Number of entries in the training set&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","pattern_tanimoto","scr\\CVIP_C_functions/pattern_tanimoto.htm","   ACADEMIC COMPUTING  Normal  akharba  11  3  2005-07-02T22:12:00Z  2006-07-08T22:28:00Z  1  394  2246  SIUE  18  5  2635  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        pattern_unit_vector_normalization – uses the unit vector normalization         method to normalize the training and test files&nbsp;SYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;float.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;      #define MAX_CASE 128&nbsp;int * pattern_unit_vector_normalization (char *file_tr, char *file_tt, int *err_code)      &nbsp;&lt;file_tr&gt; - pointer to the training text file&lt;file_tt&gt; - pointer to the test text file      &lt;err_code&gt; - pointer to the error code; use 0 for no error&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\pattern_unit_vector_normalization.c&nbsp;DESCRIPTION     This function unit vector normalizes the training and test files.     The formula used for unit vector normalization is given in chapter 6      of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 128\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       char   *test,*training;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r       \n\r\n\r       /* Memory allocation */\n\r\n\r       test = malloc(MAX_CASE*sizeof(char));\n\r\n\r       training = malloc(MAX_CASE*sizeof(char));\n\r\n\r&nbsp;\n\r\n\r       /* Get the file names, and parameters. */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for testing set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, test);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for training  set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, training);\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       err_code =pattern_unit_vector_normalization(training, test, err_code);\n\r\n\r       \n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free pointers */\n\r\n\r       free(test);\n\r\n\r       free(training);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES         A pointer to the error code  Error Codes:  1: The headers in the training and test files don\'t match  2: K is greater than the number of entries in the training setor K&lt;=0  3: s_min is greater than or equal to s_max  4: Data range is 0 and so the data can\'t be normalized  5: Divisor is 0 in Tanimoto similarity measure  7: Can\'t open, read or create file  9: Memory allocation error  10: Every entry in training set should have a class name  12: r in minkowski should be a positive integer  13: There is more than one header in the training or test feature file &nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","pattern_unit_vector_normalization","scr\\CVIP_C_functions/pattern_unit_vector_normalization.htm","   ACADEMIC COMPUTING  Normal  akharba  4  3  2005-07-02T21:56:00Z  2006-07-08T22:28:00Z  1  349  1993  SIUE  16  4  2338  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        pattern_vector_inner_product – calculates the vector inner                                        product similarity measure&nbsp;SYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;float.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot;      #define MAX_CASE 128&nbsp;int pattern_vector_inner_product(char *file_tt, char *file_tr, int *err_code)&nbsp;&lt;file_tt&gt; - pointer to the test text file&lt;file_tr&gt; - pointer to the training text file&lt;err_code&gt; - pointer to the error code; if no error use 0&nbsp;&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\pattern_vector_inner_product.c&nbsp;DESCRIPTION     This function calculates the vector inner product similarity measure from     the elements of the two text files. The results are saved in a      temporary file named CVIPtemp. This temporary file can be found in the      system TEMP folder. The formula used for the calculation is      given in chapter 6 of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 128\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       char   *test,*training;\n\r\n\r&nbsp;\n\r\n\r       /* pattern_vector_inner_product willreturn number of entries in training set */\n\r\n\r       int           no_of_entries_tr;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r       \n\r\n\r       /* Memory allocation */\n\r\n\r       test = malloc(MAX_CASE*sizeof(char));\n\r\n\r       training = malloc(MAX_CASE*sizeof(char));\n\r\n\r&nbsp;\n\r\n\r       /* Get the file names, and parameters. */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for testing set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, test);\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in thefile name for training  set: &quot;);\n\r\n\r       scanf(&quot;%s&quot;, training);\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       no_of_entries_tr =pattern_vector_inner_product(test, training, err_code);\n\r\n\r       \n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free pointers */\n\r\n\r       free(test);\n\r\n\r       free(training);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Number of entries in the training set&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;\n\r\n\r&nbsp;","pattern_vector_inner_product","scr\\CVIP_C_functions/pattern_vector_inner_product.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T00:37:00Z  2004-10-20T00:10:00Z  1  401  2289  SIUE  19  5  2685  10.3501    Clean                  MicrosoftInternetExplorer4 NAME     pct - performs the principal components transform.&nbsp;SYNOPSIS      #include &lt;pct.h&gt;&nbsp;      &nbsp;     Image *pct(Image *imgP, CVIP_BOOLEAN is_mask, float *maskP)&nbsp;      &lt;imgP&gt; -  pointer to Image structure      &lt;is_mask&gt; - whether to ignore a background color  (CVIP_YES     or CVIP_NO)      &lt;maskP&gt; - background color to ignore&nbsp;     Image *ipct(Image *imgP, CVIP_BOOLEAN is_mask, float *maskP)&nbsp;      &lt;imgP&gt; -  pointer to Image structure      &lt;is_mask&gt; - whether to ignore a background color  (CVIP_YES     or CVIP_NO)      &lt;maskP&gt; - background color to ignore&nbsp;     Image *pct_color(Image *imgP,  CVIP_BOOLEAN  is_mask,  float     *maskP, int choice)&nbsp;      &lt;imgP&gt; -  pointer to Image structure      &lt;is_mask&gt; - whether to ignore a background color  (CVIP_YES     or CVIP_NO)      &lt;maskP&gt; - background color to ignore      &lt;choice&gt; - 1=perform PCT, 2=perform IPCT&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COLOR\\pct.c&nbsp;DESCRIPTION     Performs  the  prinicipal  components  transform  (PCT)   on     &lt;srcImage&gt;.   The resultant image contains a set of decorre-     lated data bands  in  which  the  first  band  is  the  most     discriminant, then the second band, and so on.&nbsp;TYPES AND CONSTANTS     -&nbsp;RETURN VALUES     Pointer to transformed image of type float&nbsp;HISTORY     History information recorded: 9 variables, each  an  element     of the transformation matrix&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPcomplex.h&gt;      #include &lt;CVIPcolor.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      /* The input image should be a COLOR one */      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the forward  principal  com-     ponent      transform and the background color is not ignored */      cvipImage=pct_color(cvipImage,CVIP_NO,NULL,1);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     COLOR library&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Greg Hance.&nbsp;\n\r\n\r&nbsp;","pct","scr\\CVIP_C_functions/pct.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:38:00Z  2004-10-20T00:11:00Z  1  347  1979  SIUE  16  4  2322  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     pct_median_segment -  a  segmentation  algorithm  for  color     images based on PCT and median_cut&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPsegment.h&quot;&nbsp;     Image  *pct_median_segment(Image *imgP, unsigned colors)&nbsp;      &lt;impP&gt; - pointer to Image structure      &lt;colors&gt; - desired number of colors&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\pct_median.cDESCRIPTION     This function is based on the Principal Components Transform     (PCT)  and  median_cut  algorithms.  The PCT aligns the main     axis along the maximum variance path in  the  data  set,  so     that  most  of  the color information lies along a principal     axis.  Following that, the median split part  of  the  algo-     rithm  divides  the image into the desired number of colors.     Finally, the inverse PCT will transform the resulting  image     back to the RGB color space.&nbsp;     This algorithm applies to color image only. However, it  can     also  be used on grayscale images through the extract_band()     and assemble_bands() functions.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     An Image pointer upon success; a NULL pointer upon failure&nbsp;EXAMPLE      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPsegment.h&quot;&nbsp;      void main()      {        Image  *cvipImage;        IMAGE_FORMAT   format;        char  *inputfile, *outputfile;        unsigned newcolors;&nbsp;        setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);        print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);        inputfile =(char *) getString_CVIP();        format = getFormat_CVIP(inputfile);        cvipImage = read_Image(inputfile, 1);        view_Image(cvipImage, inputfile);        print_CVIP(&quot;\\nEnter the number of desired colors:&quot;);        newcolors = getUInt_CVIP(10, 2, 1000);        cvipImage = pct_median_segment(cvipImage, newcolors);        print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);        outputfile = getString_CVIP();        view_Image(cvipImage, outputfile);        write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);        free(inputfile);        free(outputfile);      }&nbsp;BUGS     NONE&nbsp;SEE ALSO     SEGMENTATION library, median_cut_segment, pct&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Yansheng Wei.&nbsp;\n\r\n\r&nbsp;","pct_median_segment","scr\\CVIP_C_functions/pct_median_segment.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:39:00Z  2004-10-20T00:11:00Z  1  419  2390  SIUE  19  5  2804  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     perimeter - calculates a binary object\'s perimeter&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;&nbsp;     int perimeter(Image * labeledImage, int r, int c)&nbsp;      &lt;labeledImage&gt; -  pointer to a labeled image      &lt; r &gt; - row coordinate of a point on the labled image      &lt; c &gt; - column coordinate of a point on the labled image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\binary_feature.c&nbsp;DESCRIPTION     We define the perimeter of an object to be the length of the     outer edge of the object. This function first finds the max-     imum and minimum values of the object of interest\'s row  and     column. The length of the outer edge is then found by build-     ing   chain   code   for   that   object   using    function     build_ChainCode(). Chain code is a representation of a boun-     dary as a connected sequence of  straight-line  segments  of     specified  length  and  direction.  In build_ChainCode(), 8-     connectivity of the segments is used, and the length of  the     straight-line  segments  is the  distance between two neigh-     boring pixels. By building chain code for  the  object,  the     number  of  pixels  on the outer edge of the object is found     and that is the perimeter of the object.&nbsp;     The   function   build_ChainCode()   can   be    found    in     $CVIPHOME/Object/ObjectContour.c.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A value of type int: perimeter of the object&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;      void main() {         Image *inputImage, *labeledImage;         IMAGE_FORMAT format;         char *inputfile, *outputfile;         int rows, cols, r, c;         int result;&nbsp;         setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;         print_CVIP(&quot;\\nEnter the Input File Name:  &quot;);         inputfile = (char *) getString_CVIP();         inputImage = read_Image(inputfile, 1);         view_Image(inputImage,inputfile);&nbsp;         labeledImage = label(inputImage);&nbsp;         rows = getNoOfRows_Image(labeledImage);         cols = getNoOfCols_Image(labeledImage);&nbsp;         print_CVIP(&quot;\\nEnter the row coordinate of any  pixel  on     the labled image: &quot;);         r = getInt_CVIP(10, 0, rows);         print_CVIP(&quot;\\nEnter the col coordinate of any  pixel  on     the labled image: &quot;);         c = getInt_CVIP(10, 0, cols);&nbsp;         result = perimeter(labeledImage, r, c);         print_CVIP(&quot;The perimeter of the object (r,  c)  =  %d&quot;,     result );         print_CVIP(&quot;\\n&quot;);&nbsp;         free(inputfile);       }&nbsp;DIAGNOSTICS     The labeled image can only of data type CVIP_INTEGER&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","perimeter","scr\\CVIP_C_functions/perimeter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:40:00Z  2004-10-20T00:11:00Z  1  635  3626  SIUE  30  8  4253  10.3501                    MicrosoftInternetExplorer4 NAME     power_spect_eq - performs wiener filtering&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtransform.h&quot;      #include &quot;CVIPxformfilter.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIParithlogic.h&quot;&nbsp;     Image *power_spect_eq(Image  *degr,  Image  *degr_fn,  Image     *p_noise, Image *p_orig, int choice, int cutoff)&nbsp;      &lt;degr&gt;    - pointer to the degraded image      &lt;degr_fn&gt; - pointer to the degradation function      &lt;p_noise&gt; - pointer to the noise power spectral density      &lt;p_orig&gt;  - pointer to the original  image  power  spectral     density      &lt;choice&gt;  - sets the maximum gain using the DC value  as  a     baseline      &lt;cutoff&gt;  - cutoff frequency for filtering&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\restore_xformfilter.c&nbsp;DESCRIPTION     This function performs a power spectrum equalization filter.     The  function does its own memory management, freeing every-     thing passed to it, so if you need your images intact,  make     a copy of them before calling this function.&nbsp;     The function tries to determine whether an FFT has been per-     formed on the passed images.  If not, the function will per-     form the FFT.  This is especially important to note for  the     power  images.   If  the  power  images  are  in the spatial     domain, they will have an FFT performed on them, before  the     squared  magnitude  is calculated.  If an FFT is detected in     the history of any  of  the  power  images,  that  image  is     assumed  to  be  representing  a power image, and no squared     magnitude is calculated.&nbsp;     The function will also extend the sizes of the passed images     as best it can when they are of unequal size.&nbsp;     Also note that the passed images must have the  same  number     of (color) bands.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to the restored (filtered) image&nbsp;HISTORY     History information recorded:&nbsp;       parameter #1 = filter cutoff.       parameter #2 = method 1: F(u,v)=G(u,v) when H(u,v)=0                      method 2: F(u,v)=0 when H(u,v)=0&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;CVIPxformfilter.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage,*cvipImage1;      Image *cvipImage2,*cvipImage3;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      char *inputfile1,*inputfile2;&nbsp;      (void) setDisplay_Image(VIEWER,&quot;default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the File Name of the degraded      image:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call creates a gaussian mask of size      3  * 3 */      cvipImage1 = (Image *)h_image(3,3,3);      print_CVIP(&quot;\\n\\t\\tEnter the File Name of the original power      spectrum image:  &quot;);      inputfile1 =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile1);      cvipImage2 = read_Image(inputfile1,1);      view_Image(cvipImage2, inputfile1);      free(inputfile1);      print_CVIP(&quot;\\n\\t\\tEnter the File Name of the noise power      spectrum image:  &quot;);      inputfile2 =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile2);      cvipImage3 = read_Image(inputfile2,1);      view_Image(cvipImage3, inputfile2);      free(inputfile2);      /* the following call performs the power spectrum      equalisation on the input image with the gaussian mask      and the cut off frequency equal to 32  */      cvipImage3=(Image *)power_spect_eq(cvipImage,cvipImage1,      cvipImage2, cvipImage3,1,32);      cvipImage=(Image *)ifft_transform(cvipImage3,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Arve     Kjoelen.&nbsp;\n\r\n\r&nbsp;","power_spect_eq","scr\\CVIP_C_functions/power_spect_eq.htm","   ACADEMIC COMPUTING  skefel  9  12  2004-07-03T23:09:00Z  2010-05-11T17:38:00Z  2  222  1269  SIUE  10  2  1489  12.00    200  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                              NAMEpratt_merit– calculates the Pratt’s figure of merit.&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPspfltr.h&gt;&nbsp;     float *(Image *inputImage1, Image *inputImage2, float a)&nbsp;&lt;inputImage1&gt; - pointer to the ideal edge image structure            &lt;inputImage2&gt; - pointer to the output edge image structure                from the edge detection operation                  &lt;a&gt; - Scaling constant that can be adjusted to adjust the             penalty for offset edges.&nbsp;&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\pratt_merit.c&nbsp;DESCRIPTION   The Pratt Figure Of Merit will be 1 for a perfect edge. Normalizing tothe maximum of the ideal and found edge points guarantees a penalty for smeared edges or missing edge points. In general, this metric assigns a better rating to smeared edges than to offset or missing edges. This is done because techniques exist to thin smeared edges, but it is difficult to determine when an edge is missed. The distance, d, can be defined in more than one way and typically depends on the connectivity definition used.TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Returns the Pratt’s Figure of Merit. If input image has multiple bands, it returns the average Pratt’s Figure of Merit of all bands.&nbsp;HISTORY     History information recorded: NoneSEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 2004 SIUE - by Scott Umbaugh.\n\r\n\r&nbsp;","pratt_merit","scr\\CVIP_C_functions/pratt_merit.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T00:41:00Z  2004-10-20T00:11:00Z  1  225  1284  SIUE  10  3  1506  10.3501    Clean                  MicrosoftInternetExplorer4 NAME     predicate_test  -  function  used  to   set   criteria   for     split_merge_generic routine&nbsp;SYNOPSIS      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;split_merge.h&quot;      #include &quot;CVIPtexture.h&quot;&nbsp;     static  CVIP_BOOLEAN  predicate_test(Image  *srcImage,  QUAD     *quadROI, void *paramP)&nbsp;      &lt;srcImage&gt; - pointer to Image structure      &lt;quadROI&gt; - pointer to QUAD structure      &lt;paramP&gt; - pointer to any other parameters needed                 (in this case an array containing the                  global mean of each data band)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\split_merge.c&nbsp;DESCRIPTION     An example  predicate  test  module  to  be  used  with  the     split_merge_generic(...)  routine. This predicate test func-     tion will return a value of CVIP_YES if the  region  pointed     to  by  &lt;quadROI&gt;  is  completely uniform, and will return a     value of CVIP_NO if the region exhibits any form of  nonuni-     formity&nbsp;     There are currently six  predicate  test  routines  provided     with  split_merge_segment. mean_test gives an example of the     function prototype for these routines.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     CVIP_YES or CVIP_NO.&nbsp;BUGS     None at this time&nbsp;SEE ALSO    SEGMENTATION library,    split_merge_generic,     split_merge_segment,     quadtree2ras, mean_test&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Greg Hance.&nbsp;\n\r\n\r&nbsp;","predicate_test","scr\\CVIP_C_functions/predicate_test.htm","   Hari  Normal  jhansi  43  170  2009-09-17T22:08:00Z  2010-01-06T21:49:00Z  1  476  2714  SIUE  22  6  3184  11.9999    140  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                                                                  NAME     prewitt_filter - perform prewitt edge detection&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPfs.h&quot;      #include &lt;limits.h&gt;&nbsp;     Image *prewitt_filter(Image *inputImage,  Image *dirImage,         int mask_choice,  int mask_size, int keep_dc, int threshold)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;dirImage&gt; - pointer to direction Image      &lt;mask_choice&gt; - type of smoothing filter      &lt;mask_size&gt; - kernel size      &lt;keep_dc&gt; - 0 (no) or 1 (yes)      &lt;threshold&gt; - value for binary threshold&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\prewitt_filter.c&nbsp;DESCRIPTION     This function applies prewitt edge detection algorithm to     &lt;inputImage&gt;, and returns magnitude image, but for direction image,      a blank image is created using new_Image and is passed to      the function as direction image. After the function is     called direction image can be then viewed using view_Image     function. Data range of output direction image is -pi to +pi.     If a smoothing filter is desired as a preprocessing step,     set &lt;mask_choice&gt; to:                       1 = Gaussian blur                       2 = generic lowpass 1                       3 = generic lowpass 2                       4 = neighborhood average&nbsp;     For &lt;mask_size&gt;: Set mask_size to desired kernel size     For &lt;dirImage&gt; : direction image.&nbsp;     NOTE: for the parameters, mask_choice, mask_size, keepdc,      threshold, use the value -1 for any parameter not needed. &nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A prewitt edge-detected magnitude image and direction image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPfs.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *inputImage, *dirImage;      Image *outImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile,*outputfile1;              print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      inputImage = read_Image(inputfile, 1);      view_Image(inputImage, inputfile);      free(inputfile);\n\r\n\r      \n\r\n\r      dirImage =new_Image(inputImage-&gt;image_format, \n\r\n\r      inputImage-&gt;color_space,inputImage-&gt;bands, getNoOfRows_Image(inputImage), \n\r\n\r      getNoOfCols_Image(inputImage),CVIP_FLOAT, REAL);\n\r\n\r&nbsp;\n\r\n\r      outImage=prewitt_filter(inputImage,dirImage, -1, -1, -1, -1);            print_CVIP(&quot;\\n\\t\\tEnter the Output File Name of magnitude Image:  &quot;);      outputfile = getString_CVIP();      print_CVIP(“\\n\\t\\tEnter the Output File Name of direction Image: “);      outputfile1 = getString_CVIP();      view_Image(outImage,outputfile);      view_Image(dirImage, outputfile1);      delete_Image(outImage);      delete_Image(dirImage);      delete_Image(inputImage);      free(outputfile);      free(outputfile1);      }&nbsp;SEE ALSO    SPATIALFILTER library      &nbsp;AUTHOR     Copyright (C) 2010, SIUE - by Scott Umbaugh, and Hari Krishna Akkineni. &nbsp;\n\r\n\r&nbsp;","prewitt_filter","scr\\CVIP_C_functions/prewitt_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-05T00:42:00Z  2004-10-20T00:11:00Z  1  203  1159  SIUE  9  2  1360  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     print_mesh - print the data  of  a  mesh  structure  to  the     screen&nbsp;SYNOPSIS     #include &quot;mesh.h&quot; int print_mesh(struct mesh *inmesh);&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\warp.cDESCRIPTION     The print_mesh() print the coordinates of each node  in  the     mesh  structure pointed to by &quot;inmesh&quot; node by node from the     left to the right and row by row from the top to the bottom.&nbsp;TYPES AND CONSTANTS     struct mesh_node {          int x;          int y;     };&nbsp;     struct mesh {          int width;          int height;          struct mesh_node** nodes;     };&nbsp;     struct float_pair {          float x;          float y;     };     (e.g.)     typedef ... newval;     #define AVAL ...     extern newval that;&nbsp;RETURN VALUES     The print_mesh() returns 1 when succeeded and 0 when failed.&nbsp;EXAMPLE     #include &quot;mesh.h&quot; #include &lt;CVIPio.h&gt;&nbsp;     void main() {          char           *inputfile;          struct mesh    *inmesh;&nbsp;          print_CVIP(&quot;0Input the mesh file name: &quot;);          inputfile = getString_CVIP();          inmesh = file_to_mesh(inputfile);          print_mesh(inmesh); }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     file_to_mesh(),     keyboard_to_mesh(),      mesh_to_file(),     display_mesh();&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Jianxin Tan.&nbsp;\n\r\n\r&nbsp;","print_mesh","scr\\CVIP_C_functions/print_mesh.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  2  2  2004-06-05T00:43:00Z  2004-06-09T20:46:00Z  1  121  696  SIUE  5  1  816  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     prog - &lt;a brief description of the function&gt;&nbsp;SYNOPSIS     &lt;command usage&gt;&nbsp;PATH     &lt;provide path to this code, relative to $CVIPtoolsHOME/&gt;&nbsp;DESCRIPTION     &lt;Longer, detailed explanations&gt;&nbsp;TYPES AND CONSTANTS     &lt;list any types or constants defined in library&gt;     &lt;for example:     typedef ... newval;     #define AVAL ...     extern newval that; &gt;&nbsp;RETURN VALUES     &lt;description of values returned&gt;&nbsp;HISTORY     History information recorded: None&nbsp;BUGS     &lt;this section is optional, keep it when applicable&gt;&nbsp;EXAMPLE     &lt;add a complete example of the function usage here&gt;&nbsp;SEE ALSO     &lt;the library name, other related function names here, e.g.,      GEOMETRY library, resize(3), crop(3) &gt;&nbsp;AUTHOR     Copyright (C) 1996 SIUE - by Scott E. Umbaugh and YOUR  NAME     or WHOEVER .&nbsp;\n\r\n\r&nbsp;","prog","scr\\CVIP_C_functions/prog.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  3  2004-06-05T00:44:00Z  2004-10-20T00:12:00Z  1  497  2838  SIUE  23  6  3329  10.3501    Clean                  MicrosoftInternetExplorer4 NAME     projection - calculates horizontal and vertical  projections     of a size_normalized object of interest&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPimage.h&quot;&nbsp;     int * projection(Image * labeledImage, int  r,  int  c,  int     height, int width)&nbsp;      &lt;labeledImage&gt; -  pointer to a labeled image      &lt;r&gt; - row coordinate of a point on the labeled image      &lt;c&gt; - column coordinate of a point on the labeled image      &lt;height&gt; - image height after the  object  of  interest  is     normalized      &lt;width&gt;  - image width after the object of interest is nor-     malized&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\size_norm_projection.cDESCRIPTION     This function calculates the horizontal and vertical projec-     tions  of  a  binary  object.  The  object is first grown or     shrunk (as required) to fit in the box  of  &lt;height&gt;  height     and &lt;width&gt; width. Zero-order hold is used to grow; deleting     every other line (decimation) is used to shrink. The  object     is grown (or shrunk), until it just fits within the box. The     growing or shrinking is the same  in  both  dimensions.  The     function then calculates horizontal and vertical projections     on this size_normalized object according to equations  given     in chapter 3 of Computer Imaging, by Scott Umbaugh.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to int, first &lt;height&gt; values are  for  horizontal     projections, following &lt;width&gt; data are for vertical projec-     tions. Zero values are not filtered out.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;      #include &quot;CVIPfeatures.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;      void main() {         Image *inputImage, *labeledImage;         IMAGE_FORMAT format;         char *inputfile, *outputfile;         int rows, cols, r, c, h, w;         int *result;&nbsp;         setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;         print_CVIP(&quot;\\nEnter the Input File Name:  &quot;);         inputfile = (char *) getString_CVIP();         inputImage = read_Image(inputfile, 1);         view_Image(inputImage,inputfile);&nbsp;         labeledImage = label(inputImage);&nbsp;         rows = getNoOfRows_Image(labeledImage);         cols = getNoOfCols_Image(labeledImage);&nbsp;         print_CVIP(&quot;\\nEnter the row coordinate of any  pixel  on     the labled image: &quot;);         r = getInt_CVIP(10, 0, rows);         print_CVIP(&quot;\\nEnter the col coordinate of any  pixel  on     the labled image: &quot;);         c = getInt_CVIP(10, 0, cols);&nbsp;         print_CVIP(&quot;\\nEnter image height  after  the  object  of     interest is normalized: &quot;);         h = getInt_CVIP(10, 0, cols);         print_CVIP(&quot;\\nEnter image  width  after  the  object  of     interest is normalized: &quot;);         w = getInt_CVIP(10, 0, cols);&nbsp;         result = projection(labeledImage, r, c, h, w);         print_CVIP(&quot;\\nThe horizontal projection  of  the  object     (r, c) = %d\\n&quot;, *result );         print_CVIP(&quot;\\nThe vertical projection of the object  (r,     c) = %d\\n&quot;, *(result+1) );         free(inputfile);       }&nbsp;DIAGNOSTICS     The labeled image can only of data type CVIP_INTEGER&nbsp;SEE ALSO     FEATURE library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","projection","scr\\CVIP_C_functions/projection.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T00:45:00Z  2004-10-20T00:12:00Z  1  357  2037  SIUE  16  4  2390  10.3501    Clean                  MicrosoftInternetExplorer4 NAME     pseudocol_freq - creates pseudo-color image&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPcolor.h&quot;&nbsp;     Image * pseudocol_freq(Image *  grayImage,  int  inner,  int     outer, int blow, int bband, int bhigh)&nbsp;      &lt;grayImage&gt; - input gray image      &lt;inner&gt; - low cutoff frequency      &lt;outer&gt; - high cutoff frequency      &lt;blow&gt; - map lowpass results to band # (R=0,G=1,B=2)      &lt;bband&gt; - map bandpass results to band # (R=0,G=1,B=2)      &lt;bhigh&gt; - map highpass results to band # (R=0,G=1,B=2)                    (note: blow != bband != bhigh)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COLOR\\pseudocol_freq.c&nbsp;DESCRIPTION     This function creates a pseudocolor image from a gray  image     by frequency domain mapping. The low and high frequency cut-     offs define three zones on an FFT of the input  image:  low,     bandpass,  and  high  zone.  Each zone must be mapped to one     band of an RGB image; no overlap is allowed.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to an RGB image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPcolor.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      /* The input image should be a COLOR one */      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call creates a pseudocolor image from a      gray scale image by frequency domain mapping.The low and      high cutoff frequencies are specified */      cvipImage=pseudocol_freq(cvipImage,10,100,0,1,2);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,VIP,1);      free(outputfile);      }&nbsp;SEE ALSO     COLOR library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","pseudocol_freq","scr\\CVIP_C_functions/pseudocol_freq.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:45:00Z  2004-10-20T00:12:00Z  1  178  1020  SIUE  8  2  1196  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     quadtree2ras - create an image structure from a quad tree&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPtools.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPtyp.h&quot;      #include &quot;split_merge.h&quot;&nbsp;     Image *quadtree2ras(Image *srcImage, QUAD *treeQUAD)&nbsp;      &lt;srcImage&gt; - pointer to Image structure      &lt;treeQUAD&gt; - pointer to quad tree list&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\splitnMerge.cDESCRIPTION     This function will fill the contents of an  Image  structure     with  the  information  contained  in a quad tree. The Image     structure passed  (srcImage)  should  have  the  same  basic     attributes as the original Image used to form the quad tree,     such as dimension, data type (CVIP_BYTE), etc.  Most  likely     &lt;srcImage&gt;  will be the original image used to form the quad     tree unless for some reason the  contents  of  the  original     need be preserved.&nbsp;RETURN VALUES     Pointer to an Image structure.&nbsp;BUGS     None at this time&nbsp;SEE ALSO     SEGMENTATION library, split_merge_segment, split_merge_generic&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Greg Hance.&nbsp;\n\r\n\r&nbsp;","quadtree2ras","scr\\CVIP_C_functions/quadtree2ras.htm","   ACADEMIC COMPUTING  Normal  akharba  21  42  2005-07-02T20:16:00Z  2006-07-08T22:28:00Z  1  497  2833  SIUE  23  6  3324  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        range_normalize – range normalizes a 2D matrixSYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;stdlib.h&quot;&nbsp;      float **range_normalize(float **vector, int i, int j, int option, int *err_code)      &nbsp;&lt;vector&gt; - 2D pointer to a matrix&lt;i&gt; - number of columns in the matrix      &lt;j&gt; - number of rows in the matrix      &lt;option&gt; - 0 – to normalize the training set                 1 – to normalize the test set      &lt;err_code&gt; - pointer to the error code; use 0 for no error&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\range_normalize.c&nbsp;DESCRIPTION     This function range normalizes a matrix. The formula      used for range normalization is given in chapter 6      of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineno_of_col 2\n\r\n\r#defineno_of_row 3\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       float  **vector;\n\r\n\r       int           i,j;\n\r\n\r       int           option= 0;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r&nbsp;\n\r\n\r       /* Memory allocation. The size of vectoris (no_of_row+1)*no_of_col */\n\r\n\r       vector =malloc((no_of_row+1)*sizeof(float *));\n\r\n\r&nbsp;\n\r\n\r       for(i=0;i&lt;(no_of_row+1);i++)\n\r\n\r       {\n\r\n\r              vector[i] =malloc(no_of_col*sizeof(float));           \n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Get the vectors. The items should beseparated by &quot;,&quot;. vector[0][0],vector[0][1],...vector[row][col] */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector: &quot;);\n\r\n\r       for(j=0;j&lt;no_of_row;j++)\n\r\n\r       {\n\r\n\r              for(i=0;i&lt;no_of_col;i++)\n\r\n\r              {\n\r\n\r                     scanf(&quot;%f,&quot;,&amp;vector[j][i]);\n\r\n\r              }\n\r\n\r              \n\r\n\r       }\n\r\n\r       \n\r\n\r       /* Call c function, and return thevector. option is 0, means the vector comes from training set */\n\r\n\r       vector = range_normalize (vector,no_of_col, no_of_row, option, err_code);\n\r\n\r&nbsp;\n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }\n\r\n\r       else\n\r\n\r       {\n\r\n\r              /* Print out the result */\n\r\n\r              for(j=0;j&lt;no_of_row+1;j++)\n\r\n\r              {\n\r\n\r                     for(i=0;i&lt;no_of_col;i++)\n\r\n\r                     {\n\r\n\r                           printf(&quot;%f&quot;, vector[j][i]);\n\r\n\r                     }\n\r\n\r                     printf(&quot;%s\\n&quot;,&quot;&quot;);\n\r\n\r              }\n\r\n\r       }      \n\r\n\r       /* The last row in the vector is fornormalize another vector. Typically, from test set. */\n\r\n\r&nbsp;\n\r\n\r       /* Get another vectors. The items shouldbe separated by &quot;,&quot;. vector[0][0],vector[0][1],...vector[row][col] */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in another vector: &quot;);\n\r\n\r       for(j=0;j&lt;no_of_row;j++)\n\r\n\r       {\n\r\n\r              for(i=0;i&lt;no_of_col;i++)\n\r\n\r              {\n\r\n\r                     scanf(&quot;%f,&quot;,&amp;vector[j][i]);\n\r\n\r              }\n\r\n\r              \n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       option = 1;\n\r\n\r       /* Call c function, and return thevector. option is 1, means the vector comes from test set */\n\r\n\r       vector = range_normalize (vector,no_of_col, no_of_row+1, option, err_code);\n\r\n\r&nbsp;\n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }\n\r\n\r       else\n\r\n\r       {\n\r\n\r              /* Print out the result */\n\r\n\r              for(j=0;j&lt;no_of_row+1;j++)\n\r\n\r              {\n\r\n\r                     for(i=0;i&lt;no_of_col;i++)\n\r\n\r                     {\n\r\n\r                           printf(&quot;%f&quot;, vector[j][i]);\n\r\n\r                     }\n\r\n\r                     printf(&quot;%s\\n&quot;,&quot;&quot;);\n\r\n\r              }\n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Free the pointers */\n\r\n\r       for(i=0;i&lt;(no_of_row+1);i++)\n\r\n\r       {\n\r\n\r              free(vector[i]);\n\r\n\r       }\n\r\n\r       free(vector);\n\r\n\r}\n\r\n\r&nbsp;\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A range normalized matrix pointer&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;\n\r\n\r&nbsp;\n\r\n\r&nbsp;","range_normalize","scr\\CVIP_C_functions/range_normalize.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  3  2004-06-05T00:46:00Z  2004-10-20T00:13:00Z  1  262  1499  SIUE  12  3  1758  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     raster_deblur_filter - corrects raster-scan error&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;&nbsp;     Image *raster_deblur_filter(Image *cvip_image)&nbsp;      &lt;cvip_image&gt; - pointer to an Image structure&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\raster_deblur.c&nbsp;DESCRIPTION     This function corrects some raster-scan error.  It  operates     by replacing the value of every other pixel with the average     of its two adjacent pixels, first by rows, then by columns.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A filtered image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call corrects raster scan error by      calling the raster deblurring function */      cvipImage = raster_deblur_filter(cvipImage);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","raster_deblur_filter","scr\\CVIP_C_functions/raster_deblur_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T00:48:00Z  2004-10-20T00:13:00Z  1  331  1889  SIUE  15  4  2216  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     rayleigh_noise - Add Rayleigh noise to an image&nbsp;SYNOPSIS     #include &quot;CVIPnoise.h&quot;&nbsp;     Image *rayleigh_noise(Image* imageP,float *variance);&nbsp;      &lt;imageP&gt; - pointer to Image structure      &lt;var&gt; - variance of noise distribution&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\NOISE\\noise.c&nbsp;DESCRIPTION     Rayleigh type noise appears typically  in  radar  range  and     velocity  images  and  is derivable from uniform noise.  The     Rayleigh noise histogram is defined as:&nbsp;                 Gi          hi = --------exp(-Gi^2/(2a^2) 0&lt;=Gi&lt;infinity                 a^2&nbsp;     where Gi is the grey-level value of the ith pixel,  and  the     mean can be defined as follows: mean=sqrt(pi/2a).&nbsp;RETURN VALUES     The rayleigh_noise() function  returns  the  modified  Image     pointer on success, and returns a NULL pointer on failure&nbsp;BUGS     none&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;CVIPnoise.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      float var=100.0;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call adds rayleigh noise to the input      image with the variance equal to 100.0.We can use the      function rayleigh_noise_setup so that the user can      specify the inputs  */      cvipImage = rayleigh_noise(cvipImage,&amp;var);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     gamma_noise(3),     gaussian_noise(3),     neg_exp_noise(3),     speckle_noise(3), uniform_noise(3)&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and     David Lyons.&nbsp;\n\r\n\r&nbsp;","rayleigh_noise","scr\\CVIP_C_functions/rayleigh_noise.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  3  2004-06-05T00:49:00Z  2004-10-20T00:13:00Z  1  310  1769  SIUE  14  4  2075  10.3501    Clean                  MicrosoftInternetExplorer4 NAME     read_Image - loads an Image structure  with  data  from  the                    specified image file&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;&nbsp;     Image *read_Image(char *filename, int showmessages)&nbsp;      &lt;filename&gt; - pointer to an character string containing  the     file name      &lt;showmessages&gt; - shall I be verbose?&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\CONVERSION\\convert.c&nbsp;DESCRIPTION     Loads an Image structure with data from the specified  image     file  &lt;filename&gt;. All data members of the structure are ini-     tialized to the specifications of the image file read in.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     Pointer to newly allocated Image structure loaded with  data     from image &lt;filename&gt;&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;CVIPconvert.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      /* the following call loads an image  structure  with  data     from      the specified file */      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      /* the following call writes the contents of the CVIP image      structure out to disk.The format is the same as the      input file format */      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO    CONVERSION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Greg     Hance.&nbsp;\n\r\n\r&nbsp;","read_Image","scr\\CVIP_C_functions/read_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T00:50:00Z  2004-10-20T00:13:00Z  1  338  1931  SIUE  16  4  2265  10.3501                    MicrosoftInternetExplorer4 NAME     regular_mesh - create a  regular  mesh  corresponding  to  a     given mesh and a given image&nbsp;SYNOPSIS     #include &quot;mesh.h&quot;  struct  mesh  *regular_mesh(struct  mesh*     inmesh,int width,int height);&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\warp.cDESCRIPTION     The regular_mesh() create a new  mesh  which  has  the  same     number   of   rows   and   columns   as   the   input   mesh     structure(pointed to by &quot;inmesh&quot;).  All the  cells  in  this     new mesh have exactly the same size.  The whole mesh has the     width  and  height  given  by  the  arguments  &quot;width&quot;   and     &quot;height&quot;.&nbsp;TYPES AND CONSTANTS     struct mesh_node {          int x;          int y;     };&nbsp;     struct mesh {          int width;          int height;          struct mesh_node** nodes;     };&nbsp;     struct float_pair {          float x;          float y;     };     (e.g.)     typedef ... newval;     #define AVAL ...     extern newval that;&nbsp;RETURN VALUES     The regular_mesh() returns a pointer points to the new  mesh     structure just created.&nbsp;EXAMPLE     #include &quot;mesh.h&quot; #include &lt;CVIPio.h&gt; main() {          char           *inputfile;          Image          *inputImage;          int       width, height;          struct mesh    *inmesh, *outmesh;&nbsp;          print_CVIP(&quot;0Input   the   mesh    file    name:    &quot;);       /*OPTIONAL1, get*/          inputfile              =              getString_CVIP();                    /*OPTIONAL1, a*/          inmesh  =  file_to_mesh(inputfile);        /*OPTIONAL1,     mesh structure*/&nbsp;          print_CVIP(&quot;0Width of  the  image:   &quot;);   /*OPTIONAL2,     get*/          width =  getInt_CVIP(10,  1,  1024);       /*OPTIONAL2,     an*/          print_CVIP(&quot;0Height of  the  image:   &quot;);  /*OPTIONAL2,     image*/          height = getInt_CVIP(10, 1, 1024);      /*OPTIONAL2*/          inputImage = black_pgm(width, height);  /*OPTIONAL2*/&nbsp;          outmesh = regular_mesh(inmesh, width, height);&nbsp;          display_mesh(inputImage,    outmesh);      /*OPTIONAL3,     display the mesh*/ }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     file_to_mesh(), keyboard_to_mesh(), mesh_to_file();&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Jianxin Tan.&nbsp;\n\r\n\r&nbsp;","regular_mesh","scr\\CVIP_C_functions/regular_mesh.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  3  2004-06-05T00:51:00Z  2004-10-20T00:13:00Z  1  152  873  SIUE  7  2  1023  10.3501    Clean                  MicrosoftInternetExplorer4 &nbsp;NAME     remap_Image - maps data into a range&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;float.h&quot;&nbsp;     Image *remap_Image(const  Image  *imageP,  CVIP_TYPE  dtype,     unsigned dmin, unsigned dmax)&nbsp;      &lt;imageP&gt; - pointer to an Image      &lt;dtype&gt; - datatype into which data is to be mapped      &lt;dmin&gt; - minimum value for range      &lt;dmax&gt; - maximum value for range&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\Mapping\\relremap.cDESCRIPTION     Remaps data in an image to the specified range according to:&nbsp;        P = dmin + factor*(original_value - original_minimum)&nbsp;     where factor is&nbsp;          (dmax-dmin)/(original_maximum - original_minimum)&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Pointer to a modified image&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO    HISTOGRAM library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh,  Greg  Hance,     and  Kun Luo.  # Revision 1.1  1997/01/31  17:11:03  sumbaug     # Initial revision #&nbsp;\n\r\n\r&nbsp;","remap_Image","scr\\CVIP_C_functions/remap_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:53:00Z  2004-10-20T00:13:00Z  1  245  1400  SIUE  11  3  1642  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     rms_error - computes the rms error between two images&nbsp;SYNOPSIS      #include &lt;CVIPimage.h&gt;      #include &quot;CVIPcompress.h&quot;&nbsp;     float *rms_error(Image *im1, Image *im2)&nbsp;      &lt;im1&gt; - Pointer to Image      &lt;im2&gt; - Pointer to Image&nbsp;      RETURNS: Pointer to rms values (float)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\rms_error.cDESCRIPTION     rms_error() calculates the Root-Mean_squared  error  between     two images.&nbsp;     The number of  values  contained  in  the  return  value  of     rms_error()  is  equal  to bands+1.  Thus, for a color image     (RGB),  rms_error()   will   return   float   *fptr;   where     fptr[0]=error  in  Red  Band;  fptr[1]=error  in Green band;     fptr[2]=error in Blue  band;  and  fptr[3]  is  overall  rms     error.&nbsp;EXAMPLE      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPhisto.h&gt;&nbsp;      void main()      {      Image *cvipImage, *heqimage;      IMAGE_FORMAT format;      char *inputfile;      float *error;      int i;&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      heqimage=histeq(cvipImage);      error = rms_error(cvipImage, heqimage);      for(i=0; i&lt;getNoOfBands_Image(cvipImage); i++) {         fprintf(stdout, &quot;Error in band #%d: %f0, i, error[i]);      }      fprintf(stdout,        &quot;Overall         Error:         %f0,     error[getNoOfBands_Image(cvipImage)];&nbsp;BUGS     None at this time&nbsp;SEE ALSO     snr()&nbsp;AUTHOR     Copyright (C) 1993-1996, 2004 SIUE - by  Scott  Umbaugh  and  Arve     Kjoelen&nbsp;\n\r\n\r&nbsp;","rms_error","scr\\CVIP_C_functions/rms_error.htm","   Hari  Normal  jhansi  39  47  2009-09-17T22:18:00Z  2010-01-06T21:50:00Z  1  477  2723  SIUE  22  6  3194  11.9999    140  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                                                                  NAME     robinson_filter - perform robinson edge detection&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPfs.h&quot;      #include &lt;limits.h&gt;&nbsp;     Image *robinson_filter(Image *inputImage,  Image *dirImage,         int mask_choice,  int mask_size, int keep_dc, int threshold)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;dirImage&gt; - pointer to direction Image      &lt;mask_choice&gt; - type of smoothing filter      &lt;mask_size&gt; - kernel size      &lt;keep_dc&gt; - 0 (no) or 1 (yes)      &lt;threshold&gt; - value for binary threshold&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\robinson_filter.c&nbsp;DESCRIPTION     This function applies robinson edge detection algorithm to     &lt;inputImage&gt;, and returns magnitude image, but for direction image,      a blank image is created using new_Image and is passed to      the function as direction image. After the function is     called direction image can be then viewed using view_Image     function. Data range of output direction image is -3pi/4 to +pi.     If a smoothing filter is desired as a preprocessing step,     set &lt;mask_choice&gt; to:                       1 = Gaussian blur                       2 = generic lowpass 1                       3 = generic lowpass 2                       4 = neighborhood average&nbsp;     For &lt;mask_size&gt;: Set mask_size to desired kernel size     For &lt;dirImage&gt; : direction image.&nbsp;     NOTE: for the parameters, mask_choice, mask_size, keepdc,      threshold, use the value -1 for any parameter not needed.  TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A robinson edge-detected magnitude image and direction image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPfs.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *inputImage, *dirImage;      Image *outImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile,*outputfile1;              print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      inputImage = read_Image(inputfile, 1);      view_Image(inputImage, inputfile);      free(inputfile);&nbsp;\n\r\n\r      dirImage =new_Image(inputImage-&gt;image_format, \n\r\n\r      inputImage-&gt;color_space,inputImage-&gt;bands, getNoOfRows_Image(inputImage), \n\r\n\r      getNoOfCols_Image(inputImage),CVIP_FLOAT, REAL);   \n\r\n\r      \n\r\n\r      outImage=robinson_filter(inputImage,dirImage, -1, -1, -1, -1);            print_CVIP(&quot;\\n\\t\\tEnter the Output File Name of magnitude Image:  &quot;);      outputfile = getString_CVIP();      print_CVIP(“\\n\\t\\tEnter the Output File Name of direction Image: ”);      outputfile1 = getString_CVIP();      view_Image(outImage,outputfile);      view_Image(dirImage, outputfile1);      delete_Image(outImage);      delete_Image(dirImage);      delete_Image(inputImage);      free(outputfile);      free(outputfile1);      }&nbsp;SEE ALSO    SPATIALFILTER library      &nbsp;AUTHOR     Copyright (C) 2010, SIUE - by Scott Umbaugh, and Hari Krishna Akkineni. &nbsp;\n\r\n\r&nbsp;\n\r\n\r&nbsp;","robinson_filter","scr\\CVIP_C_functions/robinson_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  4  2004-06-05T00:54:00Z  2004-10-20T00:14:00Z  1  350  1997  SIUE  16  4  2343  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     rotate - rotates an image&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPgeometry.h&quot;&nbsp;     Image *rotate( Image *input_Image, float degree)&nbsp;      &lt;input&gt; - a pointer to an Image structure      &lt;degree&gt; - amount to rotate image (1 - 360)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\rotate.c&nbsp;DESCRIPTION      This function rotates the image by the degree specified.The     transformation equation used are     X=xcos(rads)+ysin(rads);           Y=-xsin(rads)+ycos(rads);     Where,            X=shifted x  co-ordinate       Y=shifted  y  co-      ordinate      rads=number of radians to be rotated      For the 4 corners of the image,the shifted co-ordinates      are  found out and from that the new image size can be      calculated .For each co-ordinate in the new image the      corresponding  co-ordinate in the old image is calculated,      if it  falls with in the range of the old image size,      the corresponding pixel  value is copied,otherwise      the pixel value is  set to zero.&nbsp;TYPES AND CONSTANTS     #define pi 3.14159265358979323846&nbsp;RETURN VALUES      Pointer to the rotated image&nbsp;HISTORY      History information copied from the old to the new      image&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPgeometry.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /*the following call rotates the image by 90      degrees */      cvipImage = rotate(cvipImage,90);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     GEOMETRY library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and      Sreenivas Makam.&nbsp;\n\r\n\r&nbsp;","rotate","scr\\CVIP_C_functions/rotate.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  0  2004-06-05T00:55:00Z  2004-10-20T00:14:00Z  1  356  2032  SIUE  16  4  2384  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     rst_invariant - calculates seven rst-invariant features&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPimage.h&quot;&nbsp;     double *rst_invariant(Image *label_image, int row, int col)&nbsp;      &lt;label_image&gt; - pointer to a labeled ImageS structure      &lt;row&gt; - a row coordinate within the object of interest      &lt;column&gt;  -  a  column  coordinate  within  the  object  of     interest&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\rst_invariant.cDESCRIPTION     This function calculates seven moment-based  rotation-scale-     translation  (rst)-invariant features for an object selected     by the user. In order to get the rst features, the  function     first  calculates and normalizes central moments. This algo-     rithm is designed to work on the binary image.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     An array of seven feature values&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPobject.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;&nbsp;      void main()      {         Image *inputImage, *labeledImage;         IMAGE_FORMAT format;         char *inputfile, *outputfile;         int rows, cols, r, c,i;         double *ptr;&nbsp;         setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;         print_CVIP(&quot;\\nEnter the Input File Name:  &quot;);         inputfile = (char *) getString_CVIP();         inputImage = read_Image(inputfile,1);         view_Image(inputImage,inputfile);&nbsp;         labeledImage = label(inputImage);&nbsp;         rows = getNoOfRows_Image(labeledImage);         cols = getNoOfCols_Image(labeledImage);&nbsp;         print_CVIP(&quot;\\nEnter the row coordinate of a point         on the labled image: &quot;);         r = getInt_CVIP(10, 0, rows);         print_CVIP(&quot;\\nEnter the col coordinate of the point         on the labled image: &quot;);         c = getInt_CVIP(10, 0, cols);         /* the following call calculates the rst_invariant         features */         ptr=rst_invariant(labeledImage,r,c);         print_CVIP(&quot;The rst_invariant features of the input         image are:&quot;);         for(i=0;i&lt;7;i++)         print_CVIP(&quot;rst_invariant%d=%f\\n&quot;,i+1,ptr[i]);         free(inputfile);       }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     FEATURE library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Jihong Zhou.\n\r\n\r&nbsp;","rst_invariant","scr\\CVIP_C_functions/rst_invariant.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T00:56:00Z  2004-10-20T00:14:00Z  1  314  1793  SIUE  14  4  2103  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     sct_split_segment - performs Spherical Coordinate  Transform     segmentation&nbsp;SYNOPSIS      #include &quot;CVIPcolor.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;SCTsplit.h&quot;&nbsp;      Image *sct_split_segment (Image  *imgP,  int  A_split,  int     B_split)&nbsp;      &lt;imgP&gt; - address of pointer to Image structure      &lt;A_split&gt; - number of colors to divide along angle A      &lt;B_split&gt; - number of colors to divide along angle B&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\sct_split.cDESCRIPTION     The  Spherical Coordinate Transform  segmentation  algorithm     (SCT/Center  split) was developed for use in the identifica-     tion of variegated coloring in skin tumor images. The  algo-     rithm  maps  RGB data into a space defined by two angles and     an intensity measure. Then  the  subspace,  defined  by  the     minimums  and maximums on the two angles, is equally divided     along each axis, using the two input parameters, A_split and     B_split.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     The segmented image.&nbsp;EXAMPLE      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPcolor.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;sct_split.h&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile, *outputfile;      int Asplit, Bsplit;&nbsp;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      Asplit = Bsplit = 3;      cvipImage = sct_split_segment(cvipImage, Asplit, Bsplit);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage, outputfile);      format = getFileFormat_Image(cvipImage);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(inputfile);      free(outputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     SEGMENTATION library&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","sct_split_segment","scr\\CVIP_C_functions/sct_split_segment.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:56:00Z  2004-10-20T00:14:00Z  1  86  496  SIUE  4  1  581  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     setUpLabel_Objects - calls object labeling&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPobject.h&quot;&nbsp;     Image * setUpLabel_Objects( const Image *imageP )&nbsp;      &lt;imageP&gt; - pointer to an Image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\Object\\ObjectSetUp.cDESCRIPTION     This function calls the function label_Objects.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A labeled image&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     Object library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh,  Greg  Hance,     and Kun Luo.&nbsp;\n\r\n\r&nbsp;","setUpLabel_Objects","scr\\CVIP_C_functions/setUpLabel_Objects.htm","   ACADEMIC COMPUTING  Normal  akharba  7  23  2004-07-03T22:50:00Z  2006-07-08T22:35:00Z  1  415  2369  SIUE  19  5  2779  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAMEshen_castan_filter – performs a Shen-Castan edge detection on the image&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPspfltr.h&gt;&nbsp;     Image *shen_castan_filter(Image *inputImage, Image *zeroInter,float b, int window_size,float low_thresh,float high_thresh, int thinFactor)&lt;inputImage&gt; - pointer to the input image structure                  &lt;zeroInter&gt; - pointer to an intermediate image structure after                     false zero crossing suppression      &lt;b&gt; - smoothing factor for the ISEF function (0&lt;b&lt;1).      &lt;window_size&gt; - size of the window for false zero crossing suppression      &lt;low_thresh&gt; - Low threshold scale factor for the hysteresis                     threshold                      0.0 &lt; low_factor &lt; 10      &lt;high_thresh&gt; - High threshold scale factor for the hysteresis                      threshold                       low_factor &lt; high_factor &lt; 10      &lt;thinFactor&gt; - distance between final line points.&nbsp;&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\shen_castan_filter.c&nbsp;DESCRIPTIONShen_castan_filter function applies Shen &amp; Castan’s edge detector to an input image. The inputs of all data types are accepted. The function takes 5 parametrs as input, smoothing factor, window size,  the high threshold factor, the low threshold factor and thin factor. The output is of byte data type. All the function are in the file shen_castan_edge.c. Shen and Castan also proposed an optimal linear filter for edge detection. They follow the basic idea of smoothing the image to mitigate noise effect first and applying a differential operator to find the edges. But their optimal filteris the Infinite Symmetric Exponential Filter. The algorithm is as follows:Convolve input image with ISEF filter of the given smoothing factor. Recursive filters are used to speed up computation. Compute band limited laplacian (BLI). Apply false zero crossing suppression to remove spurious edges. Apply hysteresis thresholding. The threshold values for hysteresis thresholding are computed from the false zero crossing suppressed magnitude image so that the high threshold is greater that 90% of the pixels and the low threshold is the average of the high threshold and the minimum value in the image. Final high threshold used for hysteresis = high threshold computed from image * high_factorFinal low threshold used for hysteresis = low threshold computed from image * low_factor.Finally apply thinning according to the thnning factorTYPES AND CONSTANTS     None&nbsp;RETURN VALUES     Returns the edge detected image&nbsp;HISTORY     History information recorded: NoneSEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 2004 SIUE - by Scott Umbaugh.\n\r\n\r&nbsp;","shen_castan_filter","scr\\CVIP_C_functions/shen_castan_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  3  2004-06-05T00:57:00Z  2004-10-20T00:15:00Z  1  164  937  SIUE  7  2  1099  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     showMax_histogram  -  function  used  by  histogram_spec  to     display histogram statistics&nbsp;SYNOPSIS      #include &lt;stdio.h&gt;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;histogram.h&quot;      #include &quot;ee.h&quot;&nbsp;     void showMax_histogram(float **histogram, char *title)&nbsp;      &lt;histogram&gt; - pointer to a histogram pointer      &lt;title&gt; - name given to histogram image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\HISTOGRAM\\histogram.c&nbsp;DESCRIPTION     This function is used by the  histogram_spec()  function  to     display  the  value  of  the  most frequently occurring gray     level, and its probability of occurrence.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     None&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE     This    function    is    called     in     the     function     histogram_spec_setup, in histogram,c.&nbsp;BUGS     None at this time&nbsp;SEE ALSO     get_histogram,        get_histogram_Image,        hist_spec,     histogram_show, histogram_spec, make_histogram&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and  David  A.     Lyons.&nbsp;\n\r\n\r&nbsp;","showMax_histogram","scr\\CVIP_C_functions/showMax_histogram.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T00:58:00Z  2004-10-20T00:15:00Z  1  520  2964  SIUE  24  6  3478  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     shrink - reduces the image size&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPgeometry.h&quot;&nbsp;     Image *shrink( Image *input_Image, float factor );&nbsp;      &lt;input_Image&gt; - pointer to an Image structure      &lt;factor&gt; - scaling factor (0.1 - 1.0)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\shrink.cDESCRIPTION     A pointer to the Image structure is passed to  the  function     shrink   so  that  the original image can be accessed, along     with the scaling factor which should be in the range 0.1  to     1  (1 is the maximum scaling factor).  The function uses the     first order scaling  algorithm  where,  depending  upon  the     scaling factor the pixels from the original image are simple     copied to the new image.  The scaling factor is tested first     to  determine the size of the new resultant image as well as     the pixels to be removed in  the  original  image.   If  the     inverse of the scaling factor is an integer (example scaling     factor = 0.25, ==&gt; 1/0.25 = 4),  then  every  occurrence  of     that  pixel  is  COPIED  to  the new image who image size is     determined by the scaling factor (In the above  case,  every     4nd pixel is copied to the new image).&nbsp;     If the scaling factor is less than  0.5,  then  the  scaling     factor  is  apparently modified so that the number of pixels     COPIED to the new image is uniform thus  avoiding  quantiza-     tion  in  the  resultant  image.  For example, for a scaling     factor 0.4 (0.4 ==&gt; 1/0.4 = 2.5), every  alternate  2nd  and     3rd pixels are copied to the new image.&nbsp;     If the scaling factor is greater than  0.5,  then  depending     upon the scaling factor, those many pixels are SKIPPED while     rest of the pixels are copied to the new image. For example,     for a scaling factor 0.6, every alternate 2nd and 3rd pixels     are skipped while the rest is written to the new image.  For     a scaling factor of 0.8, every 5th pixel is skipped, for 0.9     every 9th pixel is skipped and so on.&nbsp;     After the scaling operation is performed, the pointer to the     new resultant image of type Image is returned to the calling     function so that the new image can be displayed.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     Pointer to the shrinkd image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPgeometry.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;0Enter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /*the following call shrinks the image size by a      factor of .1 */      cvipImage = shrink(cvipImage,.1);      print_CVIP(&quot;0Enter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     GEOMETRY library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh  and  Srinivas     Madiraju\n\r\n\r&nbsp;","shrink","scr\\CVIP_C_functions/shrink.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T00:59:00Z  2004-10-20T00:15:00Z  1  465  2654  SIUE  22  6  3113  10.3501                    MicrosoftInternetExplorer4 NAME     simple_wiener - performs a practical wiener filter&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtransform.h&quot;      #include &quot;CVIPxformfilter.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIParithlogic.h&quot;&nbsp;     Image *simple_wiener(Image *degr, Image *degr_fn, float k)&nbsp;      &lt;degr&gt; - pointer to the degraded image      &lt;degr_fn&gt; - pointer to the degradation function      &lt;k&gt;    - a constantPATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\InverseFilter.c&nbsp;DESCRIPTION            Performs the operations needed to  perform  a  simple     Wiener Filter.            Denoting the degraded image by G(u,v), and using            H(u,v) for the degradation function Image, this func-     tion calculates                                                  2                                          |H(u,v)|              F(u,v) = G(u,v)    *     --------------                                               2                                       |H(u,v)|   + k&nbsp;       Variables Passed:            Image *degr - Contains the degraded image.            Image *degr - Contains the degradation function.            float k - constant.&nbsp;     This function performs a wiener filter, (a frequency  domain     filter).   See  any  image  processing  textbook for info on     Wiener Filters.  The function does its  own  memory  manage-     ment,  freeing  everything passed to it, so if you need your     images intact, make a copy of them before calling this func-     tion.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to the restored Image&nbsp;HISTORY     History information recorded:       - function name (SIMPLE_WIENER)       - parameter #1 = the value of k (float).&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage,*cvipImage1;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER,&quot;default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call creates a gaussian mask of size      3  * 3 */      cvipImage1 = (Image *)h_image(3,3,3);      /* the following call performs the practical wiener filter      on the input image with the gaussian mask and the      constant k equal to 1 */      cvipImage=(Image *)simple_wiener(cvipImage,cvipImage1,1.0);      cvipImage=(Image *)ifft_transform(cvipImage,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Arve     Kjoelen.\n\r\n\r&nbsp;","simple_wiener","scr\\CVIP_C_functions/simple_wiener.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T01:00:00Z  2004-10-20T00:15:00Z  1  431  2461  SIUE  20  5  2887  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     single_filter - performs single filter&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPspfltr.h&quot;&nbsp;     Image *single_filter (Image *orig_image,  float  s_c,  float     s_r,  int  r_cen,      int c_cen, float rot, float beta, int     N, float *h, int choice)&nbsp;      &lt;orig_image&gt; - pointer to an Image      &lt;s_c&gt; - horizontal sizing factor, 1 for no change      &lt;s_r&gt; - vertical sizing factor, 1 for no change      &lt;r_cen&gt; - row coordinate for new center, 0 for no change      &lt;c_cen&gt; - column coordinate for new center, 0 for no change      &lt;rot&gt; - angle of rotation, 0 for no change      &lt;beta&gt; - value for beta, typically 0.3 - 0.8      &lt;N&gt; - kernel size (3,5,7,...)      &lt;h&gt; - kernel array (of size N*N)      &lt;choice&gt; - operation of filter (see DESCRIPTION, below):                     1 = -,-                     2 = +,+                     3 = +,-                     4 = -,+&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\single_filter.cDESCRIPTION     Performs manipulation and enhancement of an image in a  sin-     gle  filter, after C.B. Chittineni. This implementation of a     single filter is based on the following equation:&nbsp;         f(x,y)=[(1+/-alpha)g(x,y)]-/+[(alpha)g(x,y)*h(x,y)]&nbsp;     The parameter \'&lt;choice&gt; - operation of filter\' refers to the     selection  of  arithmetic  signs  for the +/- and -/+ in the     equation above.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A filtered image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      float  h[9]={1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0};      float *a=h;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs a single filter operation.      The original size  of the image,the center of the image      is not changed.beta is chosen as 0.5 and the kernel      size is chosen as 3 */      cvipImage = single_filter(cvipImage,1,1,0,0,0,0.5,3,a,3);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh, Joseph  Tsai,     and Kun Luo.&nbsp;\n\r\n\r&nbsp;","single_filter","scr\\CVIP_C_functions/single_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  0  2004-06-05T01:01:00Z  2004-10-20T00:15:00Z  1  252  1438  SIUE  11  3  1687  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     smooth_filter - an averaging filter for image smoothing&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPenhance.h&quot;&nbsp;      Image *smooth_filter(Image *inputImage,int kernel)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;kernel&gt; - kernel size, from 2 to 10&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\smooth.cDESCRIPTION     This function performs a neighborhood  averaging,  replacing     the  pixel  under consideration by the average of its neigh-     boring pixels. Allowable kernel  sizes  range  from  2x2  to     10x10.&nbsp;RETURN VALUES     A pointer to the smoothed Image pointer on success,  a  NULL     pointer on failure.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPenhance.h&gt;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile, *outputfile;&nbsp;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      cvipImage = smooth_filter(cvipImage, 3);      /* example kernel = 3 */      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage, outputfile);      write_Image(cvipImage,   outputfile,CVIP_NO,CVIP_NO,format,     1);      free(inputfile);      free(outputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     SPATIALFILTEER library&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE -  by  Scott  Umbaugh  and  Srinivas     Madiraju.&nbsp;\n\r\n\r&nbsp;","smooth_filter","scr\\CVIP_C_functions/smooth_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T01:02:00Z  2004-10-20T00:15:00Z  1  318  1814  SIUE  15  4  2128  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     snr - computes the rms error between two images&nbsp;SYNOPSIS      #include &lt;CVIPimage.h&gt;      #include &quot;CVIPcompress.h&quot;&nbsp;     float *snr(Image *im1, Image *im2)&nbsp;      &lt;im1&gt; - Pointer to Image      &lt;im2&gt; - Pointer to Image&nbsp;      RETURNS: Pointer to rms values (float)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\rms_error.cDESCRIPTION     snr() calculates the Peak Signal-to-Noise ratio between  two     images, assuming a maximum value of 255 (BYTE).&nbsp;     The number of values contained in the return value of  snr()     is  equal  to bands+1.  Thus, for a color image (RGB), snr()     will return float *fptr;  where  fptr[0]=snr  in  Red  Band;     fptr[1]=snr  in  Green  band;  fptr[2]=snr in Blue band; and     fptr[3] is overall SNR.&nbsp;     If case if there is no error between two images for a  band,     the  return value for that band is set to -1.0 as an indica-     tion.&nbsp;     The input images may be any data type, but for the result to     be meaningful the maximum value should be around 255.&nbsp;EXAMPLE      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPhisto.h&gt;&nbsp;     void main() {      Image *cvipImage, *cvipImage_dup, *heqimage;      IMAGE_FORMAT format;      char *inputfile;      float *error;      int i;&nbsp;      print_CVIP(&quot;0Enter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      if( !(cvipImage = read_Image(inputfile, 1))) {       error_CVIP(&quot;main&quot;, &quot;could not read input image&quot;);       break;       }      cvipImage_dup    =    duplicate_Image(     cvipImage     );&nbsp;      heqimage = histeq(cvipImage, 0);&nbsp;      error = snr(cvipImage_dup, heqimage );      for(i=0; i&lt;cvipImage -&gt;bands; i++) {        fprintf(stdout, &quot;SNR in band #%d: %f0&quot;, i, error[i]);        }      fprintf(stdout,         &quot;   Overall   SNR:          %f0  0,      error[cvipImage-&gt;bands]);      free(error);      delete_Image( cvipImage_dup );      free( heqimage );      free( cvipImage );      free( cvipImage_dup );      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     snr()&nbsp;AUTHOR     Copyright (C) 1993-1996, 2004 SIUE - by  Scott  Umbaugh  and  Arve     Kjoelen&nbsp;\n\r\n\r&nbsp;","snr","scr\\CVIP_C_functions/snr.htm","   Hari  Normal  jhansi  52  43  2009-09-17T21:47:00Z  2010-01-06T21:49:00Z  1  472  2697  SIUE  22  6  3163  11.9999    140  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                                                                  NAME     sobel_filter - perform sobel edge detection&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPfs.h&quot;      #include &lt;limits.h&gt;&nbsp;     Image *sobel_filter(Image *inputImage,  Image *dirImage,         int mask_choice,  int mask_size, int keep_dc, int threshold)&nbsp;      &lt;inputImage&gt; - pointer to an Image      &lt;dirImage&gt; - pointer to direction Image      &lt;mask_choice&gt; - type of smoothing filter      &lt;mask_size&gt; - kernel size      &lt;keep_dc&gt; - 0 (no) or 1 (yes)      &lt;threshold&gt; - value for binary thresholdPATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\sobel_filter.c&nbsp;DESCRIPTION     This function applies sobel edge detection algorithm to     &lt;inputImage&gt;, and returns magnitude image, but for direction image,      a blank image is created using new_Image and is passed to      the function as direction image. After the function is     called direction image can be then viewed using view_Image     function. Data range of output direction image is -pi to +pi.     If a smoothing filter is desired as a preprocessing step,     set &lt;mask_choice&gt; to:                       1 = Gaussian blur                       2 = generic lowpass 1                       3 = generic lowpass 2                       4 = neighborhood average&nbsp;     For &lt;mask_size&gt;: Set mask_size to desired kernel size     For &lt;dirImage&gt; : direction image.&nbsp;     NOTE: for the parameters, mask_choice, mask_size, keepdc,      threshold, use the value -1 for any parameter not needed.  TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A Sobel magnitude image and direction image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPfs.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {       Image *inputImage, *dirImage;      Image *outImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile,*outputfile1;              print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      inputImage = read_Image(inputfile, 1);      view_Image(inputImage, inputfile);      free(inputfile);    \n\r\n\r      dirImage =new_Image(inputImage-&gt;image_format, \n\r\n\r      inputImage-&gt;color_space,inputImage-&gt;bands, getNoOfRows_Image(inputImage), \n\r\n\r      getNoOfCols_Image(inputImage),CVIP_FLOAT, REAL);&nbsp;\n\r\n\r      outImage=sobel_filter(inputImage, dirImage,-1, -1, -1, -1);            print_CVIP(&quot;\\n\\t\\tEnter the Output File Name of magnitude Image:  &quot;);      outputfile = getString_CVIP();      print_CVIP(“\\n\\t\\tEnter the Output File Name of direction Image:  ”);      outputfile1 = getString_CVIP();      view_Image(outImage,outputfile);      view_Image(dirImage, outputfile1);      delete_Image(outImage);      delete_Image(dirImage);      delete_Image(inputImage);            free(outputfile);      free(outputfile1);      }&nbsp;SEE ALSO    SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 2010, SIUE - by Scott Umbaugh, and Hari Krishna Akkineni. &nbsp;\n\r\n\r&nbsp;&nbsp;","sobel_filter","scr\\CVIP_C_functions/sobel_filter.htm","   ACADEMIC COMPUTING  Normal  akharba  4  3  2005-07-02T21:14:00Z  2006-07-08T22:28:00Z  1  521  2971  SIUE  24  6  3486  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        softmax_scaling – normalizes a 2D matrix using softmax                           scaling normalization method&nbsp;SYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;stdlib.h&quot;&nbsp;float **softmax_scaling(float **vector, int i, int j, float r_softmax, int option, int *err_code)&nbsp;&lt;vector&gt; - 2D pointer to a matrix&lt;i&gt; - number of columns in the matrix      &lt;j&gt; - number of rows in the matrix      &lt;r_softmax&gt; - parameter for softmax scaling      &lt;option&gt; - 0 – to normalize the training set                 1 – to normalize the test set      &lt;err_code&gt; - pointer to the error code; use 0 for no error&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\softmax_scaling.c&nbsp;DESCRIPTION     This function normalizes a matrix using softmax scaling     method. The formula used for softmax scaling is given in      chapter 6 of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineno_of_col 2\n\r\n\r#defineno_of_row 3\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       float  **vector;\n\r\n\r       float  r_softmax=2;\n\r\n\r       int           i,j;\n\r\n\r       int           option= 0;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r&nbsp;\n\r\n\r       /* Memory allocation. The size of vectoris (no_of_row+2)*no_of_col */\n\r\n\r       vector =malloc((no_of_row+2)*sizeof(float *));\n\r\n\r&nbsp;\n\r\n\r       for(i=0;i&lt;(no_of_row+2);i++)\n\r\n\r       {\n\r\n\r              vector[i] =malloc(no_of_col*sizeof(float));           \n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Get the vectors. The items should beseparated by &quot;,&quot;. vector[0][0],vector[0][1],...vector[row][col] */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector: &quot;);\n\r\n\r       for(j=0;j&lt;no_of_row;j++)\n\r\n\r       {\n\r\n\r              for(i=0;i&lt;no_of_col;i++)\n\r\n\r              {\n\r\n\r                     scanf(&quot;%f,&quot;,&amp;vector[j][i]);\n\r\n\r              }\n\r\n\r              \n\r\n\r       }\n\r\n\r       \n\r\n\r       /* Call c function, and return thevector. option is 0, means the vector comes from training set */\n\r\n\r       vector = softmax_scaling (vector,no_of_col, no_of_row, r_softmax, option, err_code);\n\r\n\r&nbsp;\n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }\n\r\n\r       else\n\r\n\r       {\n\r\n\r              /* Print out the result */\n\r\n\r              for(j=0;j&lt;no_of_row+2;j++)\n\r\n\r              {\n\r\n\r                     for(i=0;i&lt;no_of_col;i++)\n\r\n\r                     {\n\r\n\r                           printf(&quot;%f&quot;, vector[j][i]);\n\r\n\r                     }\n\r\n\r                     printf(&quot;%s\\n&quot;,&quot;&quot;);\n\r\n\r              }\n\r\n\r       }      \n\r\n\r       /* The last two rows in the vector is fornormalize another vector. Typically, from test set. */\n\r\n\r&nbsp;\n\r\n\r       /* Get another vectors. The items shouldbe separated by &quot;,&quot;. vector[0][0],vector[0][1],...vector[row][col] */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in another vector: &quot;);\n\r\n\r       for(j=0;j&lt;no_of_row;j++)\n\r\n\r       {\n\r\n\r              for(i=0;i&lt;no_of_col;i++)\n\r\n\r              {\n\r\n\r                     scanf(&quot;%f,&quot;,&amp;vector[j][i]);\n\r\n\r              }\n\r\n\r              \n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       option = 1;\n\r\n\r       /* Call c function, and return thevector. option is 1, means the vector comes from test set */\n\r\n\r       vector = softmax_scaling (vector, no_of_col,no_of_row+2, r_softmax, option, err_code);\n\r\n\r&nbsp;\n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }\n\r\n\r       else\n\r\n\r       {\n\r\n\r              /* Print out the result */\n\r\n\r              for(j=0;j&lt;no_of_row+2;j++)\n\r\n\r              {\n\r\n\r                     for(i=0;i&lt;no_of_col;i++)\n\r\n\r                     {\n\r\n\r                           printf(&quot;%f&quot;, vector[j][i]);\n\r\n\r                     }\n\r\n\r                     printf(&quot;%s\\n&quot;,&quot;&quot;);\n\r\n\r              }\n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Free the pointers */\n\r\n\r       for(i=0;i&lt;(no_of_row+2);i++)\n\r\n\r       {\n\r\n\r              free(vector[i]);\n\r\n\r       }\n\r\n\r       free(vector);\n\r\n\r}\n\r\n\r&nbsp;\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A softmax scaled matrix pointer&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","softmax_scaling","scr\\CVIP_C_functions/softmax_scaling.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-05T01:02:00Z  2004-10-20T00:16:00Z  1  184  1055  SIUE  8  2  1237  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     solve_c - solves the bilinear equation&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPhisto.h&quot;      #include &quot;CVIPfs.h&quot;      #include &quot;CVIPmesh.h&quot;&nbsp;     int  solve_c(struct  mesh_node   intie[4],struct   mesh_node     outtie[4],float *c)&nbsp;      &lt;intie&gt; - input tie points      &lt;outtie&gt; - output tie points      &lt;c&gt; - pointer to result array&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\warp.cDESCRIPTION     This function solves the following bilinear equation:         c[0]X_in + c[1]Y_in + (c[2]X_in Y_in) + c[3] = X_out         c[4]X_in + c[5]Y_in + (c[6]X_in Y_in) + c[7] = Y_out     where (X_in,Y_in) and (X_out,Y_out) are the  coordinates  of     each  tie point. It is called internally within mesh warping     functions.&nbsp;TYPES AND CONSTANTS     struct mesh_node {          int x;          int y;     }&nbsp;     struct mesh {          int width;          int height;          struct mesh_node** nodes;     }&nbsp;RETURN VALUES     Returns 1 upon successful completion&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     GEOMETRY library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Jianxin     Tan.&nbsp;\n\r\n\r&nbsp;","solve_c","scr\\CVIP_C_functions/solve_c.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  7  2  2004-06-05T01:03:00Z  2004-10-20T00:16:00Z  1  448  2560  SIUE  21  6  3002  10.3501    Clean                  MicrosoftInternetExplorer4 NAME     spatial_quant - reduces the  image  size  by  one  of  three     methods&nbsp;SYNOPSIS      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmatrix.h&gt;      #include &quot;CVIPgeometry.h&quot;&nbsp;     Image * spatial_quant(Image *cvipImage, int  row,  int  col,     int method)&nbsp;      &lt;cvipImage&gt; - pointer to an Image structure      &lt;row&gt; - number of rows for reduced image      &lt;column&gt; - number of columns for reduced image      &lt;method&gt; - reduction method to use where                       1 = average                       2 = median                       3 = decimationPATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\spatial_quant.cDESCRIPTION     spatial_quant allows the user to specify the number of  rows     and  columns  in  the  resultant image, corresponding to the     height and width of the new image.  The  integers  specified     for  row  and column sizes must be equal to or less than the     input image sizes or an error results.&nbsp;     Three methods are available for image reduction:     1) AVERAGE - each pixel in the new image represents an aver-     age of the original image pixels it replaces     2) MEDIAN - each pixel  in  the  new  image  represents  the     median value of the original image pixels it replaces     3) DECIMATION - each pixel in the new  image  has  the  same     value  as a corresponding pixel in the original image; other     original-image pixels are discarded&nbsp;     Because the user may enter different values for  height  and     width,  spatial_quant  may  be used to geometrically distort     the image in a rubber-sheet fashion.&nbsp;TYPES AND CONSTANTS     none&nbsp;RETURN VALUES     Returns a reduced image upon successful completion;  returns     NULL upon error in size specification.&nbsp;EXAMPLE       #include &lt;CVIPtoolkit.h&gt;       #include &lt;CVIPconvert.h&gt;       #include &lt;CVIPimage.h&gt;       #include &lt;CVIPmatrix.h&gt;       #include &quot;CVIPquant.h&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile, *outputfile;&nbsp;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;      system(&quot;ln -s /opt/cvipimages/Gray/lena.pgm lena.pgm&quot;);      print_CVIP(&quot;\\nqThis  demonstration  uses   the   decimation     method of spatial quantization.\\n\\n&quot;);      print_CVIP(&quot;Please enter the image \'lena.pgm\' at  the  fol-     lowing prompt:\\n\\n&quot;);      print_CVIP(&quot;Enter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      display_Image(inputfile,format);      cvipImage = (Image *)spatial_quant(cvipImage, 200,480,3);      print_CVIP(&quot;Enter the Output File Name:  &quot;);      outputfile = getString_CVIP();      write_Image(cvipImage,   outputfile,CVIP_NO,CVIP_NO,format,     1);      display_Image(outputfile,format);      free(inputfile);      free(outputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     none&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","spatial_quant","scr\\CVIP_C_functions/spatial_quant.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T01:04:00Z  2004-10-20T00:16:00Z  1  127  727  SIUE  6  1  853  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     specify_filter - create convolution mask&nbsp;SYNOPSIS      #include &quot;CVIPtools.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPfs.h&quot;      #include &quot;CVIPmatrix.h&quot;      #include &quot;CVIPspfltr.h&quot;&nbsp;     Matrix * specify_filter(int row, int col, float** temp)&nbsp;      &lt;row&gt; - number of rows of mask      &lt;col&gt; - number of columns of mask      &lt;temp&gt; - mask value array&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\spatial_tools.cDESCRIPTION     Creates a convolution mask of size &lt;row&gt;x&lt;col&gt;, filled  with     values from the array &lt;temp&gt;.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A matrix to be used as a convolution mask&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh, Greg Hance,  and     Kun Luo.&nbsp;\n\r\n\r&nbsp;","specify_filter","scr\\CVIP_C_functions/specify_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  3  2004-06-05T01:05:00Z  2004-10-20T00:17:00Z  1  388  2217  SIUE  18  5  2600  10.3501    Clean                  MicrosoftInternetExplorer4 NAME     speckle_noise - Add speckle noise to an image&nbsp;SYNOPSIS     #include &quot;CVIPnoise.h&quot;&nbsp;     Image   *speckle_noise(Image   *imageP,float    *psalt,float     *ppepper);&nbsp;      &lt;imageP&gt; - pointer to Image structure      &lt;psalt&gt; - probability of salt noise (high gray level = 255)      &lt;ppepper&gt; - probability of pepper noise (low gray  level  =     0)PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\spatial_tools.c&nbsp;DESCRIPTION     Speckle noise, also called &quot;salt  and  pepper&quot;  type  noise,     typically occurs in images that are acquired by cameras con-     taining malfunctioning pixels.  Salt  and  Pepper  noise  is     named  after  the  white  and  black  appearance  it adds to     images.&nbsp;     The float pblack represents the probability of a pixel being     &quot;black&quot;,   or  0  in  grey-level,  while  the  float  pwhite     represents the probability of a pixel being &quot;white&quot;, or 255.     Note: the sum of pblack and pwhite cannot exceed 1.0.&nbsp;RETURN VALUES     The speckle_noise()  function  returns  the  modified  Image     pointer on success, and returns a NULL pointer on failure&nbsp;BUGS     none&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;CVIPnoise.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      float psalt=0.1;      float ppepper=0.2;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call adds speckle noise to the input      image with the probability of high grey levels equal      to 0.1 and the probability of low grey levels equal to      0.2.We can use the function speckle_noise_setup so      that the user can  specify the inputs  */      cvipImage = speckle_noise(cvipImage,&amp;psalt,&amp;ppepper);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     gamma_noise(3),     gaussian_noise(3),     neg_exp_noise(3),     rayleigh_noise(3), uniform_noise(3)&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and     David Lyons.&nbsp;\n\r\n\r&nbsp;","speckle_noise","scr\\CVIP_C_functions/speckle_noise.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  7  10  2004-06-05T01:06:00Z  2004-08-06T21:48:00Z  1  723  4127  SIUE  34  9  4841  10.3501                    MicrosoftInternetExplorer4 NAME     spectral_feature - calculates total power spectrum in each     band and sector over half image&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPimage.h&quot;      #include &quot;newfeature.h&quot;&nbsp;     POWER  * spectral_feature(Image  *  originalImage,  Image   *     labeledImage, int no_of_bands, int no_of_sectors, int r, int     c)&nbsp;      &lt;originalImage&gt; - pointer to the original image      &lt;labeledImage&gt; -  Pointer to the labeled image      &lt;no_of_bands&gt; -   number of bands      &lt;no_of_sectors&gt; - number of sectors      &lt; r &gt; - row coordinate of a point on the labeled image      &lt; c &gt; - column coordinate of a point on the labeled image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\spectral_feature.cDESCRIPTION     Half of the frequency domain of the object  of  interest  is     divided  into  &lt;no_of_rings&gt;  rings and &lt;no_of_sectors&gt; sec-     tors, that is to say, all sectors have  equal  angles,  dis-     tances  between  neighboring  rings are equal. The frequency     domain is got by performing forward  FFT  on  image  of  the     object  of  interest.  The object of interest is selected by     the  point  of  coordinates  &lt;r,c&gt;  on  the  labeled  image.     power_fft()  returns  dc_normalized  values  of  total power     spectrum in each ring and sector. \'dc_normalized\' means  all     total  power  spectrums  are divided by the value of dc com-     ponent (the value before divided by N*N). For dc  component,     it  is divided by pow(N, 4) before returned to make it to be     the power spectrum of the average value of all pixels in the     object  image. N is equal to the image size of the object of     interest(an N*N image).&nbsp;TYPES AND CONSTANTS     POWER is defined in $CVIPtoolsHOME/include/newfeature.h as follows:&nbsp;\n\r\n\r          typedef struct\n\r\n\r     {\n\r\n\r       intno_of_sectors;\n\r\n\r       intno_of_bands;\n\r\n\r       intimagebands;\n\r\n\r       double *dc;\n\r\n\r       double *sector;\n\r\n\r       double *band;     } POWER;&nbsp;     If the original image is a color image, the first no_of_bands     and no_of_sectors values pointed to by \'dc\', \'sector\', and     values pointed to by those pointers are for band 1, and so on.&nbsp;RETURN VALUES     A pointer to a structure named  POWER  containing  spectral     Features data&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPobject.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;      #include &quot;newfeature.h&quot;&nbsp;      void main()      {         Image *inputImage, *labeledImage,*inputImage1;         IMAGE_FORMAT format;         char *inputfile, *outputfile;         int rows, cols, r, c,k,i;         POWER *PP;         int bands,no_rings,no_sectors;&nbsp;         setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;         print_CVIP(&quot;\\nEnter the Input File Name:  &quot;);         inputfile = (char *) getString_CVIP();         inputImage = read_Image(inputfile,1);         view_Image(inputImage,inputfile);         inputImage1=(Image *)duplicate_Image(inputImage);         labeledImage = label(inputImage);         rows = getNoOfRows_Image(labeledImage);         cols = getNoOfCols_Image(labeledImage);         bands = getNoOfBands_Image(labeledImage);         print_CVIP(&quot;\\nEnter the row coordinate of a point         on the labled image: &quot;);         r = getInt_CVIP(10, 0, rows);         print_CVIP(&quot;\\nEnter the col coordinate of the point         on the labled image: &quot;);         c = getInt_CVIP(10, 0, cols);         print_CVIP(&quot;\\nEnter the number of rings: &quot;);         no_rings = getInt_CVIP(10, 0,10);         print_CVIP(&quot;\\nEnter the number of sectors: &quot;);         no_sectors = getInt_CVIP(10, 0,10);         PP=spectral_feature(inputImage1,labeledImage,         no_rings,no_sectors,r,c);         print_CVIP(&quot;The spectral features of the input image         are:&quot;);         for (k=0; k&lt;bands; k++)         {              print_CVIP(&quot;Spectral DC value band%d =%f&quot;,k,              (PP-&gt;dc)[k]);              for (i=0; i&lt;PP-&gt;no_of_bands; i++)                 print_CVIP(&quot;Ring%d=%f\\n &quot;,i+1,(PP-&gt;band)                 [k*PP-&gt;no_of_bands + i]);&nbsp;              for (i=0; i&lt;PP-&gt;no_of_sectors; i++)                 print_CVIP(&quot;Sector%d=%f\\n &quot;,i,(PP-&gt;sector)                 [k*PP-&gt;no_of_sectors + i]);         }&nbsp;         free(inputfile);         free((char *)PP-&gt;dc);         free((char *)PP-&gt;sector);         free((char *)PP-&gt;band);         free((char *)PP);         free(inputImage);         free(inputImage1);         free(labeledImage);&nbsp;       }&nbsp;DIAGNOSTICS     The original image can  be  of  any  of  these  data  types:     CVIP_BYTE,    CVIP_SHORT,   CVIP_INTEGER,   CVIP_FLOAT   and     CVIP_DOUBLE.&nbsp;SEE ALSO     FEATURE library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","spectral_feature","scr\\CVIP_C_functions/spectral_feature.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  4  2004-06-05T01:07:00Z  2004-10-20T00:17:00Z  1  139  798  SIUE  6  1  936  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     spher_inv_xform - spherical inverse transfor&nbsp;SYNOPSIS     void  spher_inv_xform(float  **cvecP,  unsigned  long  vdim,     float Xo, float Yo, float Zo)&nbsp;      &lt;cvecP&gt; - pointer to an array of normalized band vectors      &lt;vdim&gt; - dimension of each vector (number of pixels)      &lt;Xo&gt; - reference white for red      &lt;Yo&gt; - reference white for green      &lt;Zo&gt; - reference white for blue&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COLOR\\cxform.cDESCRIPTION     This function  performs  SCT  to  RGB  color  transformation     according to the following equations:&nbsp;                   r = rho * sin(phi) * cos(theta)                   g = rho * sin(phi) * sin(theta)                   b = rho * cos(phi)&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     None&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     COLOR library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","spher_inv_xform","scr\\CVIP_C_functions/spher_inv_xform.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T01:10:00Z  2004-10-20T00:17:00Z  1  1409  8035  SIUE  66  18  9426  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     split_merge_segment - Setup for Split and Merge Segmentation&nbsp;SYNOPSIS      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;split_merge.h&quot;      #include &quot;CVIPtexture.h&quot;&nbsp;      Image *split_merge_segment(Image *imgP, unsigned int level,      unsigned  int  choice,   void   *parameters,   CVIP_BOOLEAN     Run_PCT)&nbsp;      Image *multi_resolution_segment(Image *imgP,      unsigned  int  choice,   void   *parameters,   CVIP_BOOLEAN     Run_PCT)&nbsp;      &lt;srcImage&gt; - pointer to source Image structure      &lt;level&gt; - the level to begin procedure      &lt;choice&gt; - Predicate test chosen         (1) pure uniformity         (2) local mean vs. global         (3) local std. deviation vs. global mean         (4) Number of pixels within 2 x standard deviation         (5) Weighted gray level distance test         (6) Texture Homogeneity Test      &lt;parameters&gt; - Parameters used determined by predicate test      &lt;Run_PCT&gt; - Choice to run PCT on color images&nbsp;      QUAD_LIST split_merge_generic(Image *srcImage,      CVIP_BOOLEAN (*const pt)(Image *, QUAD *, void *),      void *pt_paramP, unsigned int level)&nbsp;      &lt;srcImage&gt; - pointer to source Image structure      &lt;pt&gt; - pointer to the homogeneity test function      &lt;pt_paramP&gt; - pointer to the parameters required by &lt;pt&gt;      &lt;level&gt; - the level to begin procedurePATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\split_merge.c,      splitnMerge.c(split_merge_generic)&nbsp;DESCRIPTION     split_merge_generic  is   the   basic   function   for   the     split_and_merge  algorithm.   A  homogeneity test is used to     determine if the Region of Interest is homogeneous, if it is     then  all  the pixels in that region are replaced with their     average (in the segmented image).&nbsp;     The level to begin the split and merge  is  related  to  the     size  of the beginning region, specifically, the smaller the     number the larger the beginning region.&nbsp;     The chosen homogeneity test is the test that is to  be  used     throughout the split and merge segmentation process.&nbsp;     split_merge_segment is the most frequently  used  one  among     the  three  functions,  which provides six homgeneity tests.     Some of the tests require additional parameters, The 6 tests     (and their additional parameter descriptions) available are:          (1) Pure Uniformity:  Region is considered  homogeneous     if  the  region  is  completely uniform, i.e. all the pixels     have the same gray value. (Additional Parameters - None).          (2) Local Mean vs. Global Mean:  Region  is  considered     homogeneous  if  the  local  mean is greater than the global     mean. (Additional Parameters - None).          (3) Local Standard Deviation vs. Global  Mean:   Region     is considered homogeneous if the local standard deviation is     less than 10% of the global mean. (Additional  Parameters  -     None).          (4) Variance Test:  Region is considered homogeneous if     at  least  X%  of the pixels are within 2 sigma of the local     mean, unless the standard deviation exceeds a maximum thres-     hold. (Additional Parameters - \'X\' percentage (float *) e.g.     X = .80 for 80%, Threshold (float *) e.g. 80)          (5)  Weighted  Gray  Level  Distance  Test:   A   total     weighted  gray level value is computed based on the mode and     the gray level distance from the mode weighted by  the  gray     level distribution.  If this value is less than a threshold,     then they region  is  considered  homogeneous.   (Additional     Parameters - Threshold (float *) e.g. 30)          (6) Texture Homogeneity test:  Compares the  four  qua-     drants  of the Region, using 5 of the textural features (See     GUI_Texture_SetUp(...)), if the  quadrants  are  similar  to     each  other then the region is considered homogenous. (Addi-     tional Parameters - Similarity measure (float *)  e.g.  .40,     Pixel distance (float *) e.g. 3)&nbsp;     To choose the homogeneity test, pass the number of the test.&nbsp;     &lt;parameters&gt; refer to the parameters as illustrated  in  the     test descriptions above.&nbsp;     &lt;RUN_PCT&gt;: if the image is a multi-band image and RUN_PCT is     CVIP_YES,  a  PCT_Image(...)  will  be  done on the image to     transform it down to a single band image, prior to doing the     split and merge segmentation. If RUN_PCT is CVIP_NO then the     split and merge segmentation will be performed on each band,     all bands must pass the homogeneity test in order to be con-     sidered homogeneous.&nbsp;     multi_resolution_segment   is   exactly    the    same    as     split_merge_segment,  except that the level is fixed to 0 in     multi_resolution_segment.&nbsp;BUGS     Runs somewhat  slowly  dependent  on  the  homogeneity  test     chosen.  The weighted Gray level distance test is noticeably     slower than the first 4 tests.&nbsp;     The Texture Test runs extremely slow compared to the other 5     tests,  the  more  non-homogeneous  the  image the slower it     runs.&nbsp;     The Texture Test also does a very poor job of memory manage-     ment.   Will  consume  a large amount of memory and then not     release it until the entire program  is  exited.   The  more     non-homogeneous the image the more memory is consumed.&nbsp;TYPES AND CONSTANTS     #include &lt;stdio.h&gt;     #include &lt;stdlib.h&gt;     #include &quot;CVIPdef.h&quot;     #include &quot;CVIPtoolkit.h&quot;     #include &quot;split_merge.h&quot;     #include &quot;CVIPtexture.h&quot;&nbsp;     typedef struct  {      /* [0] -&gt; 0 degree, [1] -&gt; 45 degree, [2] -&gt; 90 degree, [3] -&gt; 135 degree, [4] -&gt; average, [5] -&gt; range (max - min) */      float ASM[6];          /*  (1) Angular Second Moment */      float contrast[6];     /*  (2) Contrast */      float correlation[6];  /*  (3) Correlation */      float variance[6];     /*  (4) Variance */      float IDM[6];          /*  (5) Inverse Diffenence Moment */      float sum_avg[6];      /*  (6) Sum Average */      float sum_var[6];      /*  (7) Sum Variance */      float sum_entropy[6];  /*  (8) Sum Entropy */      float entropy[6];      /*  (9) Entropy */      float diff_var[6];     /* (10) Difference Variance */      float diff_entropy[6]; /* (11) Diffenence Entropy */      float meas_corr1[6];   /* (12) Measure of Correlation 1 */      float meas_corr2[6];   /* (13) Measure of Correlation 2 */      float max_corr_coef[6];/* (14) Maximal Correlation Coefficient */      } TEXTURE;&nbsp;     typedef struct {      /* Allows the user to choose which features to extract, a zero will cause        the feature to be ignored, the returned feature value will be 0.0 */      int ASM;               /*  (1) Angular Second Moment */      int contrast;          /*  (2) Contrast */      int correlation;       /*  (3) Correlation */      int variance;          /*  (4) Variance */      int IDM;               /*  (5) Inverse Diffenence Moment */      int sum_avg;           /*  (6) Sum Average */      int sum_var;           /*  (7) Sum Variance */      int sum_entropy;       /*  (8) Sum Entropy */      int entropy;           /*  (9) Entropy */      int diff_var;          /* (10) Difference Variance  */      int diff_entropy;      /* (11) Diffenence Entropy  */      int meas_corr1;        /* (12) Measure of Correlation 1 */      int meas_corr2;        /* (13) Measure of Correlation 2 */      int max_corr_coef;     /* (14) Maximal Correlation Coefficient */      } TEXTURE_FEATURE_MAP;&nbsp;     typedef struct quad QUAD;      struct quad {  /* quadrant definitions */      byte data[3];      unsigned int x;      unsigned int y;      unsigned int dx;      unsigned int dy;      QUAD *lower_right;      QUAD *lower_left;      QUAD *upper_right;      QUAD *upper_left;     };&nbsp;     typedef struct stack STACK;      struct stack {      QUAD *key;      STACK *next;     } ;&nbsp;     typedef struct quad_list_item* QUAD_LIST;      struct quad_list_item {      QUAD *q;      QUAD_LIST next;     };&nbsp;RETURN VALUES     Pointer to Image structure  containing  segmented  image  on     success; a NULL pointer on failure.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE     The   following   example   uses    the    setup    function     &quot;split_merge_setup&quot;  to  get  keyboard input for the parame-     ters. Refer $CVIPHOME/split_merge.c for  more  detail  about     the function.&nbsp;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPsegment.h&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile, *outputfile;&nbsp;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);      print_CVIP(&quot;0Enter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      cvipImage = (Image *) split_merge_setup(cvipImage);      print_CVIP(&quot;0Enter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage, outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(inputfile);      free(outputfile);      }&nbsp;SEE ALSO     SEGMENTATION library, predicate_test, quadtree2ras&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh,  Greg  Hance,     and Steven M. Costello.&nbsp;\n\r\n\r&nbsp;","split_merge_segment","scr\\CVIP_C_functions/split_merge_segment.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  3  2004-06-05T01:11:00Z  2004-10-20T00:17:00Z  1  143  816  SIUE  6  1  958  10.3501    Clean                  MicrosoftInternetExplorer4 NAME     sqrt_Matrix - computes the square root of a matrix.&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPmatrix.h&quot;&nbsp;     Matrix *sqrt_Matrix(Matrix *in)&nbsp;      &lt;in&gt; - input Matrix;PATH     $CVIPtoolsHOME\\CVIPC\\MatrixAlgebra\\m_sqrt.cDESCRIPTION     This function calculates  the  square  root  of  the  passed     matrix  structure  and  returns  the  result in a new Matrix     structure.  All data types less precise than float are  pro-     moted to float.  CVIP_DOUBLE matrices are supported, as well     as COMPLEX matrices.&nbsp;     The passed matrix structure is freed.&nbsp;TYPES AND CONSTANTS     See libmatrix.3&nbsp;RETURN VALUES     Pointer to Matrix structure containing the  square  root  of     the passed Matrix.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE&nbsp;BUGS     None at this time&nbsp;SEE ALSO     MatrixAlgebra library, cbrt_Matrix()&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Arve Kjoelen&nbsp;\n\r\n\r&nbsp;","sqrt_Matrix","scr\\CVIP_C_functions/sqrt_Matrix.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T01:14:00Z  2004-10-20T00:17:00Z  1  166  950  SIUE  7  2  1114  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     square_mag_Matrix - calculate the  squared  magnitude  of  a     matrix.&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;CVIPmatrix.h&quot;&nbsp;     Matrix *square_mag_Matrix(Matrix *in)&nbsp;      &lt;in&gt; - input Matrix;&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\MatrixAlgebra\\m_magnitude.cDESCRIPTION     This function calculates the square of the magnitude of  the     passed  matrix  structure  and  returns  the result in a new     Matrix structure.&nbsp;TYPES AND CONSTANTS     See libmatrix.3&nbsp;RETURN VALUES     Pointer to matrix structure containing the squared magnitude     of  the  Matrix at each point.  This Matrix is REAL.  If the     input matrix format is REAL, the result  is  computed  using     multPWise_Matrix().   If the input Matrix format is COMPLEX,     the return matrix is of type CVIP_DOUBLE if the input Matrix     is of type CVIP_DOUBLE, and of type CVIP_FLOAT otherwise.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE&nbsp;BUGS     None at this time&nbsp;SEE ALSO     MatrixAlgebra library, mag_Matrix()&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott Umbaugh and Arve Kjoelen&nbsp;\n\r\n\r&nbsp;","square_mag_Matrix","scr\\CVIP_C_functions/square_mag_Matrix.htm","   ACADEMIC COMPUTING  Normal  akharba  13  5  2005-07-02T21:04:00Z  2006-07-08T22:29:00Z  1  538  3069  SIUE  25  7  3600  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        standard_normal_density_normalization – normalizes a 2D matrix using standard                                                  normal density normalization method&nbsp;SYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;stdlib.h&quot;&nbsp;      float **standard_normal_density_normalization(float **vector, int i, int j, int option, int *err_code)&nbsp;&lt;vector&gt; - 2D pointer to a matrix&lt;i&gt; - number of columns in the matrix      &lt;j&gt; - number of rows in the matrix      &lt;option&gt; - 0 – to normalize the training set                 1 – to normalize the test set      &lt;err_code&gt; - pointer to the error code; use 0 for no error&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\standard_normal_density_normalization.c&nbsp;DESCRIPTION     This function normalizes a matrix using standard normal density normalization     method. The formula used for standard normal density normalization is given in      chapter 6 of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineno_of_col 2\n\r\n\r#defineno_of_row 3\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       float  **vector;\n\r\n\r       int           i,j;\n\r\n\r       int           option= 0;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r&nbsp;\n\r\n\r       /* Memory allocation. The size of vectoris (no_of_row+2)*no_of_col */\n\r\n\r       vector =malloc((no_of_row+2)*sizeof(float *));\n\r\n\r&nbsp;\n\r\n\r       for(i=0;i&lt;(no_of_row+2);i++)\n\r\n\r       {\n\r\n\r              vector[i] =malloc(no_of_col*sizeof(float));           \n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Get the vectors. The items should beseparated by &quot;,&quot;. vector[0][0],vector[0][1],...vector[row][col] */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector: &quot;);\n\r\n\r       for(j=0;j&lt;no_of_row;j++)\n\r\n\r       {\n\r\n\r              for(i=0;i&lt;no_of_col;i++)\n\r\n\r              {\n\r\n\r                     scanf(&quot;%f,&quot;,&amp;vector[j][i]);\n\r\n\r              }\n\r\n\r              \n\r\n\r       }\n\r\n\r       \n\r\n\r       /* Call c function, and return thevector. option is 0, means the vector comes from training set */\n\r\n\r       vector =standard_normal_density_normalization (vector, no_of_col, no_of_row, option,err_code);\n\r\n\r&nbsp;\n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }\n\r\n\r       else\n\r\n\r       {\n\r\n\r              /* Print out the result */\n\r\n\r              for(j=0;j&lt;no_of_row+2;j++)\n\r\n\r              {\n\r\n\r                     for(i=0;i&lt;no_of_col;i++)\n\r\n\r                     {\n\r\n\r                           printf(&quot;%f&quot;, vector[j][i]);\n\r\n\r                     }\n\r\n\r                     printf(&quot;%s\\n&quot;,&quot;&quot;);\n\r\n\r              }\n\r\n\r       }      \n\r\n\r       /* The last row in the vector is fornormalize another vector. Typically, from test set. */\n\r\n\r&nbsp;\n\r\n\r       /* Get another vectors. The items shouldbe separated by &quot;,&quot;. vector[0][0],vector[0][1],...vector[row][col] */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in another vector: &quot;);\n\r\n\r       for(j=0;j&lt;no_of_row;j++)\n\r\n\r       {\n\r\n\r              for(i=0;i&lt;no_of_col;i++)\n\r\n\r              {\n\r\n\r                     scanf(&quot;%f,&quot;,&amp;vector[j][i]);\n\r\n\r              }\n\r\n\r              \n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       option = 1;\n\r\n\r       /* Call c function, and return thevector. option is 1, means the vector comes from test set */\n\r\n\r       vector =standard_normal_density_normalization (vector, no_of_col, no_of_row+2, option,err_code);\n\r\n\r&nbsp;\n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }\n\r\n\r       else\n\r\n\r       {\n\r\n\r              /* Print out the result */\n\r\n\r              for(j=0;j&lt;no_of_row+2;j++)\n\r\n\r              {\n\r\n\r                     for(i=0;i&lt;no_of_col;i++)\n\r\n\r                     {\n\r\n\r                           printf(&quot;%f&quot;, vector[j][i]);\n\r\n\r                     }\n\r\n\r                     printf(&quot;%s\\n&quot;,&quot;&quot;);\n\r\n\r              }\n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Free the pointers */\n\r\n\r       for(i=0;i&lt;(no_of_row+2);i++)\n\r\n\r       {\n\r\n\r              free(vector[i]);\n\r\n\r       }\n\r\n\r       free(vector);\n\r\n\r}\n\r\n\r&nbsp;\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A standard normal density normalized matrix pointer&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","standard_normal_density_normalization","scr\\CVIP_C_functions/standard_normal_density_normalization.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T01:15:00Z  2004-10-20T00:18:00Z  1  272  1557  SIUE  12  3  1826  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     subtract_Image - subtracts two images&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIParithlogic.h&quot;      #include   &quot;CVIPconvert.h&quot;   Image    *subtract_Image(Image     *inputImage1,Image *inputImage2)&nbsp;      &lt;inputImage1&gt; - pointer to an Image structure      &lt;inputImage2&gt; - pointer to an Image structurePATH     $CVIPtoolsHOME\\CVIPC\\ARITHLOGIC\\arithlogic.c&nbsp;DESCRIPTION     This function uses the CVIP function \'sub_Matrix\' to perform     bitwise  subtractition  of  two images. Complex matrices are     supported.&nbsp;TYPES AND CONSTANTS      #define MATPWISE_DEFINED&nbsp;RETURN VALUES     A subtracted image.&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &quot;CVIPimage.h&quot;      #include &quot;CVIParithlogic.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;      void main() {        Image *inputImage1, *inputImage2, *outputImage;        IMAGE_FORMAT format;        char *inputfile1, *inputfile2, *outputfile;&nbsp;        setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;        print_CVIP(&quot;\\n\\tEnter the first Input File Name:  &quot;);        inputfile1 =(char *) getString_CVIP();        inputImage1 = read_Image(inputfile1, 1);        view_Image(inputImage1,inputfile1);        free(inputfile1);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the second Input File Name:  &quot;);        inputfile2 =(char *) getString_CVIP();        inputImage2 = read_Image(inputfile2, 1);        view_Image(inputImage2,inputfile2);        free(inputfile2);&nbsp;        outputImage = subtract_Image(inputImage1, inputImage2);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);        outputfile = getString_CVIP();        view_Image(outputImage,outputfile);        free(outputfile);&nbsp;      }&nbsp;SEE ALSO     ARITHLOGIC library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Greg     Hance.&nbsp;\n\r\n\r&nbsp;","subtract_Image","scr\\CVIP_C_functions/subtract_Image.htm","   ACADEMIC COMPUTING  Normal  akharba  6  4  2005-07-02T20:05:00Z  2006-07-08T22:29:00Z  1  320  1825  SIUE  15  4  2141  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        tanimoto_metric – calculates the tanimoto similarity metric&nbsp;SYNOPSIS#include &quot;math.h&quot;#include &quot;stdio.h&quot;     float tanimoto_metric(float *vector1, float *vector2, int n, int *err_code)      &lt;vector1&gt; - pointer to an input array&lt;vector2&gt; - pointer to an input array      &lt;n&gt; - number of elements (features) in the array      &lt;err_code&gt; - pointer to the error code  &nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\tanimoto_metric.c&nbsp;DESCRIPTION     This function calculates the Tanimoto similarity      measure from the elements of the two arrays. The formula      used for the calculation is given in chapter 6 of the      following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r&nbsp;\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 3\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       float  *vector1;\n\r\n\r       float  *vector2;\n\r\n\r       float  result;\n\r\n\r       int           i;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r&nbsp;\n\r\n\r       vector1 = malloc(MAX_CASE*sizeof(float));\n\r\n\r       vector2 = malloc(MAX_CASE*sizeof(float));\n\r\n\r&nbsp;\n\r\n\r       /* Get the vectors. The items should beseparated by &quot;,&quot; */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector1: &quot;);\n\r\n\r       for(i=0;i&lt;MAX_CASE;i++)\n\r\n\r       {\n\r\n\r              scanf(&quot;%f,&quot;,&amp;vector1[i]);\n\r\n\r       }\n\r\n\r       \n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector1: &quot;);\n\r\n\r       for(i=0;i&lt;MAX_CASE;i++)\n\r\n\r       {\n\r\n\r              scanf(&quot;%f,&quot;,&amp;vector2[i]);\n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       result = tanimoto_metric(vector1,vector2, MAX_CASE, err_code);\n\r\n\r&nbsp;\n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }\n\r\n\r       else\n\r\n\r       {\n\r\n\r              /* Print out the result */\n\r\n\r              printf(&quot;result=%f\\n&quot;,result);\n\r\n\r       }      \n\r\n\r&nbsp;\n\r\n\r       /* Free the pointers */\n\r\n\r       free(vector1);\n\r\n\r       free(vector2);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A float number representing the Tanimoto similarity measure&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;\n\r\n\r&nbsp;","tanimoto_metric","scr\\CVIP_C_functions/tanimoto_metric.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T01:20:00Z  2004-10-20T00:18:00Z  1  812  4630  SIUE  38  10  5432  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     texture - Texture Feature Extraction&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;string.h&quot;      #include &quot;math.h&quot;      #include &quot;CVIPsegment.h&quot;      #include &quot;adaptThresh.h&quot;      #include &quot;stdio.h&quot;      #include &quot;string.h&quot;      #include &quot;CVIPtexture.h&quot;      #include &quot;CVIPtransform.h&quot;&nbsp;     TEXTURE * texture( const Image *ImgP, const Image *segP, int     band, int r, int c, long int hex_equiv, int distance)&nbsp;     Parameters:      &lt;ImgP&gt; - pointer to source Image structure      &lt;segP&gt; - pointer to labeled Image structure      &lt;band&gt; - the band of the source image to be worked on      &lt;r&gt; -  the row co-ordinate of the object      &lt;c&gt; -  the column co-ordinate of the object      &lt;hex_equiv&gt; - the hex equivalent of the Texture feature map      &lt;distance&gt; -  the  pixel  distance  to  calculate  the  co-     occurence matrixPATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\CVIP_textureSetUp.c&nbsp;DESCRIPTION     Calculates  the  14  textural  features  based  on  the  co-     occurrence  matrices  at 0, 45, 90, and 135 degrees. See the     structure &quot;TEXTURE&quot; for the 14 features.  The input  parame-     ter  &lt;distance&gt;  is  used  in  calculating  the co-occurence     matrices.  The average and range of the four  directions  is     also calculated and returned for each feature.&nbsp;     The algorithms for calculating the 14 textural features  are     taken  from  R.M.  Haralick,  K. Shanmugam, and I. Dinstein.     1973. Textural  features  for  image  classification.  &quot;IEEE     Transactions on Systems, Man, and Cybertinetics, SMC-3 (6) :     610-621.&nbsp;     The input parameter &lt;hex_equiv&gt; is used to signal  which  of     the    14    features    to    find.     See    the   struct     &quot;TEXTURE_FEATURE_MAP&quot; for each features hex value.  To  cal-     culate  more  than  one feature at a time simply add the hex     values together. Features that are not selected to be calcu-     lated  will  be  set  to zero. The function will only do one     band of the image, the input parameter  &lt;band&gt;  is  used  to     select which band to extract the features from.&nbsp;     Gray level values of zero will be ignored, they will not  be     used in the features calculations.&nbsp;     The code for implementing  the  algrorithm  was  taken  from     another  program  written  by  James Darrell McCauley, Texas     Agricultural Experiment Station, Texas A&amp;M  University   The     algorithms were used as coded with some minor modifications.&nbsp;TYPES AND CONSTANTS     typedef struct  {      /* [0] -&gt; 0 degree, [1] -&gt; 45 degree, [2] -&gt; 90 degree, [3] -&gt; 135 degree, [4] -&gt; average, [5] -&gt; range (max - min) */      float ASM[6];          /*  (1) Angular Second Moment */      float contrast[6];     /*  (2) Contrast */      float correlation[6];  /*  (3) Correlation */      float variance[6];     /*  (4) Variance */      float IDM[6];          /*  (5) Inverse Diffenence Moment */      float sum_avg[6];      /*  (6) Sum Average */      float sum_var[6];      /*  (7) Sum Variance */      float sum_entropy[6];  /*  (8) Sum Entropy */      float entropy[6];      /*  (9) Entropy */      float diff_var[6];     /* (10) Difference Variance */      float diff_entropy[6]; /* (11) Diffenence Entropy */      float meas_corr1[6];   /* (12) Measure of Correlation 1 */      float meas_corr2[6];   /* (13) Measure of Correlation 2 */      float max_corr_coef[6];/* (14) Maximal Correlation Coefficient */      } TEXTURE;&nbsp;     typedef struct {      /* Allows the user to choose which features to extract, a zero will cause        the feature to be ignored, the returned feature value will be 0.0 */      int ASM;               /*  (1) Angular Second Moment (hex_equiv 0x0001) */      int contrast;          /*  (2) Contrast (hex_equiv 0x0002) */      int correlation;       /*  (3) Correlation (hex_equiv 0x0004) */      int variance;          /*  (4) Variance (hex_equiv 0x0008) */      int IDM;               /*  (5) Inverse Diffenence Moment (hex_equiv 0x0010) */      int sum_avg;           /*  (6) Sum Average (hex_equiv 0x0020) */      int sum_var;           /*  (7) Sum Variance (hex_equiv 0x0040) */      int sum_entropy;       /*  (8) Sum Entropy (hex_equiv 0x0080) */      int entropy;           /*  (9) Entropy (hex_equiv 0x0100) */      int diff_var;          /* (10) Difference Variance (hex_equiv 0x0200) */      int diff_entropy;      /* (11) Diffenence Entropy  (hex_equiv 0x0400) */      int meas_corr1;        /* (12) Measure of Correlation 1 (hex_equiv 0x0800) */      int meas_corr2;        /* (13) Measure of Correlation 2 (hex_equiv 0x1000) */      int max_corr_coef;     /* (14) Maximal Correlation Coefficient (hex_equiv 0x2000) */      } TEXTURE_FEATURE_MAP;&nbsp;RETURN VALUES     Pointer to a Texture Feature structure&nbsp;HISTORY     History information recorded: None&nbsp;BUGS     Runs slow with large objects (speed is also dependent on the     number of different gray levels present in the image).&nbsp;     The Maximal Correlation Coefficient  does  not  always  con-     verge,  a NULL will be returned as its data.  Calculation of     the Maximal Correlation Coefficient can take  a  long  time,     especially if it does not converge&nbsp;SEE ALSO     FEATURE library, cvip_pgmtexture.c&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and  Steven  M     Costello.&nbsp;\n\r\n\r&nbsp;","texture","scr\\CVIP_C_functions/texture.htm","   ACADEMIC COMPUTING  hari  17  18  2004-06-05T01:20:00Z  2010-07-05T03:49:00Z  2  361  1961  SIUE  80  56  2575  11.5606    150  Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME     texture2 - Texture Feature Extraction&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;string.h&quot;      #include &quot;math.h&quot;      #include &quot;CVIPsegment.h&quot;      #include &quot;adaptThresh.h&quot;      #include &quot;stdio.h&quot;      #include &quot;string.h&quot;      #include &quot;CVIPtexture.h&quot;      #include &quot;CVIPtransform.h&quot;&nbsp;\n\r\n\rTEXTURE2 *texture2(Image*inputImage, Image *labeledImage, int band, int row, int col, int distance, intenergy, int inertia, int correlation, int invDiff, int entropy,  int zero_rowcol)&nbsp;     Parameters:\n\r\n\r            &lt;inputImage&gt;- pointer to source Image structure\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;labeledImage&gt; - pointer to labeledImage structure\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;band&gt; - the band of the source image to beworked on\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;row&gt; -&nbsp; therow co-ordinate of the object\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;col&gt; -&nbsp; thecolumn co-ordinate of the object\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;distance&gt; -&nbsp; the&nbsp; pixel&nbsp;distance&nbsp; used to&nbsp; calculate&nbsp; the&nbsp; co-occurencematrix      &lt;energy&gt; -  flag for calculating energy, 0 (no) or 1 (yes)      &lt;inertia&gt; -  flag for calculating inertia, 0 (no) or 1 (yes)      &lt;correlation&gt; - flag for calculating correlation, 0 (no) or 1 (yes)      &lt;invDiff&gt; - flag for calculating inverse difference, 0 (no) or 1 (yes)      &lt;entropy&gt; - flag for calculating entropy, 0 (no) or 1 (yes)      &lt;zero_rowcol&gt; - flag to include pixels pairs with zeros, 0 (no – used for masked image objects) or 1 (yes)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\Texture_Features.c&nbsp;DESCRIPTION     Calculates  the  5  textural  features  based  on  the  co-     occurrence  matrices  at 0, 45, 90, and 135 degrees. See the     structure &quot;TEXTURE&quot; for the 5 features.  The input  parame-     ter  &lt;distance&gt;  is  used  in  calculating  the co-occurence     matrices.  The average and range of the four  directions  is     also calculated and returned for each feature.&nbsp;     The function will only do one band of the image, the input parameter      &lt;band&gt;  is  used  to select which band to extract the features from.&nbsp;     TYPES AND CONSTANTS     typedef struct  {      /* [0] -&gt; 0 degree, [1] -&gt; 45 degree, [2] -&gt; 90 degree, [3] -&gt; 135 degree, [4] -&gt; average, [5] -&gt; range (max - min) */\n\r\n\r            float energy[6];  /*  (1) Energy */\n\r\n\r      float inertia[6];  /*  (2)Inertia */\n\r\n\r      floatcorrelation[6];   /*  (3) Correlation */\n\r\n\r      float IDM[6];           /* (4) Inverse Difference Moment */      float entropy[6];        /*  (5) Entropy */      } TEXTURE2;&nbsp;RETURN VALUES     Pointer to a Texture Feature structure&nbsp;HISTORY     History information recorded: None&nbsp;BUGS     none&nbsp;AUTHOR     Copyright (C) 2010, SIUE - by Scott E. Umbaugh and Jhansi Lakshmi Akkineni      &nbsp;\n\r\n\r&nbsp;","texture2","scr\\CVIP_C_functions/texture2.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T01:21:00Z  2004-10-20T00:18:00Z  1  165  942  SIUE  7  2  1105  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     thinness - calculates thinness ratio&nbsp;SYNOPSIS      #include &lt;math.h&gt;      #include &quot;ObjectContour.h&quot;&nbsp;     double thinness(Image * labeledImage, int r, int c)&nbsp;      &lt;labeledImage&gt; -  pointer to a labeled image      &lt;r&gt; - row coordinate of a point on a labeled image      &lt;c&gt; - column coordinate of a point on a labeled image&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\FEATURE\\binary_feature.cDESCRIPTION     This function calculates the thinness ratio of an object  of     interest on the labeled image. The formula used is:&nbsp;               thinness ratio = 4*PI*area/(perimeter^2)&nbsp;     where area is area of the binary object,  and  perimeter  is     the length of outer edge of the object.&nbsp;     The inverse of thinness is known as irregularity.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A value of type double: thinness ratio&nbsp;HISTORY     History information recorded: None&nbsp;DIAGNOSTICS     The labeled image can only of data type CVIP_INTEGER&nbsp;SEE ALSO     FEATURE library, area, perimeter&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","thinness","scr\\CVIP_C_functions/thinness.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-05T01:22:00Z  2004-10-20T00:18:00Z  1  450  2567  SIUE  21  6  3011  10.3501                    MicrosoftInternetExplorer4 NAME     threshold_segment - performs a binary threshold on an image&nbsp;SYNOPSIS      #include &quot;CVIPtools.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &lt;stdio.h&gt;      #include &quot;threshold.h&quot;&nbsp;      Image *threshold_segment(Image  *inputImage,  unsigned  int     threshval, CVIP_BOOLEAN thresh_inbyte)&nbsp;      &lt;inputImage&gt; - pointer to Image structure      &lt;threshval&gt; - threshold value      &lt;thresh_inbyte&gt;               - CVIP_NO apply threshval directly to image data;               - CVIP_YES  threshval is CVIP_BYTE range; remap to                 image data range before thresholding.&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\threshold.cDESCRIPTION     This function performs a binary threshold on an input image.     It  sets  pixels  of  value greater than &lt;threshval&gt; to 255;     those less than or equal to &lt;threshval&gt;  are  set  to  zero.     Each  band of a multi-band images is thresholded separately.     If &lt;thresh_inbyte&gt; is 0, &lt;threshval&gt; is applied directly  to     the  image  data.  If &lt;thresh_inbyte&gt; equals 1,  &lt;threshval&gt;     is remapped to  its  corresponding  CVIP_BYTE  value  before     thresholding according to the formula:&nbsp;                    &lt;threshval&gt; x (max_val - min_val)     &lt;new_thresh&gt; = --------------------------------- + min_val                                  255&nbsp;     where max_val and min_val are the maximum and minimum values     found in the image.  This option is provided for consistancy     with the method used to display histograms in  CVIPtools  --     histograms  are  remapped to CVIP_BYTE range, 0 to 255. With     this option the user can select a threshold  value  directly     from the histogram.&nbsp;TYPES AND CONSTANTS      None&nbsp;RETURN VALUES     A thresholded image.&nbsp;BUGS     None at this time&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the binary threshold      on the input image with the threshval equal to 128 */      cvipImage = (Image *)threshold_segment(cvipImage,128,      CVIP_YES);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,      format,1);      free(outputfile);      }&nbsp;SEE ALSO     SEGMENTATION library&nbsp;AUTHOR     Copyright (C) 1995, 1996, 2004 SIUE - by Scott Umbaugh,  Kun  Luo,     and Yansheng Wei.&nbsp;\n\r\n\r&nbsp;","threshold_segment","scr\\CVIP_C_functions/threshold_segment.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T01:24:00Z  2004-10-20T00:18:00Z  1  1001  5706  SIUE  47  13  6694  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     trans_compr -  Performing  Spectral  Transform  Based                    Compression&nbsp;SYNOPSIS     #include &lt;vector_quant.h&gt;&nbsp;     Image *trans_compr(char *filename, Image *image,      int color_space, int xform, int WAVELET_basis,      int subimage_size, int quant, int JPEG_Q_Table,      int coding, int data_type, int remap_type, int keep_DC)&nbsp;      &lt;filename&gt;    file to store the compressed data      &lt;image&gt;       input image      &lt;color_space&gt; color space                    0 - RGB                    1 - PCT                    2 - YCbCr      &lt;xform&gt;       transform                    0 - none                    1 - DCT                    2 - WAVELET      &lt;WAVELET_basis&gt;WAVELET transform basis function                    1 - haar                    2 - daub4      &lt;subimage_size&gt;block size to do the transform                    (8, 16, 32, 64, 128, 256, 512)      &lt;quant&gt;       quantization                    0 - none                    1 - user specified      &lt;JEPG_Q_Table&gt;use JPEG quantization table                    0 - without using                    1 - using      &lt;coding&gt;      use vector quantization or not                    0 - none                    1 - user specified Vector Quantization(VQ)                    2 - Huffman coding      &lt;data_type&gt;   data type for VQ                    1 - float                    2 - byte                    3 - short      &lt;remap_type&gt;  remap type for float -&gt; byte/short                    1 - linear remap                    2 - log remap      &lt;keep_DC&gt;     quantize the DC of DCT or not                    0 - quantize it                    1 - keep itPATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\trans_compr.c&nbsp;DESCRIPTION     tran_compr is designed  for  experimentation  with  spectral     transform based compression.  You can select different color     spaces (RGB, PCT, YCbCr), transforms (NONE, DCT,  DWT),  the     transform  block  size  (8 to 512), quantization type (NONE,     USER SPECIFIED TABLE, JPEG_Q_TABLE),  coding  method  (NONE,     VQ, HUFFMAN), data type for vector quantization (VQ) (FLOAT,     BYTE, SHORT), remap type for VQ if data type  is  not  float     (LINEAR, LOG), quantization or not of the DC term if the DCT     and VQ are used.&nbsp;     The equations used for the YCbCr color space are:&nbsp;      Y  = 0.299R + 0.587G + 0.114B      Cb = - 0.1687R - 0.3313G + 0.5B + 2 ** (Sample Precision/2)      Cr = 0.5R - 0.4187G + 0.0813B + 2 ** (Sample Precision/2)&nbsp;      R = Y + 1.402Cr      G = Y - 0.34414(Cb - 2 ** (Sample Precision/2)) -          0.71414(Cr - 2 ** (Sample Precision/2))      B = Y + 1.722(Cb - 2 ** (Sample Precision/2))&nbsp;     Sample Precision is number of bits per pixel per color band.&nbsp;     The compression ratio and entropy will appear in the  termi-     nal window (UNIX).&nbsp;     When designing an algorithm, follow these rules:&nbsp;      &lt;color_space&gt; Do not use PCT and YCbCr for gray-level                    images.      &lt;WAVELET_Basis&gt; It will not  take  effect  unless  you  use                    WAVELET transform.      &lt;JEPG_Q_Table&gt;Use it only if you use the DCT on 8*8 blocks.      &lt;coding&gt;      If you use Huffman coding, you should either                    use JPEG_Q_Table or specify quantization                    table, and use data type FLOAT. And the data                    will convert to BYTE automatically.      &lt;data_type&gt;   It will not take effect unless you use VQ.      &lt;remap_type&gt;  It will not take effect unless you use VQ and                    BYTE/SHORT.      &lt;DC_Quantize&gt; It will not take effect unless you use the                    DCT and VQ.&nbsp;     If the size of the input image is not a power of 2, it  will     be zero padded.&nbsp;     For user specified quantization &lt;quant = 1&gt;, you need a file     named table in this file, in the following format:      16 32 32 48 48 48 64 64 64 64      32 48 48 64 64 64 128 128 128 128&nbsp;     The first ten for the ten subimages in red band, the  second     ten  for  the ten subimages in green band, the third ten for     the ten subimages in blue band.&nbsp;     For user specified vector quantization  &lt;coding  =  1&gt;,  you     need  a  file  named xvq_set in the directory from which the     program is run. Specify the vector table in this file.  This     file should be in the following format:&nbsp;      If color_space = 0 (RGB)          32 32 1 2 2 1024 2 2 1024 2 2 512 2 2 512          2 2 512 2 2 256 4 4 128 4 4 128 4 4 128      vector-height vector-width codebook-entry for subimage 1      vector-height vector-width codebook-entry for subimage 2      ...      vector-height vector-width codebook-entry for subimage 10&nbsp;      If color_space = 1 (PCT) or 2 (YCbCr)          64 64 64 64 64 64 1 1 1 2 2 2 2 2 2 1024 256 256          2 2 2 2 2 2 1024 256 256 2 2 2 2 2 2 512 64 64          2 2 2 2 2 2 512 64 64 2 2 2 2 2 2 512 64 64          2 2 2 2 2 2 256 64 64 4 4 4 4 4 4 128 0 0          4 4 4 4 4 128 0 0 4 4 4 4 4 4 64 0 0      red-vector-height  red-vector-width     green-vector-height      green-vector-width blue-vector-height   blue-vector-width      red-codebook-entry green-codebook-entry blue-codebook-entry      for subimage 1      ...      red-vector-height  red-vector-width     green-vector-height      green-vector-width blue-vector-height   blue-vector-width      red-codebook-entry green-codebook-entry blue-codebook-entry      for subimage 10&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     decompressed image&nbsp;HISTORY     History information recorded: None&nbsp;BUGS     None&nbsp;EXAMPLE      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtransform.h&quot;      #include &quot;vector_quant.h&quot;&nbsp;      void main()      {          Image *cvipImage, *outImage;          char *inputfile, *outfile;&nbsp;          setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);          print_CVIP(&quot;0Enter the Input File Name:  &quot;);          inputfile =(char *) getString_CVIP();          cvipImage = read_Image(inputfile, 1);          view_Image(cvipImage, inputfile);          print_CVIP(&quot;0Enter the Compressed File Name:&quot;);          outfile = (char *) getString_CVIP();          /* YCbCr, DCT on 8*8 block, JPEG_Q_Table, Huffman          coding */          outImage = trans_compr(outfile, cvipImage, 1, 1, 1, 8,          0, 1, 2, 1, 1, 0);          view_Image(outImage, outfile);&nbsp;      }&nbsp;SEE ALSO     xvq(3)  vector_quant(3),  wavelet(3),  dct(3),   huffman(3),     jpeg(3)&nbsp;AUTHOR     Copyright (C) 2000, 2004 SIUE - by Scott E.  Umbaugh  and  Zhijian     Lin.&nbsp;\n\r\n\r&nbsp;","trans_compr","scr\\CVIP_C_functions/trans_compr.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T01:23:00Z  2004-10-20T00:19:00Z  1  426  2432  SIUE  20  5  2853  10.3501                    MicrosoftInternetExplorer4 NAME     translate - moves the entire image or a part of the image&nbsp;SYNOPSIS      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPmatrix.h&gt;      #include &lt;CVIPgeometry.h&gt;      #include &lt;CVIPdef.h&gt;&nbsp;     Image *translate(Image *cvipImage, CVIP_BOOLEAN do_wrap, int     r_off,  int  c_off, int r_mount,int c_mount,int r_slide, int     c_slide, float fill_out)&nbsp;      &lt;cvipImage&gt; - pointer to an Image structure      &lt;do_wrap&gt; - wrap image during translation if CVIP_YES      &lt;r_off&gt; - row # of upper-left pixel in area to move      &lt;c_off&gt; - column # of upper-left pixel in area to move      &lt;r_mount&gt; - height of area to move      &lt;c_mount&gt; - width of area to move      &lt;r_slide&gt; - distance to slide vertically      &lt;c_slide&gt; - distance to slide horizontally      &lt;fill_out&gt; - value to fill vacated area in cut-and-paste&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\translate.c&nbsp;DESCRIPTION     Translate can perform two different  operations,  horizontal     and  vertical translation of an image, or cut-and-paste of a     part of an image. Translation moves the image as a whole; it     can either wrap the image around the \'edges\' or fill vacated     areas with a constant value.  Cut-and-paste  moves  a  user-     defined part of the image, and fills the vacated area with a     user-provided value.&nbsp;TYPES AND CONSTANTS     none&nbsp;RETURN VALUES     Returns  a  translated  image  upon  successful  completion;     returns NULL if an error occurs.&nbsp;BUGS     None at this time&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPgeometry.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;0Enter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /*the following call translates the image both in the      horizontal and vertical direction.The starting point      of the translation is 0,0 and the ending point of      translation is 255,255.The amount of translation is      10 pixels in the horizontal and vertical direction*/      cvipImage = translate(cvipImage,CVIP_YES,0,0,256,256,      10,10,0);      print_CVIP(&quot;0Enter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     GEOMETRY library&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","translate","scr\\CVIP_C_functions/translate.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T01:25:00Z  2004-10-20T00:19:00Z  1  330  1884  SIUE  15  4  2210  10.3501    Clean                  MicrosoftInternetExplorer4 NAME     uniform_noise - Add uniform noise to an image&nbsp;SYNOPSIS     #include &quot;CVIPnoise.h&quot;&nbsp;     Image *uniform_noise(Image *imageP,float *var,float *mean);&nbsp;      &lt;imageP&gt; - pointer to Image structure      &lt;var&gt; - variance of noise distribution      &lt;mean&gt; - mean or average value of distribution&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\NOISE\\noise.cDESCRIPTION     Uniform type noise is simply generated according to:&nbsp;                 1/a-b   for a&lt;=Gi&lt;=b          hi =                 0 elsewhere&nbsp;     where Gi is the grey-level value of the ith  pixel,  \'a\'  is     the  minimum  and \'b\' is the maximum gray level value of the     noise.&nbsp;RETURN VALUES     The uniform_noise()  function  returns  the  modified  Image     pointer on success, and returns a NULL pointer on failure&nbsp;BUGS     none&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;CVIPnoise.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      float var=100.0;      float mean=2;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call adds gamma noise to the input image      with the variance equal to 100.0 and the mean      equal to 0.5.We can use the function uniform_noise_setup so      that the user can specify the inputs  */      cvipImage = uniform_noise(cvipImage,&amp;var,&amp;mean);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     gamma_noise(3),     gaussian_noise(3),     neg_exp_noise(3),     rayleigh_noise(3), speckle_noise(3)&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and     David Lyons.&nbsp;\n\r\n\r&nbsp;","uniform_noise","scr\\CVIP_C_functions/uniform_noise.htm","   ACADEMIC COMPUTING  Normal  akharba  4  5  2005-07-02T20:58:00Z  2006-07-08T22:29:00Z  1  515  2936  SIUE  24  6  3445  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        unit_vector_normalization – normalizes a 2D matrix using unit                                     vector normalization method&nbsp;SYNOPSIS#include &quot;stdio.h&quot;#include &quot;math.h&quot;#include &quot;stdlib.h&quot;&nbsp;float **unit_vector_normalization(float **vector, int i, int j, int option, int *err_code)&nbsp;&lt;vector&gt; - 2Dpointer to a matrix&lt;i&gt; - number of columns in the matrix      &lt;j&gt; - number of rows in the matrix      &lt;option&gt; - 0 – to normalize the training set                 1 – to normalize the test set      &lt;err_code&gt; - pointer to the error code; use 0 for no error&nbsp;&nbsp;PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\unit_vector_normalization.c&nbsp;DESCRIPTION     This function normalizes a matrix using unit vector normalization     method. The formula used for unit vector normalization is given in      chapter 6 of the following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineno_of_col 2\n\r\n\r#defineno_of_row 3\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       float  **vector;\n\r\n\r       int           i,j;\n\r\n\r       int           option= 0;\n\r\n\r&nbsp;\n\r\n\r       /* Define a pointer pointing to the error code\n\r\n\r              Initialize  it to 0.\n\r\n\r       */\n\r\n\r       int           *err_code;\n\r\n\r       err_code = malloc(sizeof(int));\n\r\n\r       *err_code = 0;\n\r\n\r&nbsp;\n\r\n\r       /* Memory allocation. The size of vectoris (no_of_row+1)*no_of_col */\n\r\n\r       vector =malloc((no_of_row+1)*sizeof(float *));\n\r\n\r&nbsp;\n\r\n\r       for(i=0;i&lt;(no_of_row+1);i++)\n\r\n\r       {\n\r\n\r              vector[i] =malloc(no_of_col*sizeof(float));           \n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Get the vectors. The items should beseparated by &quot;,&quot;. vector[0][0],vector[0][1],...vector[row][col] */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector: &quot;);\n\r\n\r       for(j=0;j&lt;no_of_row;j++)\n\r\n\r       {\n\r\n\r              for(i=0;i&lt;no_of_col;i++)\n\r\n\r              {\n\r\n\r                     scanf(&quot;%f,&quot;,&amp;vector[j][i]);\n\r\n\r              }\n\r\n\r              \n\r\n\r       }\n\r\n\r       \n\r\n\r       /* Call c function, and return thevector. option is 0, means the vector comes from training set */\n\r\n\r       vector = unit_vector_normalization(vector, no_of_col, no_of_row, option, err_code);\n\r\n\r&nbsp;\n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }\n\r\n\r       else\n\r\n\r       {\n\r\n\r              /* Print out the result */\n\r\n\r              for(j=0;j&lt;no_of_row+1;j++)\n\r\n\r              {\n\r\n\r                     for(i=0;i&lt;no_of_col;i++)\n\r\n\r                     {\n\r\n\r                           printf(&quot;%f&quot;, vector[j][i]);\n\r\n\r                     }\n\r\n\r                     printf(&quot;%s\\n&quot;,&quot;&quot;);\n\r\n\r              }\n\r\n\r       }      \n\r\n\r       /* The last row in the vector is fornormalize another vector. Typically, from test set. */\n\r\n\r&nbsp;\n\r\n\r       /* Get another vectors. The items shouldbe separated by &quot;,&quot;. vector[0][0],vector[0][1],...vector[row][col] */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in another vector: &quot;);\n\r\n\r       for(j=0;j&lt;no_of_row;j++)\n\r\n\r       {\n\r\n\r              for(i=0;i&lt;no_of_col;i++)\n\r\n\r              {\n\r\n\r                     scanf(&quot;%f,&quot;,&amp;vector[j][i]);\n\r\n\r              }\n\r\n\r              \n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       option = 1;\n\r\n\r       /* Call c function, and return thevector. option is 1, means the vector comes from test set */\n\r\n\r       vector = unit_vector_normalization (vector,no_of_col, no_of_row+1, option, err_code);\n\r\n\r&nbsp;\n\r\n\r       /* If err_code is not 0, print out theerr_code */\n\r\n\r       if(*err_code != 0)\n\r\n\r       {\n\r\n\r              printf(&quot;Error code:%d\\n&quot;, *err_code);\n\r\n\r       }\n\r\n\r       else\n\r\n\r       {\n\r\n\r              /* Print out the result */\n\r\n\r              for(j=0;j&lt;no_of_row+1;j++)\n\r\n\r              {\n\r\n\r                     for(i=0;i&lt;no_of_col;i++)\n\r\n\r                     {\n\r\n\r                           printf(&quot;%f&quot;, vector[j][i]);\n\r\n\r                     }\n\r\n\r                     printf(&quot;%s\\n&quot;,&quot;&quot;);\n\r\n\r              }\n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Free the pointers */\n\r\n\r       for(i=0;i&lt;(no_of_row+1);i++)\n\r\n\r       {\n\r\n\r              free(vector[i]);\n\r\n\r       }\n\r\n\r       free(vector);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A unit vector normalized matrix pointer&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;","unit_vector_normailzation","scr\\CVIP_C_functions/unit_vector_normalization.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T01:27:00Z  2004-10-20T00:19:00Z  1  350  1996  SIUE  16  4  2342  10.3501    Clean                  MicrosoftInternetExplorer4 NAME     unsharp_filter - performs unsharp masking&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPtools.h&gt;&nbsp;     Image*  unsharp_filter(Image  *inputImage,  int  lower,  int     upper,  float low_clip, float high_clip)&nbsp;      &lt;inputImage&gt; - pointer to an Image structure      &lt;lower&gt; - lower limit for histogram shrink (0-254)      &lt;upper&gt; - upper limit for histogram shrink (1-255)      &lt;low_clip&gt; - percentage of low values to clip                   during hist_stretch      &lt;high_clip&gt; - percentage of high values to clip                    during hist_stretch&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\unsharp.cDESCRIPTION     Unsharp masking is a technique that combines  filtering  and     histogram modification. The input image is lowpass filtered;     a histogram shrink is then performed on the filtered  image.     The  resultant  image is subtracted from the original, and a     histogram stretch completes the process.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A filtered image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs unsharp masking with      the shrinking range between 0 and 200 and the lower      and higher clipping values equal to .01 for      histogram stretching */      cvipImage = unsharp_filter(cvipImage,0,200,.01,.01);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     SPATIALFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh and Kun Luo.&nbsp;\n\r\n\r&nbsp;","unsharp_filter","scr\\CVIP_C_functions/unsharp_filter.htm","   ACADEMIC COMPUTING  Normal  akharba  8  4  2005-07-02T19:59:00Z  2006-07-08T22:29:00Z  1  272  1554  SIUE  12  3  1823  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME        Vector_inner_product – calculates the vector inner product&nbsp;SYNOPSIS#include &quot;math.h&quot;     float vector_inner_product(float *vector1, float *vector2, int n)      &nbsp;&lt;vector1&gt; - pointer to an input array&lt;vector2&gt; - pointer to an input array      &lt;n&gt; - number of elements(features) in the array      PATH        $CVIPtoolsHOME\\CVIPC\\FEATURE\\vector_inner_product.c&nbsp;DESCRIPTION     This function calculates the vector inner product similarity      measure from the elements of the two arrays. The formula      used for the calculation is given in chapter 6 of the      following book:&nbsp;        Computer Imaging: Digital Image Analysis and Processing&nbsp;           Scott E Umbaugh, A CRC Press Book, 2005&nbsp;&nbsp;EXAMPLE\n\r\n\r#include      &quot;stdlib.h&quot;\n\r\n\r#include      &quot;CVIPtoolkit.h&quot;\n\r\n\r#include      &quot;CVIPpattern.h&quot;\n\r\n\r&nbsp;\n\r\n\r#defineMAX_CASE 3\n\r\n\r&nbsp;\n\r\n\rvoidmain()\n\r\n\r{\n\r\n\r       float  *vector1;\n\r\n\r       float  *vector2;\n\r\n\r       float  result;\n\r\n\r       int           i;\n\r\n\r&nbsp;\n\r\n\r       vector1 = malloc(MAX_CASE*sizeof(float));\n\r\n\r       vector2 = malloc(MAX_CASE*sizeof(float));\n\r\n\r&nbsp;\n\r\n\r       /* Get the vectors. The items should beseparated by &quot;,&quot; */\n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector1: &quot;);\n\r\n\r       for(i=0;i&lt;MAX_CASE;i++)\n\r\n\r       {\n\r\n\r              scanf(&quot;%f,&quot;,&amp;vector1[i]);\n\r\n\r       }\n\r\n\r       \n\r\n\r       print_CVIP(&quot;\\t\\tPlease type in theitems in vector1: &quot;);\n\r\n\r       for(i=0;i&lt;MAX_CASE;i++)\n\r\n\r       {\n\r\n\r              scanf(&quot;%f,&quot;,&amp;vector2[i]);\n\r\n\r       }\n\r\n\r&nbsp;\n\r\n\r       /* Call c function, and return theerr_code */\n\r\n\r       result = vector_inner_product(vector1,vector2, MAX_CASE);\n\r\n\r       \n\r\n\r       /* Print out the result */\n\r\n\r       printf(&quot;result=%f\\n&quot;,result);\n\r\n\r&nbsp;\n\r\n\r       /* Free the pointers */\n\r\n\r       free(vector1);\n\r\n\r       free(vector2);\n\r\n\r}\n\r\n\r&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A float number representing the vector inner product similarity     measure&nbsp;HISTORY     History information recorded: None&nbsp;SEE ALSO     FEATURE libraryAUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E. Umbaugh,     Husain Kagalwalla, Geer Shuang, Amit Kharbanda.\n\r\n\r&nbsp;\n\r\n\r&nbsp;","vector_inner_product","scr\\CVIP_C_functions/vector_inner_product.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  3  2004-06-05T01:28:00Z  2004-10-20T00:19:00Z  1  866  4942  SIUE  41  11  5797  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME      vector_quant - A vector_quant compression method&nbsp;SYNOPSIS      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #include &lt;vector_quant.h&gt;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtransform.h&quot;      #include &lt;vector_quant.h&gt;&nbsp;     int   vq_compress (         Image         *inputImage,         char          *outfile_name,         int           cdbook_in_file,         int           fixed_codebook,         float         in_error_thres,         char          *cdbook_file,         int           in_no_of_entries,         int           in_row_vector,    /* the  number  of  rows     within a vector */         int           in_col_vector,    /* the  number  of  cols     within a vector */         XFORM_FMT     xform       )&nbsp;      &lt;inputImage&gt; - pointer to an Image structure      &lt;outfile_name&gt; - output file name      &lt;cdbook_in_file&gt; - codebook file writing control      &lt;fixed_codebook&gt; - codebook file reading control      &lt;in_error_thres&gt; - distortion control      &lt;cdbook_file&gt; - the codebook file name      &lt;in_no_of_entries&gt; - total number of vectors in  the  code-     book      &lt;in_row_vector&gt; - total number of rows in a vector      &lt;in_col_vector&gt; - total number of cols in a vector      &lt;xform&gt; - what kind of transform and compression ratio  are     used&nbsp;     Image *vq_decompress(char *filename)&nbsp;      &lt;filename&gt; - character array&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\vector_quantization.cDESCRIPTION     Vector quantization works by dividing the image into  blocks     (vectors)  and  generating a codebook for those vectors. The     codebook contains the vectors, these can be  thought  of  as     subimages,  which are used to represent the image. The index     into the codebook is stored in place of the pixel values. It     uses the LBG algorithm to generate the codebook, which is an     iterative  algorithm  that  continues   searching   for   an     &quot;optimal&quot;  codebook  until  some  minimum error criterion is     reached.&nbsp;     You enter a value for the Error Threshold.  This  number  is     actually  the difference of the total error between two con-     secutive iterations.  The smaller the number,  the  &quot;better&quot;     the codebook and the longer it takes.  Since we are actually     searching in a many-dimensional space, there is no guarantee     of  a  globally optimal solution. Also, the search algorithm     does not take into account human  visual  perception,  so  a     &quot;better&quot; solution may actually look worse.&nbsp;     You enter the Entries, which is the number of vectors in the     codebook.   So  the  size  of the codebook is the (number of     entries)x(vector size).  The vector size  is  determined  by     the Vector Height and Width. For example, with a height of 4     and width of 4, the vector size is 4x4=16.&nbsp;     The final two parameters are controlled by selection of  one     of  the four radiobuttons on the left.  &quot;cdbook_in_file&quot; and     &quot;fixed_codebook&quot;have to do with how the image is  compressed     and  saved to a file, and represent the four possible permu-     tations of the following      two things: 1) You can either generate a new codebook  from     the image, or use a      codebook that has already been generated (it  can  be  from     any image, but must be      saved to a file). 2) You can either save the codebook  with     the compressed file,      or in a separate file.  In general,  you  will  get  better     results if you use a      codebook generated from the specific image  file.  However,     if you have a group of      similar images, you may want to generate a common  codebook     and save it in a      separate file. If you save the codebook in a separate file,     you  will have a higher compression ratio, but you must keep     track of the codeboook file.  If you keep the codebook  with     the compressed (coded) file, then the compression ratio will     not be as large.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES      vq_compress: 1 on success, 0 on failure&nbsp;      vq_decompress: an uncompressed image pointer  on  success,a     NULL pointer on failure&nbsp;EXAMPLE      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtransform.h&quot;      #include &lt;vector_quant&gt;&nbsp;      void main() {         Image *cvipImage, *outImage;         char *inputfile,outfile;         char c1=\'n\',c2=\'n\';         int xform = 10;&nbsp;         setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);         print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);         inputfile =(char *) getString_CVIP();         cvipImage = read_Image(inputfile, 1);         view_Image(cvipImage, inputfile);         print_CVIP(&quot;\\n\\t\\tEnter the Compressed File Name:&quot;);         outfile =(char *) getString_CVIP();         /* The following command will compress the input image with the         tolerance value equal to 15, recursion size min. equal to 4 and         recursion size max. equal to 6, domain type equal to 0, domain step         equal to 1, scale bits equal to 5 and offset bits equal to 7 with         faster compression time */         if (vq_compress(cvipImage,outfile,1,0,10,codebook,128,4,4,10)&lt;0) {          error_CVIP(&quot;vq_compress&quot;, &quot;compression failed&quot;);             exit(1);         } else if ((outImage=vq_decompress(outfile))==NULL){          error_CVIP(&quot;vq_decompress&quot;, &quot;decompression failed&quot;);             exit(1);         } else view_Image(outImage, outputfile);&nbsp;         free(inputfile);         free(outputfile);         }&nbsp;BUGS     None&nbsp;SEE ALSO     COMPRESSION library&nbsp;\n\r\n\r&nbsp;","vector_quant","scr\\CVIP_C_functions/vector_quant.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  7  7  2004-06-05T01:30:00Z  2004-11-03T02:32:00Z  1  198  1130  SIUE  9  2  1326  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     view_Image - choose the appropriate viewer and  displays  an     image&nbsp;SYNOPSIS      #include &quot;CVIPtoolkit.h&quot;&nbsp;      void view_Image( Image *inputImage, char *imagename)      &lt;inputImage&gt; - pointer to the input Image structure      &lt;imagename&gt; - character string as the image name&nbsp;DESCRIPTION     The view_Image function provides the interface for image     viewing which is most accessible and flexible for the CVIPlab     programmer. The core display functions are in the display.c      file (under ~CVIPC\\Display) and used by both CVIPlab (in      view_Image) and CVIPtools.&nbsp;TYPES AND CONSTANTS     NONE&nbsp;RETURN VALUES     NONE&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile;&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);&nbsp;      /* display the resultant image*/&nbsp;      view_Image(cvipImage, inputfile);      delete_Image (cvipImage);      free(inputfile);      }&nbsp;AUTHOR     Copyright (C) 1996, 2005 SIUE - by Scott E. Umbaugh  and  Yansheng     Wei.&nbsp;\n\r\n\r&nbsp;","view_Image","scr\\CVIP_C_functions/view_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  3  2004-06-05T01:31:00Z  2006-02-22T00:17:00Z  1  332  1898  SIUE  15  4  2226  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     walhad_transform - performs Walsh or Hadamard transform&nbsp;SYNOPSIS      #include &quot;CVIPtools.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPdef.h&quot;      #include &lt;math.h&gt;      #include &quot;CVIPtransform.h&quot;&nbsp;     Image  *walhad_transform(Image  *in_Image,  int  ibit,   int     block_size)&nbsp;      &lt;in_Image&gt; - pointer to an Image structure      &lt;ibit&gt; - 0=inverse Walsh transform, 1=Walsh transform               2=inverse Hadamard transform, 3=Hadamard transform      &lt;block_size&gt; - block size (4,8,16,...largest_dimension/2)&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\TRANSFORMS\\walhad.cDESCRIPTION     This  function   performs  a  fast  Hadamard-ordered  Walsh-     Hadamard  Transform  on  an image.  The result is then reor-     dered for display in sequency order.  The routine  works  on     any  image  with  dimensions that are powers of 2.  Optional     zero-padding may be performed if input image  has  different     dimensions.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A transformed image&nbsp;HISTORY     History information recorded: None      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;CVIPtransform.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs a forward walsh transform on     the input image with block size equal to 8 */      cvipImage = walhad_transform(cvipImage, 1,8);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     TRANSFORMS library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Arve     Kjoelen.&nbsp;\n\r\n\r&nbsp;","walhad_transform","scr\\CVIP_C_functions/walhad_transform.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  10  15  2004-09-17T23:37:00Z  2004-10-20T00:19:00Z  1  197  1125  SIUE  9  2  1320  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     watershed_segment - image segmentation based on the watershed segmentation                         algorithm&nbsp;SYNOPSIS      #include &quot;watershed.h&quot;      #include &quot;CVIPmap.h&quot;&nbsp;     Image *watershed_segment(Image *inputImage, float threshold, CVIP_BOOLEAN choice)&nbsp;      &lt;inputImage&gt; - pointer to Image structure      &lt;threshold&gt; - threshold value      &lt;choice&gt; - CVIP_NO (0) Do not merge result                 CVIP_YES (1) To merge resultPATH     $CVIPtoolsHOME\\CVIPC\\SEGMENTATION\\watershed_segment.c&nbsp;DESCRIPTION\n\r\n\r     Thewatershed segmentation algorithm as implemented in CVIPtools was initiallydesigned to separate a single object from the background in color images. Thewatershed algorithm is a morphological technique based on the idea of modelinga gray level image as a topographic surface, with higher gray levelscorresponding to higher elevations. The image is then flooded with a rainfallsimulation, and pools of water are created corresponding to segments within theimage. When rising water reaches a point where two pools will merge, a dam isbuilt to prevent the merging.RETURN VALUES     Pointer to an Image structure on success and NULL pointer     on failure.BUGS     None at this time&nbsp;SEE ALSO    SEGMENTATION library&nbsp;AUTHOR     Copyright (C) 2004 SIUE - by Scott Umbaugh \n\r\n\r&nbsp;","watershed_segment","scr\\CVIP_C_functions/watershed_segment.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  4  2004-06-05T01:32:00Z  2004-10-20T00:20:00Z  1  159  907  SIUE  7  2  1064  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 &nbsp;NAME     wavdaub4_transform - performs a Daubechies wavelet transform&nbsp;SYNOPSIS      #include &lt;stddef.h&gt;      #include &lt;ctype.h&gt;      #include &lt;string.h&gt;      #include &lt;math.h&gt;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtools.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;wavelet.h&quot;&nbsp;     Image  *wavdaub4_transform(Image  *image,  int  isign,   int     lowband)&nbsp;      &lt;image&gt; - pointer to an Image structure      &lt;isign&gt; - 1 (forward transform) or 2 (inverse transform)      &lt;lowband&gt; - # of rows/(2^([(# bands desired -1)/3]-1))&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\TRANSFORMS\\wavelet.cDESCRIPTION     This function performs a Daubechies 4 tap wavelet filter  in     the spatial domain.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A transformed image&nbsp;HISTORY     History information recorded:&nbsp;     ** Wavelet Transform:          - Basis: &lt;type&gt; wavelet          - # of frequency bands: &lt;#&gt;&nbsp;SEE ALSO    TRANSFORMS library, wavhaar_transform&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Arve     Kjoelen.&nbsp;\n\r\n\r&nbsp;","wavdaub4_transform","scr\\CVIP_C_functions/wavdaub4_transform.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  5  2004-06-05T01:35:00Z  2004-10-20T00:20:00Z  1  152  870  SIUE  7  2  1020  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     wavhaar_transform - performs Haar wavelet transform&nbsp;SYNOPSIS      #include &lt;stddef.h&gt;      #include &lt;ctype.h&gt;      #include &lt;string.h&gt;      #include &lt;math.h&gt;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtools.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;wavelet.h&quot;&nbsp;     Image  *wavhaar_transform(Image  *image,  int   isign,   int     lowband)&nbsp;      &lt;image&gt; - pointer to an Image structure      &lt;isign&gt; - 1 (forward transform) or 2 (inverse transform)      &lt;lowband&gt; -  # of rows/(2^([(# bands desired -1)/3]-1))&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\TRANSFORMS\\wavelet.cDESCRIPTION     This function performs a Haar wavelet transform.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A transformed image&nbsp;HISTORY     History information recorded:&nbsp;     ** Wavelet Transform:          - Basis: &lt;type&gt; wavelet          - # of frequency bands: &lt;#&gt;&nbsp;SEE ALSO     TRANSFORMS library, wavdaub4_transform&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Arve     Kjoelen.&nbsp;\n\r\n\r&nbsp;","wavhaar_transform","scr\\CVIP_C_functions/wavhaar_transform.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T01:38:00Z  2004-10-20T00:20:00Z  1  643  3669  SIUE  30  8  4304  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     wiener - performs wiener filtering&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtransform.h&quot;      #include &quot;CVIPxformfilter.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIParithlogic.h&quot;&nbsp;     Image *wiener(Image *degr, Image *degr_fn,  Image  *p_noise,     Image *p_orig, int choice, int cutoff)&nbsp;      &lt;degr&gt;    - pointer to the degraded image      &lt;degr_fn&gt; - pointer to the degradation function      &lt;p_noise&gt; - pointer to the noise power spectral density      &lt;p_orig&gt;  - pointer to the original  image  power  spectral     density      &lt;choice&gt;  - sets the maximum gain using the DC value  as  a     baseline      &lt;cutoff&gt;  - cutoff frequency for filtering&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\XFORMFILTER\\restore_xformfilter.cDESCRIPTION     This function performs a wiener filter, (a frequency  domain     filter).   See  any  image  processing  textbook for info on     Wiener Filters.  The function does its  own  memory  manage-     ment,  freeing  everything passed to it, so if you need your     images intact, make a copy of them before calling this func-     tion.&nbsp;     The function tries to determine whether an FFT has been per-     formed on the passed images.  If not, the function will per-     form the FFT.  This is especially important to note for  the     power  images.   If  the  power  images  are  in the spatial     domain, they will have an FFT performed on them, before  the     squared  magnitude  is calculated.  If an FFT is detected in     the history of any  of  the  power  images,  that  image  is     assumed  to  be  representing  a power image, and no squared     magnitude is calculated.&nbsp;     The function will also extend the sizes of the passed images     as best it can when they are of unequal size.&nbsp;     Also note that the passed images must have the  same  number     of (color) bands.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     A pointer to the restored (filtered) image&nbsp;HISTORY     History information recorded:&nbsp;       parameter #1 = filter cutoff.       parameter #2 = method 1: F(u,v)=G(u,v) when H(u,v)=0                      method 2: F(u,v)=0 when H(u,v)=0&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &quot;CVIPxformfilter.h&quot;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage,*cvipImage1;      Image *cvipImage2,*cvipImage3;      IMAGE_FORMAT format;      char *inputfile,*outputfile;      char *inputfile1,*inputfile2;&nbsp;      (void) setDisplay_Image(VIEWER,&quot;default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the File Name of the degraded      image:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call creates a gaussian mask of size      3  * 3 */      cvipImage1 = (Image *)h_image(3,3,3);      print_CVIP(&quot;\\n\\t\\tEnter the File Name of the original      power spectrum image:  &quot;);      inputfile1 =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile1);      cvipImage2 = read_Image(inputfile1,1);      view_Image(cvipImage2, inputfile1);      free(inputfile1);      print_CVIP(&quot;\\n\\t\\tEnter the File Name of the noise power      spectrum image:  &quot;);      inputfile2 =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile2);      cvipImage3 = read_Image(inputfile2,1);      view_Image(cvipImage3, inputfile2);      free(inputfile2);      /* the following call performs the wiener filter on the      input image with the gaussian mask and the cut off      frequency equal to 32  */      cvipImage3=(Image *)wiener(cvipImage,cvipImage1,cvipImage2,      cvipImage3,1,32);      cvipImage=(Image *)ifft_transform(cvipImage3,256);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     XFORMFILTER library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Arve     Kjoelen.&nbsp;\n\r\n\r&nbsp;","wiener","scr\\CVIP_C_functions/wiener.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  16  15  2004-06-05T01:40:00Z  2006-02-23T00:56:00Z  1  432  2465  SIUE  20  5  2892  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     write_Image - writes the contents of a CVIP Image  structure     out to disk&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPlconvert.h&gt;&nbsp;     write_Image(Image *cvip_Image, char *filename,  CVIP_BOOLEAN     retain_image,  CVIP_BOOLEAN set_up, IMAGE_FORMAT new_format,     CVIP_BOOLEAN showmessages)&nbsp;      &lt;cvip_Image&gt; - pointer to valid CVIP Image structure      &lt;filename&gt; - pointer to an character string containing  the      file name      &lt;retain_image&gt; - retain image after  writing  (CVIP_YES  or      CVIP_NO)?      &lt;set_up&gt; - run setup (CVIP_YES or CVIP_NO)?      &lt;new_format&gt; - enumerated constant specifying  the  format      of the file to be written in      &lt;showmessages&gt; - shall I be verbose (CVIP_YES or CVIP_NO)?PATH     $CVIPtoolsHOME\\CVIPC\\CONVERSION\\convert.c&nbsp;DESCRIPTION     Writes the contents of a CVIP Image structure out to disk     in the specified  format &lt;new_format&gt;. The ‘new_format’ is      an enumerated constant specifying  the  format of the file:&nbsp;     typedef enum {PBM, PGM, PPM, EPS, TIF, GIF, RAS, ITX, IRIS,      CCC, BIN, VIP, GLR, BTC, BRC, HUF, ZVL, ARITH, BTC2, BTC3,      DPC, ZON, ZON2, SAFVR, JPG, WVQ, FRA, VQ, XVQ, TRCM, PS}      IMAGE_FORMAT. &nbsp;     Many of the formats offer variations on the way a file can      be presented to disk.(e.g. compression  schemes,       byte ordering, etc..) To take full advantage of this a      set-up routine can be run by  setting &lt;set-up&gt; equal to      CVIP_YES; otherwise, default options will be used.      Set-up routines vary for each format.&nbsp;&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;CVIPconvert.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      /* the following call loads an image structure with data      from the specified file */      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      /* the following call writes the contents of the CVIP image      structure out to disk.The format is the same as the      input file format */      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO    CONVERSION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE -  by  Scott  E.  Umbaugh  and  Greg     Hance.&nbsp;\n\r\n\r&nbsp;","write_Image","scr\\CVIP_C_functions/write_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T01:41:00Z  2004-10-20T00:20:00Z  1  262  1496  SIUE  12  3  1755  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     xor_Image - performs logical XOR of two images&nbsp;SYNOPSIS      #include &quot;CVIPimage.h&quot;      #include &quot;CVIParithlogic.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;     Image *xor_Image(Image *inputImage1,Image *inputImage2)&nbsp;           &lt;inputImage1&gt; - pointer to an Image structure           &lt;inputImage2&gt; - pointer to an Image structure&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\ARITHLOGIC\\arithlogic.cDESCRIPTION     This function performs a bitwise XOR of two images.  Complex     data is NOT supported.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     An XORed image&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &quot;CVIPimage.h&quot;      #include &quot;CVIParithlogic.h&quot;      #include &quot;CVIPconvert.h&quot;&nbsp;      void main() {        Image *inputImage1, *inputImage2, *outputImage;        IMAGE_FORMAT format;        char *inputfile1, *inputfile2, *outputfile;&nbsp;        setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;        print_CVIP(&quot;\\n\\tEnter the first Input File Name:  &quot;);        inputfile1 =(char *) getString_CVIP();        inputImage1 = read_Image(inputfile1, 1);        view_Image(inputImage1,inputfile1);        free(inputfile1);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the second Input File Name:  &quot;);        inputfile2 =(char *) getString_CVIP();        inputImage2 = read_Image(inputfile2, 1);        view_Image(inputImage2,inputfile2);        free(inputfile2);&nbsp;        outputImage = xor_Image(inputImage1, inputImage2);&nbsp;        print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);        outputfile = getString_CVIP();        view_Image(outputImage,outputfile);        free(outputfile);&nbsp;      }&nbsp;SEE ALSO     ARITHLOGIC library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh, Jainxin  Tan,     and Kun Luo.&nbsp;\n\r\n\r&nbsp;","xor_Image","scr\\CVIP_C_functions/xor_Image.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T01:42:00Z  2004-10-20T00:20:00Z  1  960  5478  SIUE  45  12  6426  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     xvq - Performing vector quantization in different domains&nbsp;SYNOPSIS      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &lt;math.h&gt;      #include &lt;string.h&gt;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;wavelet.h&quot;      #include &quot;CVIPtransform.h&quot;      #include &quot;CVIPtools.h&quot;      #include &quot;vector_quant.h&quot;      #include &quot;vector_data.h&quot;&nbsp;     Image     *xvq(Image *image, int xform,  int  scheme,                    char    *filename,   int   file_type,                    int remap_type, int dc)      &lt;image&gt;       input image      &lt;xform&gt;       transform domain                    1 - DCT                    2 - PCT_DCT                    3 - WAVELET                    4 - PCT_WAVELET      &lt;scheme&gt;      VQ schemes                    1~8 - compression schemes in the domain                          mentioned above;                      9 - customize the vector sets, but this                          can only be used in CVIPtools;                     10 - VQ in spatial domain.      &lt;filename&gt;    temporary file name      &lt;filetype&gt;    the file type you want to save as                    1 - CVIP_FLOAT                    2 - CVIP_BYTE                    3 - CVIP_SHORT      &lt;remap_type&gt;  the remap method that you should choose when                    you save file as CVIP_BYTE data type                    or CVIP_SHORT data type                    1 - linear remap                    2 - log remap      &lt;dc&gt;          indicates whether you want to quantize DC                    term when doing vector quantization (only                    valid when you want to save file as                    CVIP_BYTE data type or CVIP_SHORT data                    type)                    0 - quantize DC term                    1 - seperate DC term and keep it in historyPATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\xvq.c&nbsp;DESCRIPTION     XVQ is designed for compression using vector quantization in     the  discrete  wavelet or discrete cosine transform domains.     The user can choose the  transform  domain  and  select  the     principal components transform PCT as pre-process (for color     images), by selecting one  of  the  four  transform  options     (DCT,  PCT_DCT, WAVELET, PCT_WAVELET).  The user selects one     of the four compression algorithms  (VQ1,  VQ2,  VQ3,  VQ4),     which represent different codebook and vector sizes (to view     the default values select the \'Customize\' button).&nbsp;     For a 512x512 color image, with FLOAT data type, VQ1  ~  VQ4     represent the compression ratios at 4:1, 8:1, 14:1 and 20:1.     The parameters of schemes is defiend as :      1 - without PCT, compression ratio 4:1;      2 - with PCT, compression ratio 4:1;      3 - without PCT, compression ratio 8:1;      4 - with PCT, compression ratio 8:1;      5 - without PCT, compression ratio 14:1;      6 - with PCT, compression ratio 14:1;      7 - without PCT, compression ratio 20:1;      8 - with PCT, compression ratio 20:1;&nbsp;     The user can select the data type  for  the  codebook,  less     precise data types will provide greater compression. If BYTE     is chosen, the user can select the method that will be  used     to remap the float data (from the transform), into byte for-     mat.&nbsp;     If BYTE or SHORT data type  and  the  DCT  (or  DCT_PCT)  is     selected, the user can chose to quantize the DC term or not.&nbsp;     If the user wants to perform compression by specifying their     own codebook and vector sizes, the \'Customize\' button offers     such flexibility. After clicking that button a  window  will     appear, and the user can choose the transform (DCT, PCT_DCT,     WAVELET, PCT_WAVELET), the  default  algorithmic  parameters     (VQ1  ~  VQ4), the data type for the codebook, and the remap     type (if data type  is  BYTE).   The  user  can  modify  the     default parameters in the table as desired.&nbsp;     If the input image is not with size of power of 2,  it  will     be zero padded.  If the input image is not a color image and     PCT is chosen as pre-process, an warning will occur.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     xvq : 1 on success, 0 on failure&nbsp;HISTORY     History information recorded:      1: When performing DCT, DCT history is recorded. Also the         parameters of &lt;file type&gt;, &lt;remap type&gt;, &lt;dc&gt; and some         necessary data regarding to decompression are recorded;      2: When performing PCT_DCT, PCT history and DCT history are         recorded sequentially. Also the parameters of         &lt;file type&gt;, &lt;remap type&gt;, &lt;dc&gt; and some necessary data         regarding to decompression are recorded;      3: When performing WAVELET, WAVELET history is recorded.         Also the parameters of &lt;file type&gt;, &lt;remap type&gt;, &lt;dc&gt;         and some necessary data regarding to decompression are         recorded;      4: When performing PCT_WAVELET, PCT history and WAVELET         history are recorded sequentially. Also the parameters         of &lt;file type&gt;, &lt;remap type&gt;, &lt;dc&gt; and some necessary         data regarding to decompression are recorded;&nbsp;BUGS     NONE&nbsp;EXAMPLE      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #include &quot;CVIPtoolkit.h&quot;      #include &quot;CVIPconvert.h&quot;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPtransform.h&quot;      #include &lt;vector_quant&gt;&nbsp;      void main() {         Image *cvipImage, *outImage;         char *inputfile,outfile;         char temp_file=&quot;temp_file&quot;;&nbsp;         setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);         print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);         inputfile =(char *) getString_CVIP();         cvipImage = read_Image(inputfile, 1);         view_Image(cvipImage, inputfile);         print_CVIP(&quot;\\n\\t\\tEnter the Compressed File Name:&quot;);         outfile =(char *) getString_CVIP();         /* The following command will compress the input image         PCT_DCT domain as pre-process, and compression ratio  at     20:1 */         if (outImage=xvq(cvipImage, 2, 4, temp_file, 2, 1, 1)&lt;0)     {          error_CVIP(&quot;xvq&quot;, &quot;compression failed&quot;);             exit(1);         } else view_Image(outImage, outputfile);&nbsp;         free(inputfile);         free(outputfile);         }&nbsp;SEE ALSO     vector_quant&nbsp;AUTHOR     Copyright (C) 1999, 2004 SIUE - by Scott E. Umbaugh,  Lu  Guo  and     Yue Cheng.&nbsp;\n\r\n\r&nbsp;","xvq","scr\\CVIP_C_functions/xvq.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  1  2004-06-05T01:44:00Z  2004-10-20T00:20:00Z  1  395  2255  SIUE  18  5  2645  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Ypmean_filter - a non-linear mean filter which is better  at     removing  gaussian  type  noise and preserving edge features     than the mean filter.&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;float.h&gt;&nbsp;     Image *Ypmean_filter(Image *imageP, int mask_size, int p)          &lt;imageP&gt; - pointer to Image structure.          &lt;mask_size&gt; - size of the filtering window (3-&gt;3x3).          &lt;p&gt; - filter order.&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER\\spatial_filter.cDESCRIPTION     Calculates the sum of the pixels in the filter window raised     to  the power of p, then divided by N*N.  Returns this value     raised to the  power  of  3/p.  Good  at  removing  positive     outliers  for negative values of p and negative outliers for     positive values of p.  Size  of  filter  should  be  an  odd     integer limited from &lt; 3 - 31 &gt;, and order of filter is lim-     ited from &lt;-5 to +5&gt;.&nbsp;TIPS     Works well on images containing positive  outlier  noise  if     the  parameter P is negative, and on images containing nega-     tive outlier noise if the parameter P is positive.  P should     remain small (3-3) for better performance.  Keep filter mask     size small to reduce blurring.&nbsp;DIAGNOSTICS     Returns a pointer to the modified Image  structure  on  suc-     cess.  Returns a NULL pointer if the input Image datatype is     not CVIP_BYTE and can\'t be cast to CVIP_FLOAT.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      (void) setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs a non-linear mean      filter in every 3 x 3 window */      cvipImage = Ypmean_filter(cvipImage,3,2);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;BUGS     None.&nbsp;AUTHOR     Copyright (C) 1992, 1996, 2004 SIUE - by Scott E. Umbaugh and John     A Creighton.&nbsp;\n\r\n\r&nbsp;","Ypmean_filter","scr\\CVIP_C_functions/Ypmean_filter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  0  2004-06-05T01:46:00Z  2004-10-20T00:21:00Z  1  478  2731  SIUE  22  6  3203  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     zon_compress, zon_decompress - compress  and  decompress  an     image using zonal coding&nbsp;SYNOPSIS     int zon_compress(Image *  inputImage,  char  *filename,  int     block_size,     int    choice,    int    mask_type,    float     compress_ratio);&nbsp;      &lt;inputImage&gt; - pointer to an image      &lt;filename&gt; - pointer to a character array      &lt;block_size&gt; - a power of 2; kernel size is &lt;block_size&gt;^2      &lt;choice&gt; - transform to use:                     1=FFT 2=DCT 3=Walsh 4=Hadamard      &lt;mask_type&gt; - type of kernel to use:                     1=triangle 2=square 3=circle      &lt;compress_ratio&gt; - compression ratio, from 1.0 (min)                         to (block_size*block_size/4) (max)                         for all kinds of transforms&nbsp;     Image * zon_decompress(char * filename)&nbsp;      &lt;filename&gt; - pointer to a character array&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\zonal.cDESCRIPTION     The  program  consists  of  two  parts:  zon_compress()  and     zon_decompress().   zon_compress() first performs a selected     transform on the input image, forms a  kernel  according  to     arguments  block_size,  mask_type  and  compress_ratio, then     uses the kernel to sample the transform of the input  image,     maps  the result to CVIP_BYTE data(unsigned char) and stores     them in the file filename.&nbsp;     zon_decompress()   performs   the   inverse    process    of     zon_compress().&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     zon_compress: 0 on success, -1 on failure&nbsp;     zon_decompression: an uncompressed image pointer on success,     a NULL pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;DIAGNOSTICS     The input image is a real image, it can be multi_band and of     any    of   these   data   types:   CVIP_BYTE,   CVIP_SHORT,     CVIP_INTEGER, CVIP_FLOAT or CVIP_DOUBLE.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the zonal coding of the      input image with dc quantisation */      zon_compress(cvipImage,&quot;file1&quot;,32,2,1,2);      /* the following call performs the zonal decoding of      the &quot;file1&quot; */      cvipImage=zon_decompress(&quot;file1&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     COMPRESSION library, zon2_compress&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","zon_compress,zon_decompress","scr\\CVIP_C_functions/zon_compress, zon_decompress.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T01:44:00Z  2004-10-20T00:21:00Z  1  513  2927  SIUE  24  6  3434  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     zon2_compress, zon2_decompress - compress and uncompress  an     image using zonal coding&nbsp;SYNOPSIS     int zon2_compress(Image * inputImage,  char  *filename,  int     block_size, int choice, int mask_type, float compress_ratio)&nbsp;      &lt;inputImage&gt; - pointer to an image      &lt;filename&gt; - pointer to a character array      &lt;block_size&gt; - a power of 2; kernel size is &lt;block_size&gt;^2      &lt;choice&gt; - transform to use:                     1=FFT 2=DCT 3=Walsh 4=Hadamard      &lt;mask_type&gt; - type of kernel to use:                     1=triangle 2=square 3=circle      &lt;compress_ratio&gt; - compression ratio, from 1.0 (min)                         to (block_size*block_size/4) (max)                         for all kinds of transforms&nbsp;     Image * zon2_decompress(char * filename)&nbsp;      &lt;filename&gt; - pointer to a character arrayPATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\zonal2.c&nbsp;DESCRIPTION     The program  consists  of  two  parts:  zon2_compress()  and     zon2_decompress().    zon2_compress()   first   performs   a     selected transform  on  the  input  image,  forms  a  kernel     according    to    arguments   block_size,   mask_type   and     compress_ratio, then uses the kernel to sample the transform     of  the  input  image,  maps  the  result  to CVIP_BYTE data     (unsigned char) and stores them in the file filename.&nbsp;     zon2_decompress()   performs   the   inverse   process    of     zon2_compress().&nbsp;     The difference between zon_compress() and zon2_compress() is     that  in  zon_compress(),  the DC component is included into     local remapping; while it is not included in zon2_compress()     coding.&nbsp;TYPES AND CONSTANTS     None&nbsp;RETURN VALUES     zon2_compress: 0 on success, -1 on failure&nbsp;     zon2_decompression: an uncompressed image  pointer  on  suc-     cess, a NULL pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;DIAGNOSTICS     The input image is a real image, it can be multi_band and of     any    of   these   data   types:   CVIP_BYTE,   CVIP_SHORT,     CVIP_INTEGER, CVIP_FLOAT or CVIP_DOUBLE.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the zonal coding of the      input image with no dc quantisation */      zon2_compress(cvipImage,&quot;file1&quot;,32,2,1,2);      /* the following call performs the zonal decoding of the      &quot;file1&quot; */      cvipImage=zon2_decompress(&quot;file1&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     COMPRESSION library, zon_compress&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E.  Umbaugh  and  Wenxing     Li.&nbsp;\n\r\n\r&nbsp;","zon2_compress,zon2_decompress","scr\\CVIP_C_functions/zon2_compress, zon2_decompress.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T01:46:00Z  2004-10-20T00:21:00Z  1  545  3110  SIUE  25  7  3648  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     zoom - Enlarges a user-defined image area up to 10 times&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPgeometry.h&gt;&nbsp;     Image *zoom(Image *input_Image, int quadrant, int c, int  r,     int width, int height, float temp_factor)&nbsp;      &lt;input_Image&gt; - pointer to an Image      &lt;quadrant&gt; - 1=UL,2=UR,3=LL,4=LR,5=ALL,                   6=Specify (x,y), dx, dy      &lt;c&gt; - column coordinate of area\'s upper-left corner      &lt;r&gt; - row coordinate of area\'s upper-left corner      &lt;width&gt; - width of area to enlarge      &lt;height&gt; - height of area to enlarge      &lt;temp_factor&gt; - degree of enlargement&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\GEOMETRY\\zoom.cDESCRIPTION     To the function zoom, a pointer to  the  original  image  is     passed  as a parameter.  After performing the zooming opera-     tion, the pointer to the resultant image is returned to  the     calling  function  to  display  the resultant image.  As the     &lt;quadrant&gt; implies, the user can zoom the entire image,  the     first  quadrant,  the second and so on as well as specifying     the  co-ordinates  and  their  respective  distances  to  be     zoomed.   The  maximum  zoom factor allowed is 10.  The zoom     factor entered by the user is rounded before performing  the     actual  zooming.  If  the  zoom factor is 3/4th or above the     closest integer value, the zooming factor is rounded to  the     nearest integer value. Like wise if the zoom factor is 1/4th     or below the closest integer value, the  zooming  factor  is     rounded  to the nearest integer value. If the zoom factor is     between 1/4th or 3/4th an integer value, then depending upon     the zooming factor, selected pixels are skipped in a uniform     pattern and the zooming factor is  rounded  to  the  nearest     integer.  In  this  case,  if the zooming factor is close or     above 1/2 the integer value, the zooming factor  is  rounded     to the nearest high integer value, else it is rounded to the     nearest lower integer value.&nbsp;     The zooming is performed as a  first  order  zooming  algor-     ithmn.  For  example,  a zooming factor n implies n*n pixels     are replicated in the neighborhood  of  any  given  original     pixel.&nbsp;     Depending upon  the  &lt;quadrant&gt;  chosen  by  the  user,  the     oppropriate  regions  in  the  original image are chosen and     zoomed accordingly. A new image of the appropriate  size  is     created  where  the  zoomed pixels of the original image are     written. The pointer to this newly created zoomed  image  is     returned to the calling function.&nbsp;TYPES AND CONSTANTS&nbsp;RETURN VALUES     Returns a pointer to an image.&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPgeometry.h&gt;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile, *outputfile;&nbsp;      setDisplay_Image(&quot;picture&quot;, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile, 1);      cvipImage = zoom(cvipImage, 1, -1, -1, -1, -1, 2.0);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      write_Image(cvipImage,   outputfile,CVIP_NO,CVIP_NO,format,     1);      display_Image(outputfile,format);      free(inputfile);      free(outputfile);      }&nbsp;BUGS     None at this time&nbsp;SEE ALSO     GEOMETRY library&nbsp;AUTHOR     Copyright (C) 1995, 2004 SIUE -  by  Scott  Umbaugh  and  Srinivas     Madiraju.&nbsp;\n\r\n\r&nbsp;","zoom","scr\\CVIP_C_functions/zoom.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-05T01:47:00Z  2004-10-20T00:21:00Z  1  444  2535  SIUE  21  5  2974  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     zvl_compress - performs Ziv-Lempel compression&nbsp;SYNOPSIS      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &lt;time.h&gt;      #include &lt;string.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #include &quot;CVIPdef.h&quot;      #include &quot;CVIPimage.h&quot;      #include &quot;CVIPcompress.h&quot;&nbsp;     int zvl_compress(Image *inputImage, char *filename)&nbsp;      &lt;inputImage&gt; - pointer to the image      &lt;filename&gt; - pointer to a character array&nbsp;     Image *zvl_decompress(char *filename)&nbsp;      &lt;filename&gt; - pointer to a character array&nbsp;PATH     $CVIPtoolsHOME\\CVIPC\\COMPRESSION\\zvl.cDESCRIPTION     This function encodes an image using  the  Ziv-Lempel  algo-     rithm. The first two 9-bit codes have been reserved for com-     munication between the encoder and decoder.&nbsp;TYPES AND CONSTANTS     #define INIT_BITS 9     #define MAX_BITS 14     #define HASHING_SHIFT MAX_BITS - 8&nbsp;     #if MAX_BITS == 14     /* Set the table size. Must be a prime number */     #define TABLE_SIZE 18041     #elif MAX_BITS == 13     #define TABLE_SIZE 9029     #else     #define TABLE_SIZE 5021     #endif&nbsp;     #define CLEAR_TABLE 256 /* Code to clear the string table */     #define TERMINATOR  257 /* Marks EOF condition, instead of MAX_VALUE */     #define FIRST_CODE  258 /* First available code for code_vaule table */     #define CHECK_TIME  100 /* Check comp ratio every CHECK_TIME chars input */     #define MAXVAL(n) (( 1 &lt;&lt;(n)) -1)  /* max_value formual macro */&nbsp;RETURN VALUES     zvl_compress: 0 on success, -1 on failure&nbsp;     zvl_decompression: an uncompressed image pointer on success,     a NULL pointer on failure&nbsp;HISTORY     History information recorded: None&nbsp;EXAMPLE      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPview.h&gt;      #include &lt;sys/types.h&gt;      #include &lt;sys/stat.h&gt;      #define VIEWER &quot;picture&quot;      #define VIDEO_APP &quot;SunVideo &amp;&quot;&nbsp;      void main()      {      Image *cvipImage;      IMAGE_FORMAT format;      char *inputfile,*outputfile;&nbsp;      setDisplay_Image(VIEWER, &quot;Default&quot;);&nbsp;      print_CVIP(&quot;\\n\\t\\tEnter the  Input File Name:  &quot;);      inputfile =(char *) getString_CVIP();      format = getFormat_CVIP(inputfile);      cvipImage = read_Image(inputfile,1);      view_Image(cvipImage, inputfile);      free(inputfile);      /* the following call performs the lempel ziv      coding of the input image */      zvl_compress(cvipImage,&quot;file1&quot;);      /* the following call performs the lempel ziv      decoding of the &quot;file1&quot; */      cvipImage=zvl_decompress(&quot;file1&quot;);      print_CVIP(&quot;\\n\\t\\tEnter the Output File Name:  &quot;);      outputfile = getString_CVIP();      view_Image(cvipImage,outputfile);      write_Image(cvipImage,outputfile,CVIP_NO,CVIP_NO,format,1);      free(outputfile);      }&nbsp;SEE ALSO     COMPRESSION library&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E. Umbaugh.&nbsp;\n\r\n\r&nbsp;","zvl_compress","scr\\CVIP_C_functions/zvl_compress.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  7  8  2004-06-04T19:02:00Z  2004-07-12T22:37:00Z  1  183  1045  SIUE  8  2  1226  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME&nbsp;&nbsp;&nbsp;&nbsp; ArithLogic- CVIPtools core toolbox&nbsp; library&nbsp; for&nbsp; arith-&nbsp;&nbsp;&nbsp;&nbsp; metic and logical functions&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPtoolkit.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPdef.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPimage.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPconvert.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIParithlogic.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; See the individual function man page for details&nbsp; and&nbsp; exam-&nbsp;&nbsp;&nbsp;&nbsp; ples.&nbsp;PATH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $CVIPtoolsHOME\\lib&nbsp;FUNCTIONS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The following functions are included in Arithlogic :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arithmetic functions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;====================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subtract_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; multiply_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; divide_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Logic functions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;===============&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The function not_Image requires only one&nbsp; input&nbsp; image;&nbsp; all&nbsp;&nbsp;&nbsp;&nbsp; other functions require two images.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\ARITHLOGIC&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; Functions listed above&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1996, 2004 SIUE - by Scott E Umbaugh.&nbsp;\n\r\n\r&nbsp;","ArithLogic","scr\\CVIPlibraries/ArithLogic.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  5  3  2004-06-04T02:16:00Z  2004-07-12T22:37:00Z  1  980  5592  SIUE  46  13  6559  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME&nbsp;&nbsp;&nbsp; Band - CVIPtools toolkit library for the data handling of&nbsp;&nbsp;&nbsp;&nbsp; multi-spectral imagery&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPband.h&gt;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPimage.h&gt;&nbsp;&nbsp;&nbsp;&nbsp; FUNCTIONS&nbsp;&nbsp;&nbsp;&nbsp; Band includes the following utilities:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assemble_bands&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bandcast&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bandcopy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; band_minmax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extract_band&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matalloc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matfree&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vecalloc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vecfree&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\BandUtilities&nbsp;&nbsp;DESCRIPTION&nbsp; ASSEMBLE MULTI-SPECTRAL Image FROM MONOCHROME ImageS&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image *assemble_bands(Image **inImgs, int noimgs);&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;inImgs&gt; - Pointer to array of image pointers&nbsp;&nbsp;&nbsp;&nbsp; &lt;noimgs&gt; - number of image pointers contained in the array.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: Pointer to new image structure.&nbsp;&nbsp; Description:&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; monochrome image planes to create&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a multispectral image.&nbsp; Diagnostics: - Supports&nbsp;&nbsp;&nbsp;&nbsp; COMPLEX data formats.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - If any color images are passed, only their&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first color band is used.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Adds history entry for operation.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Returns NULL if error is encountered.&nbsp;&nbsp; CAST DATA BANDS&nbsp;&nbsp;&nbsp;&nbsp; =========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MATRIX **bandcast(MATRIX **srcBANDS, int no_of_bands,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CVIP_TYPE data_type);&nbsp;&nbsp;&nbsp;&nbsp; =========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;srcBANDS&gt; - pointer to an array of MATRIX pointers&nbsp;&nbsp;&nbsp;&nbsp; &lt;no_of_bands&gt; - number of spectral data bands&nbsp;&nbsp;&nbsp;&nbsp; &lt;data_type&gt; - data type to be promoted to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to new array of MATRIX pointers&nbsp; cast&nbsp; into&nbsp;&nbsp;&nbsp;&nbsp; the&nbsp; specified&nbsp; data&nbsp; type&nbsp; Description: cast the data of an&nbsp;&nbsp;&nbsp;&nbsp; image pointed to by &lt;srcBANDS&gt; into&nbsp; a&nbsp; more&nbsp; precise&nbsp; type.&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics:&nbsp; returns&nbsp; with&nbsp; NULL&nbsp; pointer and error message&nbsp;&nbsp;&nbsp;&nbsp; when cast cannot be performed.&nbsp;&nbsp; COPY DATA BANDS&nbsp;&nbsp;&nbsp;&nbsp; =======================================================&nbsp;&nbsp;&nbsp;&nbsp; void bandcopy(MATRIX **, MATRIX **, int);&nbsp;&nbsp;&nbsp;&nbsp; =======================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;srcBANDS&gt; - pointer to an array of MATRIX pointers&nbsp;&nbsp;&nbsp;&nbsp; &lt;desBANDS&gt; - pointer to an array of MATRIX pointers&nbsp;&nbsp;&nbsp;&nbsp; &lt;no_of_bands&gt; - number of spectral data bands&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: copy the data pointed&nbsp; to&nbsp; be&nbsp; &lt;srcBANDS&gt;&nbsp; into&nbsp;&nbsp;&nbsp;&nbsp; that of &lt;desBANDS&gt;.&nbsp;&nbsp; FIND MIN AND MAX&nbsp;&nbsp;&nbsp;&nbsp; =================================================================&nbsp;&nbsp;&nbsp;&nbsp; void *band_minmax(MATRIX *const *bands, unsigned int no_of_bands,&nbsp;&nbsp;&nbsp;&nbsp; CVIP_TYPE data_type, int bstart, int bstop);&nbsp;&nbsp;&nbsp;&nbsp; =================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;bands&gt; - pointer to array of MATRIX pointers&nbsp;&nbsp;&nbsp;&nbsp; containing image data&nbsp;&nbsp;&nbsp;&nbsp; &lt;no_of_bands&gt; - number of spectral bands&nbsp;&nbsp;&nbsp;&nbsp; &lt;data_type&gt; - type of image data&nbsp;&nbsp;&nbsp;&nbsp; &lt;bstart&gt; - starting band&nbsp;&nbsp;&nbsp;&nbsp; &lt;bstop&gt; - stopping band&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: Pointer to array containing pairs of min.&nbsp; and&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; max.&nbsp; values.&nbsp; Array will have same data type as image data.&nbsp;&nbsp;&nbsp;&nbsp; Description: find the maximum and&nbsp; minimum&nbsp; values&nbsp; of&nbsp; each&nbsp;&nbsp;&nbsp;&nbsp; band&nbsp; of&nbsp; an&nbsp; image&nbsp; from &lt;bstart&gt; to &lt;bstop&gt;.&nbsp; Diagnostics:&nbsp;&nbsp;&nbsp;&nbsp; returns NULL pointer w/ error message&nbsp; if&nbsp; bstop&nbsp; &lt;&nbsp; bstart,&nbsp;&nbsp;&nbsp;&nbsp; etc.&nbsp;&nbsp; EXTRACT ONE BAND FROM MULTI-SPECTRAL Images&nbsp;&nbsp;&nbsp;&nbsp; ==========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image *extract_band(Image *inImg, int bandno);&nbsp;&nbsp;&nbsp;&nbsp; ==========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;inImgs&gt; - Pointer to image&nbsp;&nbsp;&nbsp;&nbsp; &lt;bandno&gt; - band number to be extracted from the image.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: Pointer to new image structure.&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Description: Create a monochrome image from a color&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image by extracting a color plane.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: - Supports COMPLEX data formats.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Adds history entry for operation.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Returns NULL if error is encountered.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===============================================================&nbsp;&nbsp;&nbsp;&nbsp; void *matalloc( unsigned int depth, unsigned int rows,&nbsp;&nbsp;&nbsp;&nbsp; unsigned int cols, size_t size );&nbsp;&nbsp;&nbsp;&nbsp; ===============================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;depth&gt; - depth of matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;rows&gt; - number of rows in matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;cols&gt; - number of columns in matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;size&gt; - size of each matrix element (e.g.&nbsp;&nbsp;&nbsp;&nbsp; sizeof(float))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: triple pointer to a new instance&nbsp; of&nbsp; an&nbsp; array&nbsp; of&nbsp;&nbsp;&nbsp;&nbsp; matrices&nbsp; Description: allocate an array of &lt;depth&gt; matrices&nbsp;&nbsp;&nbsp;&nbsp; each with &lt;rows&gt; rows and &lt;cols&gt; cols with an&nbsp; element&nbsp; size&nbsp;&nbsp;&nbsp;&nbsp; of&nbsp; &lt;size&gt;.&nbsp; NOTE: use matfree(...) to free the matrix Diag-&nbsp;&nbsp;&nbsp;&nbsp; nostics: returns NULL pointer w/ corresponding error message&nbsp;&nbsp;&nbsp;&nbsp; upon memory allocation failure.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================&nbsp;&nbsp;&nbsp;&nbsp; void matfree(void *matP, unsigned int no_of_planes);&nbsp;&nbsp;&nbsp;&nbsp; =====================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matP&gt; - pointer to matrix allocated w/ matalloc&nbsp;&nbsp;&nbsp;&nbsp; &lt;number_of_planes&gt; - depth of matrix (number of&nbsp;&nbsp;&nbsp;&nbsp; data bands)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: free the memory associated with a matrix&nbsp; allo-&nbsp;&nbsp;&nbsp;&nbsp; cated by matalloc&nbsp;&nbsp; MEMORY MANAGEMENT&nbsp;&nbsp;&nbsp;&nbsp; ===============================================================&nbsp;&nbsp;&nbsp;&nbsp; void *vecalloc( unsigned int no_of_vecs, unsigned int vdim,&nbsp;&nbsp;&nbsp;&nbsp; size_t size );&nbsp;&nbsp;&nbsp;&nbsp; ===============================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;no_of_vecs&gt; - number of vectors to allocate&nbsp;&nbsp;&nbsp;&nbsp; &lt;vdim&gt; - dimension of each vector&nbsp; &nbsp;&nbsp;&nbsp;&lt;size&gt; - size of each vector element (e.g.&nbsp;&nbsp;&nbsp;&nbsp; sizeof(float))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: double pointer to a new instance&nbsp; of&nbsp; an&nbsp; array&nbsp; of&nbsp;&nbsp;&nbsp;&nbsp; vectors.&nbsp;&nbsp; Description:&nbsp; allocate&nbsp; an&nbsp; array of &lt;no_of_vecs&gt;&nbsp;&nbsp;&nbsp;&nbsp; vectors each of size &lt;vdim&gt; with an element size of &nbsp;&lt;size&gt;.&nbsp;&nbsp;&nbsp;&nbsp; NOTE:&nbsp; use&nbsp; vecfree(...)&nbsp; to&nbsp; free&nbsp; the&nbsp; vector Diagnostics:&nbsp;&nbsp;&nbsp;&nbsp; returns NULL pointer w/&nbsp; corresponding&nbsp; error&nbsp; message&nbsp; upon&nbsp;&nbsp;&nbsp;&nbsp; memory allocation error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================&nbsp;&nbsp;&nbsp;&nbsp; void vecfree(void *vecP, unsigned int no_of_vecs);&nbsp;&nbsp;&nbsp;&nbsp; =====================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;vecP&gt; - pointer to vector allocated w/ vecalloc&nbsp;&nbsp;&nbsp;&nbsp; &lt;number_of_vecs&gt; - number of vectors (number of&nbsp;&nbsp;&nbsp;&nbsp; data bands)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: free the memory associated with a vector&nbsp; allo-&nbsp;&nbsp;&nbsp;&nbsp; cated by vecalloc&nbsp;BUGS&nbsp;&nbsp;&nbsp;&nbsp; none as of yet&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; CVIPtools&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1992, 1993, 1997, 2004 SIUE - by Gregory&nbsp; Hance&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; Scott Umbaugh.&nbsp;\n\r\n\r&nbsp;","Band","scr\\CVIPlibraries/Band.htm","   ACADEMIC COMPUTING  Normal  Mounika  3  2  2004-07-12T22:22:00Z  2010-04-23T16:06:00Z  1  125  717  SIUE  5  1  841  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME    Color - CVIPtools core toolbox  library  containing  rou-     tines related to color transforms&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPcolor.h&gt;&nbsp;     See the individual function man page for details and examples.&nbsp;FUNCTIONS     Color includes the following utilities:&nbsp;             colorxform             color_contrast_enhance             ipct             linxform             luminance_Image             lum_average             pct             pct_color             pseudocol_freq&nbsp;     The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\COLOR&nbsp;DESCRIPTION     see individual manual pages for each function&nbsp;AUTHOR     Copyright (C) 1992, 1993, 1996, 2004 SIUE - by Scott Umbaugh.&nbsp;\n\r\n\r&nbsp;","Color","scr\\CVIPlibraries/Color.htm","   ACADEMIC COMPUTING  skefel  8  2  2004-06-04T02:18:00Z  2010-01-06T19:22:00Z  1  331  1890  SIUE  15  4  2217  11.9999    Clean    false  false  false                  MicrosoftInternetExplorer4   NAME     Compression - CVIPtools  core  toolbox  library  for  image     compression and decompression routines&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPcompress.h&gt;&nbsp;     See the individual function man page for details  and  exam-     ples.&nbsp;PATH  $CVIPtoolsHOME\\lib  &nbsp;FUNCTIONS     The following functions are included in Compression:&nbsp;                    bit_compress, bit_decompress,                    bit_planeadd                    btc_compress, btc_decompress                    btc2_compress, btc2_decompress                    btc3_compress, btc3_decompress                    dpc_compress, dpc_decompress                    frac_compress, frac_decompress                    glr_compress, glr_decompress                    huf_compress, huf_decompress                    jp2_compress, jp2_decompress                    jpg_compress, jpg_decompress                    rms_error, snr                    vq_compress, vq_decompress                    xvq_compress, xvq_decompress                    zon_compress, zon_decompress                    zon2_compress, zon2_decompress                     zvl_compress, zvl_decompress&nbsp;     Each of the compress function accepts a pointer to an Image,     and  a  filename in which the compressd data will be stored,     and other parameters depending on different algorithms.  The     functions  will  release  the memory of the input Image, but     won\'t delete the memory by the string of filename.&nbsp;     Each  of the decompress function takes a  single  parameter,     the  file  name of the compressed data. The decompress func-     tions won\'t  release  the  memory  occupied  by  the  string     &quot;filename&quot;.          The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\COMPRESSION&nbsp;TYPES AND CONSTANTS     See individual function man pages&nbsp;RETURN VALUES     compress functions: 0 on success, -1 on failure&nbsp;     decompress functions: an uncompressed image pointer on  suc-     cess, a NULL pointer on failure&nbsp;SEE ALSO     CVIPcompress.h&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E Umbaugh.&nbsp;\n\r\n\r&nbsp;","Compression","scr\\CVIPlibraries/Compression.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  6  5  2004-06-04T02:18:00Z  2004-07-12T22:40:00Z  1  283  1616  SIUE  13  3  1896  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME&nbsp;&nbsp;&nbsp;&nbsp; Conversion- CVIPtools&nbsp; core&nbsp; toolbox&nbsp; library&nbsp; containing&nbsp;&nbsp;&nbsp;&nbsp; routines for image file I/O and format conversion&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPtoolkit.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPdef.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPimage.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPconvert.h&gt;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;See the individual function man page for details&nbsp; and&nbsp; exam-&nbsp;&nbsp;&nbsp;&nbsp; ples.&nbsp;PATH&nbsp; $CVIPtoolsHOME\\lib&nbsp;&nbsp; &nbsp;TYPES AND CONSTANTS&nbsp;&nbsp;&nbsp;&nbsp; typedef enum {PBM, PGM, PPM, EPS, TIF, GIF, RAS, ITX,IRIS, CCC, BIN, BMP, VIP, GLR, BTC, BRC, HUF, LZW, ARITH, BTC2, BTC3, DPC, SAFVR} IMAGE_FORMAT&nbsp;FUNCTIONS&nbsp;&nbsp;&nbsp;&nbsp; The following functions are included in Conversion:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CVIPhalftone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gray_binary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bintocvip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bmptocvip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ccctocvip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; epstocvip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; giftocvip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iristocvip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itextocvip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jpgtocvip&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pnmtocvip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rastocvip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tifftocvip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; viptocvip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cviptobin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cviptobmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cviptoccc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cviptoeps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cviptogif&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cviptoiris&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cviptoitex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cviptojpg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cviptopnm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cviptoras&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cviptotiff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cviptovip&nbsp;&nbsp;&nbsp;&nbsp; The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\CONVERSION&nbsp;RETURN VALUES&nbsp;&nbsp;&nbsp;&nbsp; See function man pages&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; Functions listed above&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1996, 2004 SIUE - by Scott E Umbaugh.&nbsp;\n\r\n\r&nbsp;","Conversion","scr\\CVIPlibraries/Conversion.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  5  1  2004-06-04T02:19:00Z  2004-07-12T22:41:00Z  1  92  529  SIUE  4  1  620  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME&nbsp;&nbsp;&nbsp;&nbsp; Display - CVIPtools core toolbox library&nbsp; for&nbsp; displaying&nbsp;&nbsp;&nbsp;&nbsp; images&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPtoolkit.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPdef.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPimage.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPconvert.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPview.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; See the individual function man page for details&nbsp; and&nbsp; exam-&nbsp;&nbsp;&nbsp;&nbsp; ples.&nbsp;PATH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $CVIPtoolsHOME\\lib&nbsp;FUNCTIONS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\Display&nbsp;RETURN VALUES&nbsp;&nbsp;&nbsp;&nbsp; See function man pages&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1996, 2004 SIUE - by Scott E Umbaugh,&nbsp; Kun&nbsp; Luo&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; Yansheng Wei.&nbsp;\n\r\n\r&nbsp;","Display","scr\\CVIPlibraries/Display.html","	   ACADEMIC COMPUTING  skefel  19  16  2004-06-04T02:20:00Z  2010-07-17T21:02:00Z  1  300  1714  SIUE  14  4  2010  12.00    false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                              	NAMEFeature - CVIPtools  core  toolbox  library  for  feature          extraction and pattern classification routines&nbsp;SYNOPSIS      #include &lt; CVIPtoolkit.h&gt;      #include &lt; CVIPdef.h&gt;      #include &lt; CVIPimage.h&gt;      #include &lt; CVIPconvert.h&gt;      #include &lt; CVIPfeatures.h&gt;&nbsp;     See the individual function man page for details  and  exam-     ples.&nbsp;PATH     $CVIPtoolsHOME\\lib&nbsp;FUNCTIONS     The following functions are included in Feature:&nbsp;                           area                           aspect                           centroid                           city_block                           euclidean_distance                           euler                           hist_feature                           k_nearest_neighbor                           irregular                           label                           maximum_value_metric                           min_max_normalization                           minkowski_distance                           nearest_centroid                           nearest_centroid_set                           nearest_neighbor                           orientation                           pattern_city_block                           pattern_euclidean                           pattern_maximum                           pattern_min_max_normalization                           pattern_minkowski                           pattern_range_normalize                           pattern_softmax_scaling_normalization                           pattern_standard_normal_density_normalization                           pattern_tanimoto                           pattern_unit_vector_normalization                           pattern_vector_inner_product                           perimeter                           projection                           range_normalize                           rst_invariant                           softmax_scaling                           standard_normal_density_normalization                           spectral_feature                           tanimoto_metric                           texture                           texture2                           thinness                           unit_vector_normalization                           vector_inner_product                            The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\FEATURE&nbsp;RETURN VALUES     See function man pages&nbsp;SEE ALSO     Functions listed above&nbsp;AUTHOR     Copyright (C) 1996, 2004, 2005 SIUE - by Scott E Umbaugh, Husain Kagalwalla&nbsp;\n\r\n\r&nbsp;","Feature","scr\\CVIPlibraries/Feature.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  7  4  2004-06-04T02:20:00Z  2004-10-12T23:44:00Z  1  244  1393  SIUE  11  3  1634  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     Geometry - CVIPtools core toolbox library  for  geometric     manipulations&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPgeometry.h&gt;&nbsp;     See the individual function man pages for details and  exam-     ples.&nbsp;PATH        $CVIPtoolsHOME\\lib&nbsp;FUNCTIONS     The following functions are included in Geometry:&nbsp;                          bilinear_interp                          copy_paste                          create_black                          creat_checkboard                          create_cosine                          create_circle                          create_degenerate_circle                          create_ellipse                          create_line                          create_rectangle                          create_sine                          create_squarewave                          crop                          display_mesh                          enlarge                          keyboard_to_mesh                          mesh_warping                          mesh_to_file                          object_crop                          rotate                          shrink                          solve_c                          spatial_quant                          translate                          zoom&nbsp;      The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\GEOMETRY&nbsp;RETURN VALUES     See individual function man pages&nbsp;SEE ALSO     Functions listed above&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E Umbaugh.&nbsp;\n\r\n\r&nbsp;","Geometry","scr\\CVIPlibraries/Geometry.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  5  2  2004-06-04T02:21:00Z  2004-07-12T22:44:00Z  1  146  837  SIUE  6  1  982  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME&nbsp;&nbsp;&nbsp;&nbsp; Histogram - CVIPtools&nbsp; core&nbsp; toolbox&nbsp; library&nbsp; for&nbsp; histogram&nbsp;&nbsp;&nbsp;&nbsp; manipulation&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPtoolkit.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPdef.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPimage.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPconvert.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPhisto.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; See the individual function man pages for details and&nbsp; exam-&nbsp;&nbsp;&nbsp;&nbsp; ples.&nbsp;PATH&nbsp;&nbsp; $CVIPtoolsHOME\\lib&nbsp;FUNCTIONS&nbsp;&nbsp;&nbsp;&nbsp; The following functions are included in Histogram:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_histogram&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_histogram&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_histogram_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gray_linear&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gray_multiply&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gray_multiply2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; histeq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; histogram_show&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hist_spec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; histogram_spec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hist_slide&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hist_stretch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; local_histeq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; make_histogram&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; showMax_histogram&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\HISTOGRAM&nbsp;RETURN VALUES&nbsp;&nbsp;&nbsp;&nbsp; See individual function man pages&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; Functions listed above&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1996, 2004 SIUE - by Scott E Umbaugh.&nbsp;\n\r\n\r&nbsp;","Histogram","scr\\CVIPlibraries/Histogram.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  6  3  2004-06-04T02:22:00Z  2004-07-12T22:44:00Z  1  3238  18461  SIUE  153  43  21656  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME&nbsp;&nbsp;&nbsp;&nbsp; Image - CVIPtools toolkit library containing routines for&nbsp;&nbsp;&nbsp;&nbsp; image type conversion, memory management, etc.&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPimage.h&gt;&nbsp;DESCRIPTION&nbsp; TYPES AND CONSTANTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef enum {PBM, PGM, PPM, EPS, TIF, GIF, RAS, ITX, IRIS, CCC, BIN, VIP, GLR, BTC, BRC, HUF, ZVL, ARITH, BTC2, BTC3, DPC, ZON, ZON2, SAFVR, JPG, WVQ, FRA, VQ, XVQ} IMAGE_FORMAT;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef enum {BINARY, GRAY_SCALE, RGB, HSL, HSV, SCT, CCT, LUV, LAB, XYZ}&nbsp;&nbsp;&nbsp;&nbsp; COLOR_FORMAT;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMAGE_FORMAT image_format;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COLOR_FORMAT color_space;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bands;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix **image_ptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HISTORY story;&nbsp;&nbsp;&nbsp;&nbsp; } Image;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef enum {CVIP_BYTE, CVIP_SHORT, CVIP_INTEGER, CVIP_FLOAT, CVIP_DOUBLE} CVIP_TYPE;&nbsp;&nbsp;&nbsp;&nbsp; typedef enum {REAL, COMPLEX} FORMAT;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CVIP_TYPE data_type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORMAT data_format;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int rows;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int cols;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void **rptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void **iptr;&nbsp;&nbsp;&nbsp;&nbsp; } Matrix;&nbsp;FUNCTIONS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The following functions are included in this manpage:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cast_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getRealPixel_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getRealRow_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dump_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getRow_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; duplicate_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; history_add&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getBandVector_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; history_check&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getBand_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; history_copy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getColorSpace_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; history_get&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getDataFormat_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; history_print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getDataType_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; history_show&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getFileFormat_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makeComplex_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImagPixel_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makeReal_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImagRow_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getNoOfBands_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setBand_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getNoOfCols_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setImagPixel_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getNoOfRows_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setPixel_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getPixel_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setRealPixel_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getData_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getRealData_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\Image&nbsp;&nbsp; MEMORY MANAGEMENT&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; Image *new_Image(IMAGE_FORMAT image_format, COLOR_FORMAT color_space,&nbsp;&nbsp;&nbsp;&nbsp; int bands, int heigth, int width, CVIP_TYPE data_type,&nbsp;&nbsp;&nbsp;&nbsp; FORMAT data_format)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;image_format&gt; - original file format of image&nbsp;&nbsp;&nbsp;&nbsp; &lt;color_space&gt; - current color space of image&nbsp;&nbsp;&nbsp;&nbsp; &lt;bands&gt; - number of spectral bands&nbsp;&nbsp;&nbsp;&nbsp; &lt;height&gt; - height of image (no. of rows)&nbsp;&nbsp;&nbsp;&nbsp; &lt;width&gt; - width of image (no. of cols)&nbsp;&nbsp;&nbsp;&nbsp; &lt;data_type&gt; - current data type of image&nbsp;&nbsp;&nbsp;&nbsp; &lt;data_format&gt; - specifies real or complex data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer&nbsp; to&nbsp; Image&nbsp; structure.&nbsp; Description:&nbsp; Image&nbsp;&nbsp;&nbsp;&nbsp; class&nbsp; constructor.&nbsp; creates&nbsp; a&nbsp; new instance of a CVIPtools&nbsp;&nbsp;&nbsp;&nbsp; Image structure.The Image structure is the primary means&nbsp; of&nbsp;&nbsp;&nbsp;&nbsp; data&nbsp; transport&nbsp; in CVIPtools. Ordinarily the developer does&nbsp;&nbsp;&nbsp;&nbsp; not have to worry about allocating an Image structure in the&nbsp;&nbsp;&nbsp;&nbsp; sense that the function read_Image(...) returns a pointer to&nbsp;&nbsp;&nbsp;&nbsp; an Image structure that has been initialized to the specifi-&nbsp;&nbsp;&nbsp;&nbsp; cations&nbsp; of&nbsp; a&nbsp; particular image. Diagnostics returns a NULL&nbsp;&nbsp;&nbsp;&nbsp; pointer w/ respective error message when a memory allocation&nbsp;&nbsp;&nbsp;&nbsp; request can not be satisfied.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; void delete_Image(Image *A)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to Image structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Image class destructor. Free all elements of an&nbsp;&nbsp;&nbsp;&nbsp; Image&nbsp; structure.&nbsp;&nbsp; Diagnostics:&nbsp; complains if the structure&nbsp;&nbsp;&nbsp;&nbsp; passed is not valid.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp; Image DISPLAY&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; Image *duplicate_Image(const Image *a)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;a&gt; - pointer to Image structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns:&nbsp; pointer&nbsp; to&nbsp; new&nbsp; Image&nbsp; structure.&nbsp;&nbsp; Description:&nbsp;&nbsp;&nbsp;&nbsp; creates&nbsp; a new instance of the Image structure pointed to by&nbsp;&nbsp;&nbsp;&nbsp; &lt;a&gt;. This function is useful if one wants to pass&nbsp; an&nbsp; Image&nbsp;&nbsp;&nbsp;&nbsp; structure&nbsp; to&nbsp; a&nbsp; function to be processed while maintaining&nbsp;&nbsp;&nbsp;&nbsp; the integrity of the original image.&nbsp; Diagnostics: complains&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp; returns&nbsp; NULL&nbsp; pointer&nbsp; upon memory allocation failure.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp; CASTING TO NEW TYPES - FORMATS&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; int cast_Image(Image *src, CVIP_TYPE dtype)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;src&gt; - pointer to Image structure&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; - new data type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: 0 or 1.&nbsp; Description: casts an Image structure into&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp; more&nbsp; precise&nbsp; data&nbsp; type.&nbsp; Diagnostics: returns 1 if the&nbsp;&nbsp;&nbsp;&nbsp; cast can be performed (i.e. the type specified by &lt;type&gt;&nbsp; is&nbsp;&nbsp;&nbsp;&nbsp; more&nbsp; precise&nbsp; than that of &lt;src&gt; and 0 if the type of &lt;src&gt;&nbsp;&nbsp;&nbsp;&nbsp; is more precise than that of &lt;type&gt;. If the&nbsp; types&nbsp; are&nbsp; the&nbsp;&nbsp;&nbsp;&nbsp; same&nbsp; or&nbsp; 0&nbsp; is&nbsp; returned&nbsp; then&nbsp; &lt;src&gt;&nbsp; is&nbsp; left&nbsp; untouched.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; void makeComplex_Image(Image *src)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;src&gt; - pointer to &quot;real&quot; Image structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: create a &quot;complex&quot; Image structure&nbsp; by&nbsp; reallo-&nbsp;&nbsp;&nbsp;&nbsp; cating&nbsp; the&nbsp; storage&nbsp; the associated with the Image -- &lt;src&gt;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: complains when an invalid&nbsp; Image&nbsp; structure&nbsp; is&nbsp;&nbsp;&nbsp;&nbsp; passed.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; void makeReal_Image(Image *src)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;src&gt; - pointer to &quot;complex&quot; Image structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: create a &quot;real&quot; Image structure by reallocating&nbsp;&nbsp;&nbsp;&nbsp; the storage the associated with the Image -- &lt;src&gt;. Diagnos-&nbsp;&nbsp;&nbsp;&nbsp; tics: complains when an invalid Image structure&nbsp; is&nbsp; passed.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp; IMPORTING &amp; EXPORTING DATA&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; void getBandVector_Image(Image *imageP, void *vecP)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;imageP&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp; &lt;vecP&gt; - pointer to a vector that will reference the image data bands&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: unload the Image bands into a vector Author(s):&nbsp;&nbsp;&nbsp;&nbsp; Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; unsigned getNoOfRows_Image(Image *image)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns the height&nbsp; of&nbsp; an&nbsp; Image.&nbsp;&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp; Gregory Hance.&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;=====================================================================&nbsp;&nbsp;&nbsp;&nbsp; unsigned getNoOfCols_Image(Image *image)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns the width of an Image.&nbsp; Author(s): Gre-&nbsp;&nbsp;&nbsp;&nbsp; gory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; void *getData_Image(Image *image,unsigned int bands)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns reference to the real data of a&nbsp; matrix&nbsp;&nbsp;&nbsp;&nbsp; for the particular band.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; void *getRealData_Image(Image *image,unsigned int bands)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns reference to the real data of a&nbsp; matrix&nbsp;&nbsp;&nbsp;&nbsp; for the particular band.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; CVIP_TYPE getDataType_Image(Image *image)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; returns&nbsp; the&nbsp; data&nbsp; type&nbsp; of&nbsp; an&nbsp; Image&nbsp; (e.g.&nbsp;&nbsp;&nbsp;&nbsp; CVIP_BYTE,CVIP_FLOAT, etc.)&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; FORMAT getDataFormat_Image(Image *image)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns the data format of an image (i.e.&nbsp; REAL&nbsp;&nbsp;&nbsp;&nbsp; or COMPLEX).&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; IMAGE_FORMAT getFileFormat_Image(Image *image)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns the&nbsp; file&nbsp; format&nbsp; of&nbsp; an&nbsp; Image&nbsp; (e.g.&nbsp;&nbsp;&nbsp;&nbsp; PPM,PGM,etc.).&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; COLOR_FORMAT getColorSpace_Image(Image *image)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns the&nbsp; color&nbsp; space&nbsp; of&nbsp; an&nbsp; Image&nbsp; (e.g.&nbsp;&nbsp;&nbsp;&nbsp; RGB,GRAY, etc.).&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; unsigned getNoOfBands_Image(Image *image)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns the number of data bands in&nbsp; an&nbsp; Image.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *getBand_Image(Image *image, unsigned band)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp; &lt;band&gt; - band number to reference (0 ... bands-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns a band&nbsp; of&nbsp; Image&nbsp; data&nbsp; as&nbsp; a&nbsp; Matrix.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *setBand_Image(Image *image, unsigned band, unsigned band_no)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp; &lt;band&gt; - new band number to reference&nbsp;&nbsp;&nbsp;&nbsp; &lt;band_no&gt; - band number to reference (0 ... bands-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: add a new reference to a band of&nbsp; matrix&nbsp; data.&nbsp;&nbsp;&nbsp;&nbsp; Sets band_no equal to band.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; void *getRealRow_Image(Image *image, unsigned row, unsigned band)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp; &lt;row&gt; - row number to reference (0 ... rows-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;band&gt; - band number to reference (0 ... bands-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns a reference to a real row of image data&nbsp;&nbsp;&nbsp;&nbsp; in&nbsp; band&nbsp; &lt;band&gt;&nbsp; at&nbsp; row offset &lt;row&gt;..&nbsp; Author(s): Gregory&nbsp;&nbsp;&nbsp;&nbsp; Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; void *getRow_Image(Image *image, unsigned row, unsigned band)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp; &lt;row&gt; - row number to reference (0 ... rows-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;band&gt; - band number to reference (0 ... bands-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; same as &quot;getRealRow_Image&quot; Author(s):&nbsp; Gregory&nbsp;&nbsp;&nbsp;&nbsp; Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; void *getImagRow_Image(Image *image, unsigned row, unsigned band)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp; &lt;row&gt; - row number to reference (0 ... rows-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;band&gt; - band number to reference (0 ... bands-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; returns a reference to&nbsp; an&nbsp; imaginary&nbsp; row&nbsp; of&nbsp;&nbsp;&nbsp;&nbsp; image&nbsp; data&nbsp; in band &lt;band&gt; at row offset &lt;row&gt;.&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp; Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; type getRealPixel_Image(Image *image, type, unsigned col, unsigned row,&nbsp;&nbsp;&nbsp;&nbsp; unsigned band)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; - the name of a valid &quot;C&quot;, CVIPtools data type (i.e. one of byte,&nbsp;&nbsp;&nbsp;&nbsp; short, int, float or double)&nbsp;&nbsp;&nbsp;&nbsp; &lt;col&gt; - column number to reference (0 ... cols-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;row&gt; - row number to reference (0 ... rows-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;band&gt; - band number to reference (0 ... bands-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: read a real pixel sample&nbsp; of&nbsp; image&nbsp; data&nbsp; from&nbsp;&nbsp;&nbsp;&nbsp; band&nbsp; &lt;band&gt;&nbsp; at&nbsp; row&nbsp; offset &lt;row&gt; and column offset &lt;col&gt;.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; type getPixel_Image(Image *image, type, unsigned col, unsigned row,&nbsp;&nbsp;&nbsp;&nbsp; unsigned band)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; - the name of a valid &quot;C&quot;, CVIPtools data type (i.e. one of byte,&nbsp;&nbsp;&nbsp;&nbsp; short, int, float or double)&nbsp;&nbsp;&nbsp;&nbsp; &lt;col&gt; - column number to reference (0 ... cols-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;row&gt; - row number to reference (0 ... rows-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;band&gt; - band number to reference (0 ... bands-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: same as &quot;getRealPixel_Image&quot; Author(s): Gregory&nbsp;&nbsp;&nbsp;&nbsp; Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; type getImagPixel_Image(Image *image, type, unsigned col, unsigned row,&nbsp;&nbsp;&nbsp;&nbsp; unsigned band)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; - the name of a valid &quot;C&quot;, CVIPtools data type (i.e. one of byte,&nbsp;&nbsp;&nbsp;&nbsp; short, int, float or double)&nbsp;&nbsp;&nbsp;&nbsp; &lt;col&gt; - column number to reference (0 ... cols-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;row&gt; - row number to reference (0 ... rows-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;band&gt; - band number to reference (0 ... bands-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: read an imaginary pixel sample&nbsp; of&nbsp; image&nbsp; data&nbsp;&nbsp;&nbsp;&nbsp; from&nbsp; band&nbsp; &lt;band&gt;&nbsp; at&nbsp; row&nbsp; offset&nbsp; &lt;row&gt; and column offset&nbsp;&nbsp;&nbsp;&nbsp; &lt;col&gt;.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================&nbsp;&nbsp;&nbsp;&nbsp; void history_add(image, newstuff)&nbsp;&nbsp;&nbsp;&nbsp; =====================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Image *image;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HISTORY newstuff;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Adds the contents in the structure pointed to by newstuff to the&nbsp;&nbsp;&nbsp;&nbsp; image history.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;CVIPimage.h&quot;&nbsp;&nbsp;&nbsp;&nbsp; HISTORY stuff;&nbsp;&nbsp;&nbsp;&nbsp; int *hptr;&nbsp;&nbsp;&nbsp;&nbsp; stuff = (HISTORY)malloc(sizeof(struct history));&nbsp;&nbsp;&nbsp;&nbsp; stuff-&gt;packetP = (PACKET *)malloc(sizeof(PACKET));&nbsp;&nbsp;&nbsp;&nbsp; stuff-&gt;packetP-&gt;dsize=1;&nbsp;&nbsp;&nbsp;&nbsp; stuff-&gt;packetP-&gt;dtype=(CVIP_TYPE *)malloc(sizeof(CVIP_TYPE));&nbsp;&nbsp;&nbsp;&nbsp; stuff-&gt;packetP-&gt;dtype[0]=CVIP_INTEGER;&nbsp;&nbsp;&nbsp;&nbsp; hptr=(int *)malloc(sizeof(int));&nbsp;&nbsp;&nbsp;&nbsp; hptr[0]=block_size;&nbsp;&nbsp;&nbsp;&nbsp; stuff-&gt;packetP-&gt;dptr=(void **)malloc(sizeof(void *)*dsize);&nbsp;&nbsp;&nbsp;&nbsp; stuff-&gt;packetP-&gt;dptr=(void *)(int *)hptr;&nbsp;&nbsp;&nbsp;&nbsp; stuff-&gt;next=(HISTORY)NULL;&nbsp;&nbsp;&nbsp;&nbsp; stuff-&gt;ftag=WALSH;&nbsp;&nbsp;&nbsp;&nbsp; history_add(input_Image, stuff);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arve Kjoelen, Southern Illinois University at Edwardsville, 1993.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The document history_doc.frame contained in $CVIPHOME/docs contains a&nbsp;&nbsp;&nbsp;&nbsp; complete listing of the routines supported by the history structure&nbsp;&nbsp;&nbsp;&nbsp; along with additional documentation.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ============================================================&nbsp;&nbsp;&nbsp;&nbsp; CVIP_BOOLEAN history_check(PROGRAMS routine, Image *your_image)&nbsp;&nbsp;&nbsp;&nbsp; ============================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Determines whether the CVIPtools program specified by \'routine\' has been&nbsp;&nbsp;&nbsp;&nbsp; performed on the image.&nbsp; returns CVIP_YES if the program has been performed, returns CVIP_NO if the program has not been performed on that image.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;CVIPimage.h&quot;&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;CVIPdef.h&quot;&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;CVIPtools.h&quot;&nbsp;&nbsp;&nbsp;&nbsp; Image *my_image;&nbsp;&nbsp;&nbsp;&nbsp; if(history_check(FFT, my_image) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp; else {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arve Kjoelen, Southern Illinois University at Edwardsville, 1993.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The document history_doc.frame contained in $CVIPHOME/docs contains a&nbsp;&nbsp;&nbsp;&nbsp; complete listing of the routines supported by the history structure&nbsp;&nbsp;&nbsp;&nbsp; along with additional documentation.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================&nbsp;&nbsp;&nbsp;&nbsp; HISTORY history_get(Image *image, PROGRAMS routine)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Checks whether the CVIPtools program specified by \'routine\' has been&nbsp;&nbsp;&nbsp;&nbsp; performed on the image.&nbsp; Returns a pointer to the history structure&nbsp;&nbsp;&nbsp;&nbsp; containing information about the program.&nbsp; If the program has not been&nbsp;&nbsp;&nbsp;&nbsp; performed on the image, (HISTORY)NULL is returned.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* This sample code extracts the blocksize of a previously */&nbsp;&nbsp;&nbsp;&nbsp; /* performed FFT from the history structure of an image.&nbsp;&nbsp; */&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;CVIPimage.h&quot;&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;CVIPdef.h&quot;&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;CVIPtools.h&quot;&nbsp;&nbsp;&nbsp;&nbsp; Image *my_image;&nbsp;&nbsp;&nbsp;&nbsp; HISTORY story;&nbsp;&nbsp;&nbsp;&nbsp; int *dataptr;&nbsp;&nbsp;&nbsp;&nbsp; int blocksize;&nbsp;&nbsp;&nbsp;&nbsp; if(history_check(HAAR, my_image) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; story=(HISTORY)history_get(my_image, HAAR);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dataptr=(int *)story-&gt;packetP-&gt;dptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blocksize=dataptr[0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The document history_doc.frame contained in $CVIPHOME/docs contains a&nbsp;&nbsp;&nbsp;&nbsp; complete listing of the routines supported by the history structure&nbsp;&nbsp;&nbsp;&nbsp; along with additional documentation.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ====================================&nbsp;&nbsp;&nbsp;&nbsp; void history_show(Image *your_image)&nbsp;&nbsp;&nbsp;&nbsp; ====================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This routine checks the image history structure for entries (programs&nbsp;&nbsp;&nbsp;&nbsp; that have been performed on the structure). It then passes each entry&nbsp;&nbsp;&nbsp;&nbsp; to the function history_print, which prints the processing history to stdout.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AUTHOR Arve Kjoelen, Southern Illinois University at Edwardsville, 1993&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; The document history_doc.frame contained in $CVIPHOME/docs contains a&nbsp;&nbsp;&nbsp;&nbsp; complete listing of the routines supported by the history structure&nbsp;&nbsp;&nbsp;&nbsp; along with additional documentation.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ====================================&nbsp;&nbsp;&nbsp;&nbsp; void history_print(HISTORY stuff)&nbsp;&nbsp;&nbsp;&nbsp; ====================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This routine performs the actual output of the information associated&nbsp;&nbsp;&nbsp;&nbsp; with the history structure passed to it.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The document history_doc.frame contained in $CVIPHOME/docs contains a&nbsp;&nbsp;&nbsp;&nbsp; complete listing of the routines supported by the history structure&nbsp;&nbsp;&nbsp;&nbsp; along with additional documentation.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===================================================&nbsp;&nbsp;&nbsp;&nbsp; void history_copy(Image *fromimage, Image *toimage&nbsp;&nbsp;&nbsp;&nbsp; ===================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Copies the history information contained in fromimage to to image.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;CVIPimage.h&quot;&nbsp;&nbsp;&nbsp;&nbsp; Image *fromimage, *toimage;&nbsp;&nbsp;&nbsp;&nbsp; (void)history_copy(fromimage, toimage);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; void setRealPixel_Image(Image *image, type, unsigned col, unsigned row,&nbsp;&nbsp;&nbsp;&nbsp; unsigned band, type pixel)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; - the name of a valid &quot;C&quot;, CVIPtools data type (i.e. one of byte,&nbsp;&nbsp;&nbsp;&nbsp; short, int, float or double)&nbsp;&nbsp;&nbsp;&nbsp; &lt;col&gt; - column number to reference (0 ... cols-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;row&gt; - row number to reference (0 ... rows-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;band&gt; - band number to reference (0 ... bands-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;pixel&gt; - pixel sample of type &lt;type&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: write a real pixel sample of image data to band&nbsp;&nbsp;&nbsp;&nbsp; &lt;band&gt;&nbsp;&nbsp; at&nbsp; row&nbsp; offset&nbsp; &lt;row&gt;&nbsp; and&nbsp; column&nbsp; offset&nbsp; &lt;col&gt;.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; void setPixel_Image(Image *image, type, unsigned col, unsigned row,&nbsp;&nbsp;&nbsp;&nbsp; unsigned band, type pixel) &nbsp;&nbsp;&nbsp;&nbsp;=====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; - the name of a valid &quot;C&quot;, CVIPtools data type (i.e. one of byte,&nbsp;&nbsp;&nbsp;&nbsp; short, int, float or double)&nbsp;&nbsp;&nbsp;&nbsp; &lt;col&gt; - column number to reference (0 ... cols-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;row&gt; - row number to reference (0 ... rows-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;band&gt; - band number to reference (0 ... bands-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;pixel&gt; - pixel sample of type &lt;type&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: same as &quot;setRealPixel_Image&quot;.&nbsp; Author(s):&nbsp; Gre-&nbsp;&nbsp;&nbsp;&nbsp; gory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; void setImagPixel_Image(Image *image, type, unsigned col, unsigned row,&nbsp;&nbsp;&nbsp;&nbsp; unsigned band, type pixel)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - pointer to an Image object&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; - the name of a valid &quot;C&quot;, CVIPtools data type (i.e. one of byte,&nbsp;&nbsp;&nbsp;&nbsp; short, int, float or double)&nbsp;&nbsp;&nbsp;&nbsp; &lt;col&gt; - column number to reference (0 ... cols-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;row&gt; - row number to reference (0 ... rows-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;band&gt; - band number to reference (0 ... bands-1)&nbsp;&nbsp;&nbsp;&nbsp; &lt;pixel&gt; - pixel sample of type &lt;type&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: write an imaginary pixel sample of&nbsp; image&nbsp; data&nbsp;&nbsp;&nbsp;&nbsp; to&nbsp; band &lt;band&gt; at row offset &lt;row&gt; and column offset &lt;col&gt;.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp; MISC.&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp; CVIP_BOOLEAN dump_Image(Image *src)&nbsp;&nbsp;&nbsp;&nbsp; =====================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;src&gt; - pointer to Image structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: 1 upon success; 0 upon failure. Description:&nbsp; print&nbsp;&nbsp;&nbsp;&nbsp; the contents of an Image structure Diagnostics: returns 0 if&nbsp;&nbsp;&nbsp;&nbsp; the pointer to the Image structure is not valid.&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp; Gregory Hance.&nbsp;BUGS&nbsp;&nbsp;&nbsp;&nbsp; none as of yet&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; CVIPtools library quick reference guide&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1992, 1993, 2004 SIUE - by Gregory Hance&nbsp; and&nbsp; Scott&nbsp;&nbsp;&nbsp;&nbsp; Umbaugh.&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; CONVERSION(for read_Image, write_Image)&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1995, 2004 SIUE - by Scott Umbaugh.&nbsp;\n\r\n\r&nbsp;","Image","scr\\CVIPlibraries/Image.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-04T02:23:00Z  2004-07-12T22:45:00Z  1  1663  9482  SIUE  79  22  11123  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAMEIO - CVIPtools toolkit library for general  purpose  I/O,     memory management, etc.&nbsp;SYNOPSIS     #include &lt;CVIPio.h&gt;     #include &lt;CVIPtoolkit.h&gt;&nbsp;DESCRIPTION  TYPES AND CONSTANTS     #define LINELENGTH 80&nbsp;  INITIALIZATION     ********************************************************     void init_CVIP( int* argcP, char* argv[] )     ********************************************************&nbsp;     &lt;argcP&gt; - pointer to the number of command line arguments     &lt;argv&gt; - array of pointers to the command line arguments&nbsp;     Description: searches for global command line arguments such     as   --   &quot;-quit&quot;   -   do  not  print  messages  issued  w/     cvip_msg(...)  &quot;-version&quot; - print current version  of  CVIP-     tools and then exit program.  Author(s): Gregory Hance.&nbsp;  MESSAGES AND ERRORS     *************************************************     void quiet_CVIP(void)     *************************************************&nbsp;     Description: turns off messages displayed by msg_CVIP(...)&nbsp;     *************************************************     void verbose_CVIP(void)     *************************************************&nbsp;     Description: turns on messages displayed  by  msg_CVIP(...).     Author(s): Gregory Hance.&nbsp;     *************************************************     void usage_CVIP( const char *fn, const char *usage )     *************************************************&nbsp;     &lt;fn&gt; - pointer to character string containing the     name of the program     &lt;usage&gt; - pointer to character string containing a     usage message for the current program.&nbsp;     Description: prints a usage message out to stderr  and  then     exits the program.  Author(s): Gregory Hance.     *************************************************     void perror_CVIP( const char *fn, const char *reason )     *************************************************&nbsp;     &lt;fn&gt; - pointer to character string containing the     name of the program     &lt;usage&gt; - pointer to character string containing a     message about the reason of the error.&nbsp;     Description: print a system  error  to  stderr.   Author(s):     Gregory Hance.&nbsp;     *************************************************     void msg_CVIP( const char *fn, const char *msg, ... )     *************************************************&nbsp;     &lt;fn&gt; - pointer to character string containing the     name of the program/function     &lt;msg&gt; - pointer to a format control string in the     form of printf(...) (e.g. &quot;x = %d&quot;).     &lt;...&gt; - list of variables, seperated by commas, to be     used by the format control string. (e.g.) -     msg_CVIP(&quot;myfunc&quot;, &quot;x = %d&quot;, 3) =&gt; &quot;myfunc: x = 3&quot;&nbsp;     Description: print  an  informational  message.   Author(s):     Gregory Hance.&nbsp;     *************************************************     void print_CVIP( const char *msg, ... )     *************************************************&nbsp;     &lt;msg&gt; - pointer to a format control string in the     form of printf(...) (e.g. &quot;x = %d&quot;).     &lt;...&gt; - list of variables, seperated by commas, to be     used by the format control string. (e.g.) -     msg_CVIP(&quot;myfunc&quot;, &quot;x = %d&quot;, 3) =&gt; &quot;myfunc: x = 3&quot;&nbsp;     Description: print an informational message.  Like  msg_CVIP     except  the source function is not printed.  Author(s): Gre-     gory Hance.&nbsp;     *************************************************      void error_CVIP( const char *fn, const char *error, ... )     *************************************************&nbsp;     &lt;fn&gt; - pointer to character string containing the     name of the program/function     &lt;format&gt; - pointer to a format control string in the     form of printf(...) (e.g. &quot;x != %d&quot;).     &lt;...&gt; - list of variables, seperated by commas, to be     used by the format control string.&nbsp;     Description: print an error message prefixed by  a  standard     CVIPtools  error  tag.  (e.g.)  - error_CVIP(&quot;myfunc&quot;, &quot;x !=     %d&quot;, 3) =&gt;  &quot;&lt;myfunc-error&gt;:  x  !=  3&quot;  Author(s):  Gregory     Hance.&nbsp;  PARSING USER INPUT     *************************************************     char *getString_CVIP(void)     *************************************************&nbsp;     Returns: pointer to string of input text LINELENGTH  charac-     ters long     Description: obtain a string of characters from stdin up  to     the first newline character. If more than LINELENGTH charac-     ters are read the rest of the input is dicarded  up  to  and     including the newline char.     Diagnostics: returns NULL pointer w/ appropriate error  mes-     sage  upon  (1) memory allocation failure, (2) error reading     from standard input.     Author(s): Gregory Hance.&nbsp;     *************************************************     long getInt_CVIP(int base, long low_limit, long up_limit)     *************************************************&nbsp;     &lt;base&gt; - base/radix of number (2 to 36 inclusive)     &lt;low_limit&gt; - lower limit of acceptable input     &lt;up_limit&gt; - upper limit of acceptable input&nbsp;     Returns: an integer value Description: obtain value of  type     int   from   standard   input   within   a  specified  range     &lt;low_limit&gt;...&lt;up_limit&gt;.  This function uses the C  library     function--  strtol(..)   and  expects  the number to consist     of... (1) an optional plus or minus sign. (2) a sequence  of     decimal  digits which may be preceeded by 0x or 0X for hexa-     decimal values.  Diagnostics: prompts user for another value     when the value entered is... (1) - a candidate for overflow,     (2) bogus, (4) not within the specified range &lt;low_limit&gt;...     &lt;up_limit&gt;.  Returns  with  value  of 0 w/ appropriate error     message when a call is made to get_int(...)  and &lt;low_limit&gt;     &lt;  &lt;up_limit&gt;  or  base is not between 2 and 36.  Author(s):     Gregory Hance.&nbsp;     *************************************************     unsigned long getUInt_CVIP(int base, unsigned long low_limit, unsigned long up_limit)     *************************************************&nbsp;     &lt;base&gt; - base/radix of number (2 to 36 inclusive)     &lt;low_limit&gt; - lower limit of acceptable input     &lt;up_limit&gt; - upper limit of acceptable input&nbsp;     Returns: unsigned integer value Description: obtain value of     type  unsigned  int  from  standard input within a specified     range &lt;low_limit&gt;...&lt;up_limit&gt;.  This function  uses  the  C     library  function--  strtoul(..)   and expects the number to     consist of... (1) an optional plus  or  minus  sign.  (2)  a     sequence  of  decimal digits which may be preceeded by 0x or     0X for hexadecimal values.  Diagnostics:  prompts  user  for     another value when the value entered is... (1) - a candidate     for overflow, (2) bogus, (4) not within the specified  range     &lt;low_limit&gt;...   &lt;up_limit&gt;.  Returns  with  value  of  0 w/     appropriate  error  message  when  a   call   is   made   to     get_uint(...)   and  &lt;low_limit&gt; &lt; &lt;UP_LIMIT&gt; &lt;low_limit&gt; - lower limit of acceptable input     &lt;up_limit&gt; - upper limit of acceptable input&nbsp;     Returns: double precison floating point  value  Description:     obtain  value  of  type  double from standard input within a     specified  range  &lt;low_limit&gt;...&lt;up_limit&gt;.   This  function     uses  the  C library function -- strtod(..)  and expects the     number to consist of... (1) an optional plus or minus  sign.     (2)  a sequence of decimal digits possibly containing a sin-     gle decimal point, and (3) an optional exponent  part,  con-     sisting  of  the  letter  e  or  E.  an optional sign, and a     sequence of decimal digits.  Diagnostics: prompts  user  for     another value when the value entered is... (1) - a candidate     for overflow, (2) a candidate for overflow, (3)  bogus,  (4)     not  within  the  specified  range &lt;low_limit&gt;...&lt;up_limit&gt;.     Returns with value of 0 w/ appropriate error message when  a     call is made to get_float(...) and &lt;low_limit&gt; &lt; &lt;UP_LIMIT&gt;. &lt;depth&gt; - depth of matrix     &lt;rows&gt; - number of rows in matrix     &lt;cols&gt; - number of columns in matrix     &lt;size&gt; - size of each matrix element (e.g. sizeof(float))&nbsp;     Returns: triple pointer to a new instance  of  an  array  of     matrices.    Description:   allocate  an  array  of  &lt;depth&gt;     matrices each with &lt;rows&gt; rows and &lt;cols&gt; cols with an  ele-     ment  size  of  &lt;size&gt;.  NOTE: use freeMatrix3D_CVIP(...) to     free  the  matrix  Diagnostics:  returns  NULL  pointer   w/     corresponding  error message upon memory allocation failure.     Author(s): Gregory Hance.&nbsp;     *************************************************     void *allocMatrix_CVIP(unsigned int rows, unsigned int cols, size_t size)     *************************************************&nbsp;     &lt;rows&gt; - number of rows in matrix     &lt;cols&gt; - number of columns in matrix     &lt;size&gt; - size of each matrix element (e.g. sizeof(float))&nbsp;     Returns: double pointer to  a  new  instance  of  a  matrix.     Description:  allocate  an  array  of &lt;rows&gt; rows and &lt;cols&gt;     cols  with  an  element   size   of   &lt;size&gt;.    NOTE:   use     freeMatrix_CVIP(...)   to  free  the  matrix.   Diagnostics:     returns NULL pointer w/  corresponding  error  message  upon     memory allocation failure.  Author(s): Gregory Hance.&nbsp;     *************************************************     void freeMatrix_CVIP(void *matP)     *************************************************&nbsp;     &lt;matP&gt; - pointer to matrix allocated w/ matalloc     &lt;number_of_planes&gt; - depth of matrix (number of data bands)&nbsp;     Description: free the memory associated with a matrix  allo-     cated by allocMatrix_CVIP.  Author(s): Gregory Hance.&nbsp;     *************************************************     void freeMatrix3D_CVIP(void *matP)     *************************************************&nbsp;     &lt;matP&gt; - pointer to matrix allocated w/ matalloc     &lt;number_of_planes&gt; - depth of matrix (number of data bands)&nbsp;     Description: free the memory associated with a matrix  allo-     cated by allocMatrix3D_CVIP Author(s): Gregory Hance&nbsp;     *************************************************      FILE * openRead_CVIP( const char *name)     *************************************************&nbsp;     &lt;name&gt; - file name&nbsp;     Description: opens a file  for  reading  Author(s):  Gregory     Hance.&nbsp;     *************************************************      FILE * openWrite_CVIP( const char *name, CVIP_BOOLEAN nice)     *************************************************&nbsp;     &lt;name&gt; - file name     &lt;nice&gt; - priority level of the command; if non-zero, checks     for existing file of same name&nbsp;     Description: writes a file to disk, prompting for  overwrite     permission.  Author(s): Gregory Hance.&nbsp;     *************************************************      void * close_CVIP(FILE* f)     *************************************************&nbsp;     &lt;f&gt; - file name&nbsp;     Description: closes a file Author(s): Gregory Hance.&nbsp;BUGS     none as of yet&nbsp;SEE ALSO     CVIPtools&nbsp;AUTHOR     Copyright (C) 1992, 1993, 2004 SIUE - by Gregory Hance  and  Scott     Umbaugh.&nbsp;\n\r\n\r&nbsp;","IO","scr\\CVIPlibraries/IO.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  1  2004-06-04T02:24:00Z  2004-06-09T16:14:00Z  1  715  4079  SIUE  33  9  4785  10.3501                    MicrosoftInternetExplorer4 NAME&nbsp;&nbsp;&nbsp;&nbsp; Mapping - CVIPtools toolkit library containing utilities&nbsp; for&nbsp;&nbsp;&nbsp;&nbsp; mapping data and manipulating data sets&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPmap.h&gt;&nbsp;FUNCTIONS&nbsp;&nbsp;&nbsp;&nbsp; Mapping includes the following functions:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condRemap_Image&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;linearTrans_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logMap_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remap_Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trun_Image&nbsp;NAME&nbsp;&nbsp;&nbsp;&nbsp; ===================================================================&nbsp;&nbsp;&nbsp;&nbsp; Image *condRemap_Image(const Image *imageP, CVIP_TYPE dtype,&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max)&nbsp;&nbsp;&nbsp;&nbsp; ===================================================================&nbsp;DESCRIPTION&nbsp;&nbsp;&nbsp;&nbsp; &lt;imageP&gt; - pointer to Image structure &lt;dtype&gt; - type of&nbsp; the&nbsp;&nbsp;&nbsp;&nbsp; data&nbsp; to&nbsp; be&nbsp; mapped to (e.g. CVIP_BYTE).&nbsp; must be either as&nbsp;&nbsp;&nbsp;&nbsp; precise or less precise than that of the input image.&nbsp; &lt;min&gt;&nbsp;&nbsp;&nbsp;&nbsp; -&nbsp; minimum value in range (e.g. 0 ) &lt;max&gt; - maximum value in&nbsp;&nbsp;&nbsp;&nbsp; range (e.g. 255 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to a new instance&nbsp; of&nbsp; the&nbsp; Image&nbsp; &lt;imageP&gt;&nbsp;&nbsp;&nbsp;&nbsp; that&nbsp;&nbsp; has&nbsp; been&nbsp; mapped&nbsp; into&nbsp; the&nbsp; range&nbsp; [&lt;min&gt;...&lt;max&gt;].&nbsp;&nbsp;&nbsp;&nbsp; Description: Called if a non-byte image&nbsp; is&nbsp; passed&nbsp; to&nbsp; the&nbsp;&nbsp;&nbsp;&nbsp; image viewer. Performs conditional remapping procedure: data&nbsp;&nbsp;&nbsp;&nbsp; in range 0-255 is not remapped; data more than 0.499 outside&nbsp;&nbsp;&nbsp;&nbsp; specified range is completely remapped.&nbsp; Author(s): Kun Luo,&nbsp;&nbsp;&nbsp;&nbsp; Arve Kjoelen.&nbsp;NAME&nbsp;&nbsp;&nbsp;&nbsp; ===================================================================&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; linearTrans_Image(float&nbsp;&nbsp;&nbsp; **cvecP,&nbsp;&nbsp; unsigned&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; no_of_vecs,&nbsp; unsigned&nbsp; int&nbsp;&nbsp; vdim,&nbsp;&nbsp; double&nbsp;&nbsp; **transmatrix)&nbsp;&nbsp;&nbsp;&nbsp; ===================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;cvecP&gt; - pointer to an array of band vectors &lt;no_of_vecs&gt; -&nbsp;&nbsp;&nbsp;&nbsp; number&nbsp; of vectors &lt;vdim&gt; - dimension of each vector (number&nbsp;&nbsp;&nbsp;&nbsp; of pixels) &lt;transmatrix&gt; - transformation matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: linearly&nbsp; transforms&nbsp; a&nbsp; set&nbsp; of&nbsp; band&nbsp; vectors&nbsp;&nbsp;&nbsp;&nbsp; &lt;cvecP&gt;&nbsp; through&nbsp; a transformation matrix &lt;transmatrix&gt;. The&nbsp;&nbsp;&nbsp;&nbsp; transformation&nbsp; matrix&nbsp; must&nbsp; be&nbsp;&nbsp; have&nbsp;&nbsp; a&nbsp;&nbsp; dimension&nbsp;&nbsp; of&nbsp;&nbsp;&nbsp;&nbsp; &lt;no_of_vecs&gt; by &lt;no_of_vecs&gt;.&nbsp; Author(s): Gregory Hance.&nbsp;NAME&nbsp;&nbsp;&nbsp;&nbsp; ===================================================================&nbsp;&nbsp;&nbsp;&nbsp; Image *logMap_Image(image *image, int band)&nbsp;&nbsp;&nbsp;&nbsp; ===================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;image&gt; - Pointer to Image structure.&nbsp;&nbsp;&nbsp;&nbsp; &lt;band&gt; - the band to do logarithmic mapping;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1=all bands, 0=1st band, 1=2nd band, etc.&nbsp;DESCRIPTION&nbsp;&nbsp;&nbsp;&nbsp; This function remaps a transformed image&nbsp; using&nbsp; logarithmic&nbsp;&nbsp;&nbsp;&nbsp; mapping.&nbsp;&nbsp;&nbsp; The&nbsp;&nbsp; resulting&nbsp;&nbsp; spectra&nbsp; Image&nbsp;&nbsp; structure&nbsp; is&nbsp;&nbsp;&nbsp;&nbsp; returned. The &quot;band&quot; specifies on which&nbsp; band&nbsp; to&nbsp; do&nbsp; loga-&nbsp;&nbsp;&nbsp;&nbsp; rithmic mapping. If band == -1, or band &gt; [(number of bands)&nbsp;&nbsp;&nbsp;&nbsp; - 1] all bands will be remapped;&nbsp; otherwise&nbsp; only&nbsp; one&nbsp; band&nbsp;&nbsp;&nbsp;&nbsp; will&nbsp; be remapped and the return Image is a grayscale image.&nbsp;&nbsp;&nbsp;&nbsp; For example, with a color, three-band, RGB image: 0 = Red, 1&nbsp;&nbsp;&nbsp;&nbsp; = Green, 2 = Blue.&nbsp; Author(s): Simon Lowh, Yansheng Wei&nbsp;NAME&nbsp;&nbsp;&nbsp;&nbsp; ===================================================================&nbsp;&nbsp;&nbsp;&nbsp; Image&nbsp; *remap_Image(const&nbsp; Image&nbsp; *imageP,&nbsp; CVIP_TYPE dtype,&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dmin,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dmax)&nbsp;&nbsp;&nbsp;&nbsp; ===================================================================&nbsp;DESCRIPTION&nbsp;&nbsp;&nbsp;&nbsp; &lt;imageP&gt; - pointer to Image structure &lt;dtype&gt; - type of&nbsp; the&nbsp;&nbsp;&nbsp;&nbsp; data&nbsp; to&nbsp; be&nbsp; mapped to (e.g. CVIP_BYTE).&nbsp; must be either as&nbsp;&nbsp;&nbsp;&nbsp; precise or less&nbsp; precise&nbsp; than&nbsp; that&nbsp; of&nbsp; the&nbsp; input&nbsp; image.&nbsp;&nbsp;&nbsp;&nbsp; &lt;dmin&gt;&nbsp; -&nbsp; minimum value in range (e.g. 0 ) &lt;dmax&gt; - maximum&nbsp;&nbsp;&nbsp;&nbsp; value in range (e.g. 255 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to a new instance&nbsp; of&nbsp; the&nbsp; Image&nbsp; &lt;imageP&gt;&nbsp;&nbsp;&nbsp;&nbsp; that&nbsp; has&nbsp; been&nbsp; mapped&nbsp; into&nbsp; the&nbsp; range [&lt;dmin&gt;...&lt;dmax&gt;].&nbsp;&nbsp;&nbsp;&nbsp; Description: performs remapping procedure in which the rela-&nbsp;&nbsp;&nbsp;&nbsp; tive&nbsp; size of each data band is maintained.&nbsp; Author(s): Gre-&nbsp;&nbsp;&nbsp;&nbsp; gory Hance.&nbsp;NAME&nbsp;&nbsp;&nbsp;&nbsp; ===================================================================&nbsp;&nbsp;&nbsp;&nbsp; void trun_Image(const Image *imageP, type dtype, long dmin, long dmax)&nbsp;&nbsp;&nbsp;&nbsp; ===================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;imageP&gt; - Pointer to Image structure.&nbsp;&nbsp;&nbsp;&nbsp; &lt;dtype&gt; - type of the data to be mapped to (e.g. CVIP_BYTE). Must be either&nbsp;&nbsp;&nbsp;&nbsp; as precise or less precise.&nbsp;&nbsp;&nbsp;&nbsp; &lt;dmin&gt; - minimum value in range (e.g. 0 )&nbsp;&nbsp;&nbsp;&nbsp; &lt;dmax&gt; - maximum value in range (e.g. 255 )&nbsp;DESCRIPTION&nbsp;&nbsp;&nbsp;&nbsp; This function remaps an image, maintaining the relative size&nbsp;&nbsp;&nbsp;&nbsp; of each data band.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\Mapping&nbsp;&nbsp;PATH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $CVIPtoolsHOME\\CVIPlab\\lib&nbsp;BUGS&nbsp;&nbsp;&nbsp;&nbsp; none known&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; CVIPtools library quick reference guide&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1992, 1993, 2004 SIUE - by Gregory Hance&nbsp; and&nbsp; Scott&nbsp;&nbsp;&nbsp;&nbsp; Umbaugh.&nbsp;\n\r\n\r&nbsp;","Mapping","scr\\CVIPlibraries/Mapping.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  6  6  2004-06-04T02:25:00Z  2004-07-12T22:46:00Z  1  4170  23770  SIUE  198  55  27885  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME&nbsp;&nbsp;&nbsp;&nbsp; Matrix -&nbsp; CVIPtools&nbsp; toolkit&nbsp;&nbsp; library&nbsp;&nbsp; for&nbsp;&nbsp; numerical&nbsp;&nbsp;&nbsp;&nbsp; analysis/linear algebra and matrix manipulation&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPmatrix.h&gt;&nbsp;DESCRIPTION&nbsp; TYPES AND CONSTANTS&nbsp;&nbsp;&nbsp;&nbsp; typedef enum {CVIP_BYTE, CVIP_SHORT, CVIP_INTEGER, CVIP_FLOAT, CVIP_DOUBLE} CVIP_TYPE;&nbsp;&nbsp;&nbsp;&nbsp; typedef enum {REAL, COMPLEX} FORMAT;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef struct {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CVIP_TYPE data_type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORMAT data_format;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int rows;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int cols;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;void **rptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void **iptr;&nbsp;&nbsp;&nbsp;&nbsp; } Matrix;&nbsp;FUNCTIONS&nbsp;&nbsp;&nbsp;&nbsp; The following functions are included in this man page:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CANG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getImagVal_Matrix&nbsp;&nbsp;&nbsp;&nbsp; CASSIGN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getNoOfCols_Matrix&nbsp;&nbsp;&nbsp;&nbsp; CMAG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getNoOfRows_Matrix&nbsp;&nbsp;&nbsp;&nbsp; CMUL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getRealData_Matrix&nbsp;&nbsp;&nbsp;&nbsp; MAGSQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getRealRow_Matrix&nbsp;&nbsp;&nbsp;&nbsp; POL2REC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getRealVal_Matrix&nbsp;&nbsp;&nbsp;&nbsp; REC2POL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getRow_Matrix&nbsp;&nbsp;&nbsp;&nbsp; add_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getVal_Matrix&nbsp;&nbsp;&nbsp;&nbsp; copy_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invert_Matrix&nbsp;&nbsp;&nbsp;&nbsp; covariance_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makeComplex_Matrix&nbsp;&nbsp;&nbsp;&nbsp; crop_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makeReal_Matrix&nbsp;&nbsp;&nbsp;&nbsp; delete_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mult_Matrix&nbsp;&nbsp;&nbsp;&nbsp; det_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; multPWise_Matrix&nbsp;&nbsp;&nbsp;&nbsp; eigenSystem_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_Matrix&nbsp;&nbsp;&nbsp;&nbsp; fastCopy_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_Matrix&nbsp;&nbsp;&nbsp;&nbsp; getDataFormat_Matrix&nbsp;&nbsp;&nbsp;&nbsp; rect2pol_Matrix&nbsp;&nbsp;&nbsp;&nbsp; getData_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scale_Matrix&nbsp;&nbsp;&nbsp;&nbsp; getDataType_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub_Matrix&nbsp;&nbsp;&nbsp;&nbsp; getImagData_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; transpose_Matrix&nbsp;&nbsp;&nbsp;&nbsp; getImagRow_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;and_Matrix&nbsp;&nbsp;&nbsp;&nbsp; clone_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; duplicate_Matrix&nbsp;&nbsp;&nbsp;&nbsp; setRealVal_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setVal_Matrix&nbsp;&nbsp;&nbsp;&nbsp; setImagVal_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; conj_Matrix&nbsp;&nbsp;&nbsp;&nbsp; mag_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; square_mag_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqrt_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbrt_Matrix &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;divide_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clone_Matrix&nbsp;&nbsp;&nbsp;&nbsp; read_Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_Matrix&nbsp;&nbsp; MEMORY MANAGEMENT&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *new_Matrix(unsigned int rows, unsigned int cols, CVIP_TYPE data_type,&nbsp;&nbsp;&nbsp;&nbsp; FORMAT data_format)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;rows&gt; - number of rows for new matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;cols&gt; - nuber of cols for new matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;data_type&gt; - one of CVIP_BYTE, CVIP_SHORT, CVIP_INTEGER, CVIP_FLOAT or CVIP_DOUBLE&nbsp; &nbsp;&nbsp;&nbsp;&lt;data_format&gt; - one of REAL or IMAGINARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: a pointer to the newly allocated&nbsp; Matrix&nbsp; structure&nbsp;&nbsp;&nbsp;&nbsp; Description: Matrix class constructor. allocates a structure&nbsp;&nbsp;&nbsp;&nbsp; of type Matrix with &lt;rows&gt; x &lt;cols&gt; data&nbsp; elements&nbsp; of&nbsp; type&nbsp;&nbsp;&nbsp;&nbsp; &lt;data_type&gt;.&nbsp;&nbsp; The&nbsp; Matrix&nbsp; structure&nbsp; contains two members,&nbsp;&nbsp;&nbsp;&nbsp; **rptr and **iptr which are used to reference the&nbsp; real&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; imaginary&nbsp; data&nbsp; respectively. The matrix data is contiguous&nbsp;&nbsp;&nbsp;&nbsp; in the sense that a reference to the address&nbsp; of&nbsp; the&nbsp; first&nbsp;&nbsp;&nbsp;&nbsp; element&nbsp; may be used to dereference all others. Diagnostics:&nbsp;&nbsp;&nbsp;&nbsp; returns NULL pointer w/&nbsp; corresponding&nbsp; error&nbsp; message&nbsp; upon&nbsp;&nbsp;&nbsp;&nbsp; memory allocation failure.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp; &nbsp;void delete_Matrix(Matrix *A)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to a Matrix structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Matrix class Destructor. Frees all memory asso-&nbsp;&nbsp;&nbsp;&nbsp; ciated with a Matrix structure.&nbsp; NOTE: Matrix structure must&nbsp;&nbsp;&nbsp;&nbsp; be allocated be new_Matrix Diagnostics: returns&nbsp; with&nbsp; error&nbsp;&nbsp;&nbsp;&nbsp; message when invalid Matrix structure is passed.&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp; Gregory Hance.&nbsp;&nbsp; MATRIX MANIPULATION&nbsp;&nbsp;&nbsp;&nbsp; =========================================================== &nbsp;&nbsp;&nbsp;&nbsp;unsigned getNoOfRows_Matrix(Matrix *matrix)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns number of&nbsp; rows&nbsp; in&nbsp; a&nbsp; Matrix&nbsp; object.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; unsigned getNoOfCols_Matrix(Matrix *matrix)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns number of columns in a&nbsp; Matrix&nbsp; object.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; CVIP_TYPE getDataType_Matrix(Matrix *matrix)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; returns&nbsp; data&nbsp; type&nbsp; of&nbsp; Matrix&nbsp; object&nbsp; (e.g.&nbsp;&nbsp;&nbsp;&nbsp; CVIP_BYTE,CVIP_FLOAT,etc.).&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp; &nbsp;&nbsp;FORMAT getDataFormat_Matrix(Matrix *matrix)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns data format of a&nbsp; Matrix&nbsp; object&nbsp; (i.e.&nbsp;&nbsp;&nbsp;&nbsp; REAL or COMPLEX).&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; void *getRealData_Matrix(Matrix *matrix)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns reference to the real data of a&nbsp; Matrix&nbsp;&nbsp;&nbsp;&nbsp; object (mapped into rows).&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; void *getData_Matrix(Matrix *matrix)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: same as &quot;getRealData_Matrix&quot;.&nbsp; Author(s):&nbsp; Gre-&nbsp;&nbsp;&nbsp;&nbsp; gory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; void *getRealRow_Matrix(Matrix *matrix, unsigned row)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp; &lt;row&gt; - row number (0 ... rows-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns a reference to a row of real data&nbsp; from&nbsp;&nbsp;&nbsp;&nbsp; a Matrix object.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; void *getRow_Matrix(Matrix *matrix, unsigned row)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp; &lt;row&gt; - row number (0 ... rows-1)&nbsp;&nbsp;&nbsp;&nbsp; Description: same as &quot;getRealRow_Matrix&quot;.&nbsp;&nbsp; Author(s):&nbsp; Gre-&nbsp;&nbsp;&nbsp;&nbsp; gory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; void *getImagData_Matrix(matrix)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns a reference to the imaginary data of&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; Matrix object (mapped into rows).&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; void *getImagRow_Matrix(matrix,row)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object.&nbsp;&nbsp;&nbsp;&nbsp; &lt;row&gt; - row number (0 ... rows-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns a reference to a row of imaginary&nbsp; data&nbsp;&nbsp;&nbsp;&nbsp; from a Matrix object.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; type getRealVal_Matrix(Matrix *matrix, type, unsigned x, unsigned y) &nbsp;&nbsp;&nbsp;&nbsp;===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; - valid &quot;C&quot; data type (i.e.one of byte, short, int, float or double)&nbsp;&nbsp;&nbsp;&nbsp; &lt;x&gt; - column offset&nbsp;&nbsp;&nbsp;&nbsp; &lt;y&gt; - row offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns a &quot;real&quot; element from a Matrix&nbsp; object.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; getVal_Matrix(Matrix *matrix, type, unsigned x, unsigned y)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; - valid &quot;C&quot;data type (i.e.one of byte, short, int, float or double)&nbsp;&nbsp;&nbsp;&nbsp; &lt;x&gt; - column offset&nbsp;&nbsp;&nbsp;&nbsp; &lt;y&gt; - row offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: same as &quot;getRealVal_Matrix&quot;.&nbsp;&nbsp; Author(s):&nbsp; Gre-&nbsp;&nbsp;&nbsp;&nbsp; gory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; getImagVal_Matrix(Matrix *matrix, type, unsigned x, unsigned y)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; - valid &quot;C&quot; data type (i.e. one of byte, short, int, float or double&nbsp;&nbsp;&nbsp;&nbsp; &lt;x&gt; - column offset&nbsp;&nbsp;&nbsp;&nbsp; &lt;y&gt; - row offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns an &quot;imaginary&quot; element&nbsp; from&nbsp; a&nbsp; Matrix&nbsp;&nbsp;&nbsp;&nbsp; object.&nbsp; Author(s): Gregory Hance.&nbsp; &nbsp;BINARY ARITHMETIC OPERATORS&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *add_Matrix(const Matrix *A,const Matrix *B);&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to first matrix&nbsp;&nbsp; &nbsp;&nbsp;&lt;B&gt; -pointer to second matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to&nbsp; resultant&nbsp; matrix&nbsp; containing,&nbsp; &lt;A&gt;+&lt;B&gt;&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; adds&nbsp; the contents of &lt;A&gt; to that of &lt;B&gt;. Uses&nbsp;&nbsp;&nbsp;&nbsp; the PWISE_MAT macro to do&nbsp; all&nbsp; 25&nbsp; combinations&nbsp; of&nbsp; matrix&nbsp;&nbsp;&nbsp;&nbsp; types.&nbsp; Promotes&nbsp; to&nbsp; most precise type of &lt;A&gt; and &lt;B&gt;. Sup-&nbsp;&nbsp;&nbsp;&nbsp; ports complex matrices.&nbsp; Diagnostics: returns&nbsp; NULL&nbsp; pointer&nbsp;&nbsp;&nbsp;&nbsp; w/ error message when matrix sizes do not agree.&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp; Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *sub_Matrix(const Matrix *A,const Matrix *B);&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to first matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;B&gt; -pointer to second matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to&nbsp; resultant&nbsp; matrix&nbsp; containing,&nbsp; &lt;A&gt;-&lt;B&gt;&nbsp;&nbsp;&nbsp;&nbsp; Description: subtracts the contents of &lt;B&gt; from that of &lt;A&gt;.&nbsp;&nbsp;&nbsp;&nbsp; Uses the PWISE_MAT macro to do all 25 combinations of matrix&nbsp;&nbsp;&nbsp;&nbsp; types.&nbsp; Promotes&nbsp; to&nbsp; most precise type of &lt;A&gt; and &lt;B&gt;. Sup-&nbsp;&nbsp;&nbsp;&nbsp; ports complex matrices Diagnostics: returns NULL pointer&nbsp; w/&nbsp;&nbsp;&nbsp;&nbsp; error&nbsp; message&nbsp; when&nbsp; matrix sizes do not agree.&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp; Gregory Hance.&nbsp;&nbsp; MATRIX MULTIPLICATION&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *multPWise_Matrix(const Matrix *A, const Matrix *B)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to first matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;B&gt; -pointer to second matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to&nbsp; resultant&nbsp; matrix&nbsp; containing,&nbsp; &lt;A&gt;*&lt;B&gt;&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; multiplies&nbsp; the&nbsp; contents&nbsp; of &lt;B&gt; from that of&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt;.&nbsp; Uses the PWISE_MULT macro to do all 25 combinations of&nbsp;&nbsp;&nbsp;&nbsp; matrix&nbsp; types. Promotes to most precise type of &lt;A&gt; and &lt;B&gt;.&nbsp;&nbsp;&nbsp;&nbsp; Supports complex matrices Diagnostics: returns NULL&nbsp; pointer&nbsp;&nbsp;&nbsp;&nbsp; w/ error message when matrix sizes do not agree.&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp; Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *mult_Matrix(const Matrix *A,const Matrix *B)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to first Matrix structure&nbsp;&nbsp;&nbsp;&nbsp; &lt;B&gt; - pointer to second Matrix structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to Matrix structure containing the&nbsp; result-&nbsp;&nbsp;&nbsp;&nbsp; ing&nbsp; vector&nbsp; multiplication,&nbsp; &lt;A&gt;x&lt;B&gt;&nbsp; Description:&nbsp; peforms&nbsp;&nbsp;&nbsp;&nbsp; Matrix cross product of &lt;A&gt; and&nbsp; &lt;B&gt;.&nbsp;&nbsp; Promotes &nbsp;result&nbsp; to&nbsp;&nbsp;&nbsp;&nbsp; most precise type of &lt;A&gt; and &lt;B&gt;.&nbsp; Uses MULT_MAT macro to do&nbsp;&nbsp;&nbsp;&nbsp; all 25 type combinations of matrices.&nbsp; Diagnostics:&nbsp; returns&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp; pointer&nbsp; w/&nbsp; error&nbsp; message&nbsp; when...&nbsp;&nbsp; of&nbsp; rows in &lt;B&gt;&nbsp;&nbsp;&nbsp;&nbsp; ...problems w/ Matrix structure.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *sqrt_Matrix(Matrix *a)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;a&gt; - pointer to Matrix structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns:&nbsp; pointer&nbsp; to&nbsp; Matrix&nbsp; structure&nbsp; containing&nbsp; matrix&nbsp;&nbsp;&nbsp;&nbsp; square root.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Computes the square root of each element of the&nbsp;&nbsp;&nbsp;&nbsp; passed matrix, works on both REAL and COMPLEX matrices.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: Frees up old matrix.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author: Arve Kjoelen&nbsp;&nbsp; GENERAL MATRIX UTILTIES&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; void print_Matrix(const Matrix *A)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to venerable Matrix structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Prints out the contents of a&nbsp; matrix&nbsp; structure&nbsp;&nbsp;&nbsp;&nbsp; in row - column format.&nbsp; Diagnostics: Row 1: &lt;col.1&gt; &lt;col.2&gt;&nbsp;&nbsp;&nbsp;&nbsp; ...&nbsp; &lt;col.N&gt;&nbsp; ...&nbsp; Row&nbsp; N:&nbsp; &lt;col.1&gt;&nbsp; &lt;col.3&gt;&nbsp; ...&nbsp;&nbsp; &lt;col.N&gt;.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ============================================================&nbsp;&nbsp;&nbsp;&nbsp; CVIP_BOOLEAN conj_Matrix(Matrix *A)&nbsp;&nbsp;&nbsp;&nbsp; ============================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to Matrix structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: 1 upons success, 0 upon failure (A is real or NULL)&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; Calculates&nbsp; the&nbsp; complex conjugate of a Matrix&nbsp;&nbsp;&nbsp;&nbsp; structure IN PLACE.&nbsp; Diagnostics: If it is desired&nbsp; to&nbsp; keep&nbsp;&nbsp;&nbsp;&nbsp; the&nbsp; original,&nbsp; call&nbsp; duplicate_Matrix&nbsp; first.&nbsp; Author: Arve&nbsp;&nbsp;&nbsp;&nbsp; Kjoelen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; CVIP_BOOLEAN copy_Matrix(const Matrix *A, Matrix *B, CVIP_BOOLEAN force)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to source matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;B&gt; - pointer to destination matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;force&gt; - force operation even if matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;B&gt; is of a less precise type than &lt;A&gt;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: 1 upon success, 0 upon&nbsp; failure&nbsp; Description:&nbsp; Copy&nbsp;&nbsp;&nbsp;&nbsp; the&nbsp; contents&nbsp; of&nbsp; &lt;A&gt;&nbsp; into &lt;B&gt;. Uses the macro MAT_COPY to&nbsp;&nbsp;&nbsp;&nbsp; support all 25 combinations of matrix&nbsp; types.&nbsp;&nbsp; Diagnostics:&nbsp;&nbsp;&nbsp;&nbsp; returns 1 upon success and 0 upon failure; matrix sizes must&nbsp;&nbsp;&nbsp;&nbsp; agree and if &lt;force&gt; is CVIP_NO then&nbsp; copy_Matrix&nbsp; will&nbsp; not&nbsp;&nbsp;&nbsp;&nbsp; perform&nbsp;&nbsp; the&nbsp;&nbsp; copy&nbsp; if&nbsp; &lt;B&gt;&nbsp; is&nbsp; less&nbsp; precise&nbsp; than&nbsp; &lt;A&gt;.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; CVIP_BOOLEAN fastCopy_Matrix(const Matrix *A, Matrix *B)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to source matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;B&gt; - pointer to destination matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: 1 upon success, 0 upon&nbsp; failure&nbsp; Description:&nbsp; Copy&nbsp;&nbsp;&nbsp;&nbsp; the&nbsp; contents&nbsp; of&nbsp; &lt;A&gt;&nbsp; into&nbsp; &lt;B&gt;.&nbsp; Uses&nbsp; a faster method of&nbsp;&nbsp;&nbsp;&nbsp; transfering data than in copy_Matrix&nbsp; for&nbsp; matrices&nbsp; of&nbsp; the&nbsp;&nbsp;&nbsp;&nbsp; same&nbsp; type.&nbsp;&nbsp; Diagnostics: returns 1 upon success and 0 upon&nbsp;&nbsp;&nbsp;&nbsp; failure; matrix sizes must agree&nbsp; and&nbsp; fastCopy_Matrix&nbsp; will&nbsp;&nbsp;&nbsp;&nbsp; not&nbsp; perform&nbsp; the&nbsp; copy&nbsp; if&nbsp; &lt;B&gt;&nbsp; is&nbsp; less precise than &lt;A&gt;.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix *duplicate_Matrix(const Matrix *A, FORMAT df)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to source matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;df&gt; - data format of new matrix (REAL or IMAGINARY)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to new instance of matrix &lt;A&gt;&nbsp; Description:&nbsp;&nbsp;&nbsp;&nbsp; Creates&nbsp; an exact duplicate of the original matrix &lt;A&gt;, with&nbsp;&nbsp;&nbsp;&nbsp; the exception that the format can be altered. If the&nbsp; format&nbsp;&nbsp;&nbsp;&nbsp; is specified to be less precise than that of A then the ima-&nbsp;&nbsp;&nbsp;&nbsp; ginary data is truncated.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *scale_Matrix(const Matrix *a, double s)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; &lt;a&gt; - pointer to Matrix structure&nbsp;&nbsp;&nbsp;&nbsp; &lt;s&gt; - coefficient to multiply by each element&nbsp;&nbsp;&nbsp;&nbsp; of matrix &lt;a&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns:&nbsp; pointer&nbsp; to&nbsp; Matrix&nbsp; structure&nbsp; containing&nbsp; scaled&nbsp;&nbsp;&nbsp;&nbsp; matrix&nbsp; (type float or double) Description: Scales each ele-&nbsp;&nbsp;&nbsp;&nbsp; ment of the matrix &lt;a&gt; by some&nbsp; coefficient&nbsp; &lt;s&gt;.&nbsp; All&nbsp; data&nbsp;&nbsp;&nbsp;&nbsp; types less precise than CVIP_FLOAT or promoted. Diagnostics:&nbsp;&nbsp;&nbsp;&nbsp; prints message of type of promotion being made.&nbsp;&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp; Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *crop_Matrix(const Matrix *a, unsigned int, unsigned int, unsigned int, unsigned int)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;a&gt; - pointer to source matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;row_offset&gt; - offset of row from 0&nbsp;&nbsp;&nbsp;&nbsp; &lt;col_offset&gt; - offset of column from 0&nbsp;&nbsp;&nbsp;&nbsp; &lt;rows&gt; - number of rows&nbsp;&nbsp;&nbsp;&nbsp; &lt;cols&gt; - number of columns&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: Returns the new smaller matrix as a&nbsp; pointer&nbsp; to&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; new&nbsp; Matrix&nbsp; structure&nbsp; using&nbsp; the&nbsp; row&nbsp; and col offsets and&nbsp;&nbsp;&nbsp;&nbsp; number of &lt;rows&gt; and &lt;cols&gt; in the result matrix.&nbsp;&nbsp; Descrip-&nbsp;&nbsp;&nbsp;&nbsp; tion:&nbsp; forms&nbsp; a&nbsp; sub-matrix&nbsp; of given size and location from&nbsp;&nbsp;&nbsp;&nbsp; original Diagnostics: returns NULL ptr. w/ error&nbsp; msg.&nbsp; when&nbsp;&nbsp;&nbsp;&nbsp; submatrix&nbsp; size&nbsp; exceeds&nbsp; that of parent matrix.&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp; Gregory Hance.&nbsp;&nbsp; MATRIX ALGEBRA, NUMERICAL ANALYSIS&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; double det_Matrix(const Matrix *A)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to Matrix structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: double value equal to the determinant of the matrix&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; Finds&nbsp; the&nbsp; determinant&nbsp; of&nbsp; the input matrix.&nbsp;&nbsp;&nbsp;&nbsp; Allocates and frees a matrix for&nbsp; the&nbsp; determinant&nbsp; calcula-&nbsp;&nbsp;&nbsp;&nbsp; tion.&nbsp; Exits&nbsp; and&nbsp; prints&nbsp; error&nbsp; message&nbsp; on invalid Matrix&nbsp;&nbsp;&nbsp;&nbsp; structure.&nbsp; Diagnostics: returns 0&nbsp; w/&nbsp; corresponding&nbsp; error&nbsp;&nbsp;&nbsp;&nbsp; message&nbsp; when matrix is not square. Can not handle a complex&nbsp;&nbsp;&nbsp;&nbsp; matrix.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *invert_Matrix(const Matrix *A)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to matrix to be inverted&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to inverted matrix (promoted to&nbsp; type&nbsp; dou-&nbsp;&nbsp;&nbsp;&nbsp; ble)&nbsp; Description:&nbsp; finds&nbsp; the&nbsp; inverse&nbsp; of matrix &lt;A&gt; using&nbsp;&nbsp;&nbsp;&nbsp; Gauss-Jordan elimination with full pivoting (not your&nbsp; usual&nbsp;&nbsp;&nbsp;&nbsp; half&nbsp; pivot&nbsp; I guess... ) ALSO... this routine will find the&nbsp;&nbsp;&nbsp;&nbsp; inverse of&nbsp; a&nbsp; complex&nbsp; matrix!&nbsp; Diagnostics:&nbsp; returns&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp; pointer and issues error message with singular matrices, bad&nbsp;&nbsp;&nbsp;&nbsp; Matrix structures.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *transpose_Matrix(const Matrix *A)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to Matrix structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to new matrix structure of same&nbsp; type&nbsp; con-&nbsp;&nbsp;&nbsp;&nbsp; taining&nbsp; the&nbsp; transposed&nbsp; matrix Description: transposes the&nbsp;&nbsp;&nbsp;&nbsp; matrix &lt;A&gt; by copying to a new matrix. In&nbsp; case&nbsp; you&nbsp; didn\'t&nbsp;&nbsp;&nbsp;&nbsp; now&nbsp;&nbsp; that&nbsp; means&nbsp; interchange&nbsp; the&nbsp; rows&nbsp; w/&nbsp; the&nbsp; columns.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *covariance_Matrix(float **bvecP, unsigned int no_of_bands,&nbsp;&nbsp;&nbsp;&nbsp; unsigned int vdim)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;bvecP&gt; - pointer to an array of band vectors of type float&nbsp;&nbsp;&nbsp;&nbsp; &lt;no_of_bands&gt; - number of data bands&nbsp;&nbsp;&nbsp;&nbsp; &lt;vdim&gt; - vector dimension (no. of pixels)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to covariance matrix&nbsp; Description:&nbsp; returns&nbsp;&nbsp;&nbsp;&nbsp; the covariance matrix of the band vector.&nbsp; The dimensions of&nbsp;&nbsp;&nbsp;&nbsp; the matrix are equal to the number of data bands. (e.g.) for&nbsp;&nbsp;&nbsp;&nbsp; an RGB image with 3 data bands the covariance matrix is...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Crr Cgr Cbr |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Crg Cgg Cbg |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Crb Cgb Cbb |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _| 3x3&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *eigenSystem_Matrix(Matrix *a)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;a&gt; - pointer to MATRIX structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to&nbsp; Matrix&nbsp; structure&nbsp; containing&nbsp; rows&nbsp; of&nbsp;&nbsp;&nbsp;&nbsp; eigenvectors.&nbsp;&nbsp;&nbsp; Description:&nbsp; This&nbsp; function&nbsp; computes&nbsp; the&nbsp;&nbsp;&nbsp;&nbsp; eigenvalues and corresponding eigenvectors of&nbsp; a&nbsp; real&nbsp; sym-&nbsp;&nbsp;&nbsp;&nbsp; metric&nbsp; matrix. The eigen matrix is returned in terms of row&nbsp;&nbsp;&nbsp;&nbsp; vectors.&nbsp; The routine also sorts the eigenvalues in descend-&nbsp;&nbsp;&nbsp;&nbsp; ing order, and rearranges the rows correspondingly.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; En = {E1, E2, E3, ..., En}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | E11 E12 E13 . . E1n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | E21 E22 E23 . . E2n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | E31 E32 E33 . . E3n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . . .&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | En1 En2 En3 . . Enn |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _| nxn&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp; COMPLEX MATRIX UTILITIES&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; void CASSIGN(Matrix *matrix, type, int row, int col, int r, int i)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to Matrix structure&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; - valid C data type for matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;row&gt; - row of matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;col&gt; - column of matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;r&gt; - real component of data&nbsp;&nbsp;&nbsp; &nbsp;&lt;i&gt; - imaginary component of data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: this macro will assign a complex&nbsp; number&nbsp; to&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double CANG(double r, double i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: This macro will compute the phasor angle&nbsp; of&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; complex number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double CMAG(double r, double i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: This macro will compute the magnitude of a com-&nbsp;&nbsp;&nbsp;&nbsp; plex number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double MAGSQ(double r, double i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: macro to compute the&nbsp; magnitude&nbsp; squared&nbsp; of&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; complex number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void CMUL(type, r3, i3, r1, i1, r2, i2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: macro to perform complex multiply and store the&nbsp;&nbsp;&nbsp;&nbsp; result in &lt;r3&gt; and &lt;i3&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void REC2POL(type, m, p, r,i)&nbsp;&nbsp;&nbsp;&nbsp; Description: macro to perform rectangular to&nbsp; polar&nbsp; coordi-&nbsp;&nbsp;&nbsp;&nbsp; nate conversion&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;void POL2REC(type, r, i, m, p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: macro to perform polar to&nbsp; rectangular&nbsp; coordi-&nbsp;&nbsp;&nbsp;&nbsp; nate conversion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; CVIP_BOOLEAN makeComplex_Matrix(Matrix *real_Matrix, CVIP_BOOLEAN verbose)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;real_Matrix&gt; - pointer to real matrix&nbsp;&nbsp;&nbsp;&nbsp; &lt;verbose&gt; - speak to me&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: 1 - upon success, 0&nbsp; -&nbsp; upon&nbsp; failure&nbsp; Description:&nbsp;&nbsp;&nbsp;&nbsp; reallocates&nbsp; twice&nbsp; the amount of memory already assigned to&nbsp;&nbsp;&nbsp;&nbsp; &lt;real_Matrix&gt; to make a complex.&nbsp; The new complex&nbsp; data&nbsp; can&nbsp;&nbsp;&nbsp;&nbsp; be referenced through **iptr of the Matrix structure.&nbsp; real-&nbsp;&nbsp;&nbsp;&nbsp; loc() is used to keep the new data address\' contiguous&nbsp; with&nbsp;&nbsp;&nbsp;&nbsp; that&nbsp; of&nbsp; the real data...&nbsp; rather than allocate a new block&nbsp;&nbsp;&nbsp;&nbsp; of memory.&nbsp; This has potential advantages when peforming the&nbsp;&nbsp;&nbsp;&nbsp; same&nbsp; operation&nbsp; on&nbsp; both data sets (real &amp; imag.)&nbsp; Diagnos-&nbsp;&nbsp;&nbsp;&nbsp; tics: returns a NULL pointer&nbsp; and&nbsp; warning&nbsp; message&nbsp; when...&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; CVIP_BOOLEAN makeReal_Matrix(Matrix *complex_Matrix, CVIP_BOOLEAN verbose)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; complex_Matrix - pointer to matrix structure&nbsp;&nbsp;&nbsp;&nbsp; verbose - should i speak?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: 1 - upon success, 0&nbsp; -&nbsp; upon&nbsp; failure&nbsp; Description:&nbsp;&nbsp;&nbsp;&nbsp; reallocates&nbsp;&nbsp; the&nbsp;&nbsp; amount&nbsp;&nbsp; of&nbsp;&nbsp; memory&nbsp;&nbsp; associated&nbsp;&nbsp; with&nbsp;&nbsp;&nbsp;&nbsp; complex_Matrix to that of a real matrix Diagnostics: returns&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp; pointer&nbsp; and error message when...&nbsp; Author(s): Gregory&nbsp;&nbsp;&nbsp;&nbsp; Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix *rect2pol_Matrix(Matrix *A, int dir)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to Matrix structure&nbsp;&nbsp;&nbsp;&nbsp; &lt;dir&gt; - type of transformation&nbsp;&nbsp;&nbsp;&nbsp; (1) - rectangular to polar&nbsp;&nbsp;&nbsp;&nbsp; (anything else) - polar to rectangular&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to Matrix structure containing the&nbsp; desired&nbsp;&nbsp;&nbsp;&nbsp; transformation&nbsp; (type float or double) Description: Performs&nbsp;&nbsp;&nbsp;&nbsp; transformation from rectangular to polar coordinates or from&nbsp;&nbsp;&nbsp;&nbsp; polar to rectangular coordinates depending upon the value of&nbsp;&nbsp;&nbsp;&nbsp; &lt;dir&gt;.&nbsp; Values less than type CVIP_FLOAT are promoted. If&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; matrix&nbsp; of&nbsp; type double is passed the result will be double.&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: returns with NULL pointer and&nbsp; message&nbsp; when...&nbsp;&nbsp;&nbsp;&nbsp; -&nbsp; matrix&nbsp; is not complex also informs user when a promotion&nbsp;&nbsp;&nbsp;&nbsp; takes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; place.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gregory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hance.&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix&nbsp; *and_Matrix(const&nbsp; Matrix&nbsp; *A,&nbsp; const&nbsp;&nbsp; Matrix&nbsp;&nbsp; *B)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to Matrix structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;B&gt; - pointer to Matrix structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to resultant matrix containing, &lt;A&gt;&amp;&lt;B&gt;&nbsp;&nbsp;&nbsp;&nbsp; Description: ands the contents of &lt;A&gt; to that of&nbsp; &lt;B&gt;.&nbsp; Uses&nbsp;&nbsp;&nbsp;&nbsp; the&nbsp; PWISE_MAT&nbsp; macro&nbsp; to&nbsp; do all 15 combinations of integer&nbsp;&nbsp;&nbsp;&nbsp; matrix types.&nbsp; Promotes to most precise type of &lt;A&gt; and &lt;B&gt;.&nbsp;&nbsp;&nbsp;&nbsp; Supports complex matrices.&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: returns NULL&nbsp; pointer&nbsp; w/&nbsp; error&nbsp; message&nbsp; when&nbsp;&nbsp;&nbsp;&nbsp; matrix sizes do not agree.&nbsp;&nbsp;&nbsp;&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gregory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hance.&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix&nbsp; *clone_Matrix(const&nbsp; Matrix&nbsp; *matP,&nbsp; CVIP_TYPE&nbsp;&nbsp; dt)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matP&gt; - pointer to Matrix structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;dt&gt; - valid C data type for matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: New matrix copy.&nbsp;&nbsp;&nbsp;&nbsp; Description: Uses function new_Matrix to provide quick&nbsp; copy&nbsp;&nbsp;&nbsp;&nbsp; of imput matrix.&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: None.&nbsp;&nbsp;&nbsp;&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gregory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hance.&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; Matrix&nbsp; *duplicate_Matrix(const&nbsp; Matrix&nbsp;&nbsp; *A,&nbsp;&nbsp; FORMAT&nbsp;&nbsp; df)&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;A&gt; - pointer to source matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;df&gt; - data format of new matrix (REAL or IMAGINARY)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to new instance of matrix &lt;A&gt;.&nbsp;&nbsp;&nbsp;&nbsp; Description: Creates an&nbsp; exact&nbsp; duplicate&nbsp; of&nbsp; the&nbsp; original&nbsp;&nbsp;&nbsp;&nbsp; matrix&nbsp; &lt;A&gt;,&nbsp; with&nbsp; the&nbsp; exception&nbsp; that&nbsp; the&nbsp; format can be&nbsp;&nbsp;&nbsp;&nbsp; altered. If the format is specified to be less precise&nbsp; than &nbsp;&nbsp;&nbsp;&nbsp;that of A then the imaginary data is truncated.&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: None.&nbsp;&nbsp;&nbsp;&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gregory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hance.&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt;&nbsp; setRealVal_Matrix(Matrix&nbsp; *matrix,&nbsp; CVIP_TYPE&nbsp; type,&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp; y,&nbsp;&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp;&nbsp;&nbsp; val&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; - valid &quot;C&quot; data type (i.e. one of byte, short, int,&nbsp;&nbsp;&nbsp;&nbsp; float or double)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;x&gt; - column offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;y&gt; - row offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;val&gt; - value to place into matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: inserts &lt;val&gt; as a &quot;real&quot;&nbsp; element&nbsp; at&nbsp; row&nbsp; y,&nbsp;&nbsp;&nbsp;&nbsp; column x&nbsp; of matrix.&nbsp;&nbsp;&nbsp;&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gregory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hance.&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt;&nbsp;&nbsp; setVal_Matrix(Matrix&nbsp;&nbsp; *matrix,&nbsp;&nbsp; CVIP_TYPE&nbsp;&nbsp; type,&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp; y,&nbsp;&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp;&nbsp;&nbsp; val&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; - valid &quot;C&quot; data type (i.e. one of byte, short, int,&nbsp;&nbsp;&nbsp;&nbsp; float or double)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;x&gt; - column offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;y&gt; - row offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;val&gt; - value to place into matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Same as setREalVal_Matrix; inserts &lt;val&gt;&nbsp; as&nbsp; a&nbsp;&nbsp;&nbsp;&nbsp; &quot;real&quot; element at row y, column x&nbsp; of matrix.&nbsp;&nbsp;&nbsp;&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gregory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hance.&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt;&nbsp; setImagVal_Matrix(Matrix&nbsp; *matrix,&nbsp; CVIP_TYPE&nbsp; type,&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp; y,&nbsp;&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp;&nbsp;&nbsp; val&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;&nbsp;&nbsp;&nbsp; ===========================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;matrix&gt; - pointer to a Matrix object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;type&gt; - valid &quot;C&quot; data type (i.e. one of byte, short, int,&nbsp;&nbsp;&nbsp;&nbsp; float or double)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;x&gt; - column offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;y&gt; - row offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;val&gt; - value to place into matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: inserts &lt;val&gt; as an &quot;imaginary&quot; element at&nbsp; row&nbsp;&nbsp;&nbsp;&nbsp; y, column x&nbsp; of matrix.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\MatrixAlgebra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;BUGS&nbsp;&nbsp;&nbsp;&nbsp; none as of yet&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; CVIPmatrix.h, CVIPcomplex.h, m_file.h, m_CovEig.h&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1992, 1993, 2004 SIUE - by Gregory Hance&nbsp; and&nbsp; Scott&nbsp;&nbsp;&nbsp;&nbsp; Umbaugh.&nbsp;\n\r\n\r&nbsp;","Matrix","scr\\CVIPlibraries/Matrix.html","   ACADEMIC COMPUTING  Normal  Mounika  7  3  2004-06-04T02:26:00Z  2009-12-28T18:25:00Z  1  145  827  SIUE  6  1  971  11.5606    125  Clean    false  false  false                  MicrosoftInternetExplorer4   NAME    Morphological - CVIPtools core toolbox library for morphology&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPmorph.h&gt;&nbsp;     See the individual function man pages for details and  exam-     ples.&nbsp;PATH   $CVIPtoolsHOME\\lib  FUNCTIONS     The following functions are included in Morphological:&nbsp;      hexrotate      MorphClose      MorphClose_Image      MorphDilate      MorphDilate_Image      MorphErode      MorphErode_Image      morpho      morphIterMod_Image      MorphOpen      MorphOpen_Image      Morph_Hitmiss      Morph_Thinning      Morph_Skeleton&nbsp;    The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\MORPOLOGICAL&nbsp;RETURN VALUES     See the individual function man pages&nbsp;SEE ALSO     Functions listed above&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E  Umbaugh,  Greg  Hance,     Kun Luo.&nbsp;\n\r\n\r&nbsp;","Morphological","scr\\CVIPlibraries/Morphological.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  5  1  2004-06-04T02:26:00Z  2004-07-12T22:48:00Z  1  170  975  SIUE  8  2  1143  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME&nbsp;&nbsp;&nbsp;&nbsp; Noise- CVIPtools core toolbox library for noise&nbsp; genera-&nbsp;&nbsp;&nbsp;&nbsp; tion&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPtoolkit.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPdef.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPimage.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPconvert.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPnoise.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; See the individual function man pages for details and&nbsp; exam-&nbsp;&nbsp;&nbsp;&nbsp; ples.&nbsp;PATH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $CVIPtoolsHOME\\lib&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;TYPES AND CONSTANTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define FS 8000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define NOISE 100*cos(2*Pi*T*1000/FS)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define trunc(x) (((x) &gt; 255) ? 255:(((x) &lt; 0) ? 0:(x)))&nbsp;FUNCTIONS&nbsp;&nbsp;&nbsp;&nbsp; The following functions are included in Noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gamma_noise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gaussian_noise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; neg_exp_noise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rayleigh_noise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;speckle_noise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uniform_noise&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\NOISE&nbsp;RETURN VALUES&nbsp;&nbsp;&nbsp;&nbsp; The functions return a modified Image&nbsp; pointer&nbsp; on&nbsp; success,&nbsp;&nbsp;&nbsp;&nbsp; and returns a NULL pointer on failure.&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; Functions listed above&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1996, 2004 SIUE - by Scott E Umbaugh.&nbsp;\n\r\n\r&nbsp;","Noise","scr\\CVIPlibraries/Noise.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-04T02:27:00Z  2004-06-09T16:20:00Z  1  2160  12313  SIUE  102  28  14445  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME&nbsp;&nbsp;&nbsp;&nbsp; Object - CVIPtools toolkit library&nbsp; for&nbsp; object&nbsp; analysis&nbsp;&nbsp;&nbsp;&nbsp; and identification&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPobject.h&gt;&nbsp;PATH&nbsp;&nbsp;&nbsp;&nbsp; $CVIPtoolsHOME\\lib&nbsp;&nbsp;FUNCTIONS: Object&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object *new_Object(int label_count, Color pixel, int r_pos, int c_pos)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;label_count&gt; - object label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;pixel&gt; - color of the object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;r_pos&gt; - vertical position of upper left corner&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;c_pos&gt; - horizontal position of upper left corner&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to new initialized object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: constructor for object class&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void print_Object(void *thisP, FILE *fileP)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;thisP&gt; -pointer to object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;fileP&gt; - file pointer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: nothing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: prints the contents of an object structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int read_Object( void *thisP, FILE *fileP)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;thisP&gt; - pointer to object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;fileP&gt; - file pointer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: integer error status (0 or 1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: reads an object description from a file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: returns 0 upon failure to read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void delete_Object(void *objectP)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;objectP&gt; - pointer to Object structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: nothing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: detroys an instance of an object structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int match_Object(void *objectP, void *labelP)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;objectP&gt; - pointer to object structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;labelP&gt; - pointer to label to match (int)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: 0 or 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: returns 1 for a match and 0 otherwise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void drawBB_Objects(Image *imageP, ObjectList listP)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;imageP&gt; - pointer to Image structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;listP&gt; - pointer to object list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: nothing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: draws a bounding box around each box&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; corresponding to each object in the list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;FUNCTIONS: Chain Codes&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short build_ChainCode(ChainCode *ccP, Image *imageP,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c_min, int r_min, int c_max, int r_max);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ccP&gt; - pointer to chain code object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;imageP&gt; - pointer to input image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;c_min&gt; - upper left column position of region of interest &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;r_min&gt; - upper left row position of region of interest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;c_max&gt; - lower right&nbsp; column position of region of interest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;r_max&gt; - lower right row position of region of interest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: 1 if successful else 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Builds a Freeman chain of vectors&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; describing the edge of the contour with a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; specified elevation. Always follows the contour&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in a clockwise direction.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void report_ChainCode(ChainCode *ccP)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ccP&gt; - pointer to chain code object&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Returns: nothing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; Follows the Freeman chain of&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vectors describing the edge of the contour.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Reports the elevation, start point, direction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vectors, and the number of vectors in the chain.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ChainCode *new_ChainCode( int start_r, int start_c, int elev )&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;start_r&gt; - row position of tentative starting point&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;start_c&gt; - column position of tentative starting point&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;elev&gt; - elevation (pixel intensity of object of interest)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to new ChainCode structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; Construct a new chain code object,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Creates and initializes a chain code structure.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp; delete_ChainCode(ChainCode *ccP)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ccP&gt; - pointer to Chaincode structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: nothing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; Destroy the memory associated with a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ChainCode structure.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp; getXY_ChainCode(ChainCode *ccP, int **cP, int **rP)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ccP&gt; - pointer to Chaincode structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;cP&gt; - pointer to array of horizontal integer coordinates&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;rP&gt; - pointer to array of vertical&nbsp; integer coordinates&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: nothing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; Express the chain code as a contiguous array&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of column and row coordinates.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp; draw_ChainCode(ChainCode *ccP, Image *imageP)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ccP&gt; - pointer to Chaincode structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;imageP&gt; - pointer to image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: nothing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; overlay (draw) a chain code contour onto an&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int print_ChainCode(ChainCode *ccP, const char *name)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ccP&gt; - pointer to Chaincode structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;name&gt; - string containing file name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: 1 on success and 0 on failure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; Print a chain code representation to a file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ======================================================================= &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChainCode *read_ChainCode(const char *name)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;name&gt; - string containing file name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer a chain code structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Read a chain code file representation into a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chain code structure.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ChainCode *read_ChainCode(const char *name)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;name&gt; - string containing file name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer a chain code structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Read a chain code file representation into a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chain code structure.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: Null pointer on failure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;FUNCTIONS: Labeled Objects and object properties&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectList label_Objects( Image *imageP, Image **labelP,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; background)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;imageP&gt; - pointer to input image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;labelP&gt; - set to point to labelled image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;background&gt; - background pixel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to object list structure describing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objects in labelled image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Perform sequential labelling on input image.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The image may be binary, grayscale or color. A color&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image is limited to a color map of 256 colors or less.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectVector *listToVector_Objects(ObjectList listP)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;listP&gt; - pointer to object list structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to object vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Create a vector of objects from an object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vector.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void printLabel_Objects( ObjectList listP, const char *name)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;listP&gt; - pointer to object list structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;name&gt; - name of file to print to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: nothing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Print object list representation to file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int readLabel_Objects( ObjectList listP, const char *name )&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;listP&gt; - pointer to object list structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;name&gt; - name of file to print to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: 1 on success and 0 on failure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Read object list representation from file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void getProp_Object(Object *objP, ROI *roiP)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;objP&gt; - pointer to object list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;roiP&gt; - Pointer to ROI image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: nothing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Obtain object properties for a region of&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interest in an image. Properties calculated are:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1) zero-order moment (area), (2) horizontal center&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of gravity, (3) vertical center of gravity, (4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orientation angle (degrees), (5) eigenvalue ratio.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp; void getProp_Objects(ObjectList listP, Image *labelP)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;listP&gt; - pointer to object list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;labelP&gt; - Pointer to labelled image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: nothing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Obtain the object properties for each object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in the object list for the specified labelled image.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void printProp_Object( void *thisP, FILE *fileP)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;thisP&gt; - pointer to object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;fileP&gt; - open file pointer for output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: nothing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Print the properties of an object&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void printProp_Objects(ObjectList listP, const char *name)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;listP&gt; - pointer to object list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;fileP&gt; - open file pointer for output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: nothing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Print an object list representation to a file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int readProp_Objects( ObjectList listP, const char *name )&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;listP&gt; - pointer to object list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;name&gt; - name of file to read from&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: 1 on success and 0 on failure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Read an object list representation from a file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int trimList_Objects( ObjectList listP,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned width, unsigned height,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float p_area_min, float p_area_max,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float eig_r_min, float eig_r_max,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float angle_min, float angle_max,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float p_width, float p_height,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CVIP_BOOLEAN no_edge)&nbsp;&nbsp;&nbsp;&nbsp; =======================================================================&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;listP&gt; - pointer to object list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;width, height&gt; - width, height of image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;p_area_min, p_area_max&gt; - percentabe minimum/maximum area of object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relative to image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;eig_r_min, eig_r_max&gt; - minimum/maximum eigenvalue ratio&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;angle_min, angle_max&gt; - minimum/maximum angle for principal axis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;p_width, p_height&gt; - pencentage minimum width/height of object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relative to image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;no_edge&gt; - set to CVIP_TRUE is object should not touch boundary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: 1 on success and 0 on failure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description: Remove objects from a list that do not meet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the specified requirements.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Diagnostics: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\Object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References: none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; Object.c,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectContour.c,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectLabel.c,&nbsp;&nbsp;&nbsp;&nbsp; ObjectProperties.c, TrimList.c&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1996, 2004 SIUE - by Scott E Umbaugh, Greg Hance.&nbsp;\n\r\n\r&nbsp;","Object","scr\\CVIPlibraries/Object.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  3  2004-06-04T02:24:00Z  2004-06-09T16:22:00Z  1  109  624  SIUE  5  1  732  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME&nbsp;&nbsp;&nbsp; ObjectManager&nbsp; -&nbsp;&nbsp; CVIPtools&nbsp;&nbsp; toolkit&nbsp;&nbsp; library&nbsp;&nbsp; for&nbsp;&nbsp; object&nbsp;&nbsp;&nbsp;&nbsp; management/handling&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIProi.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;DLL.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;LL.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;Link.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;HT.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;Stack.h&gt;&nbsp;PATH&nbsp;&nbsp;&nbsp; $CVIPtoolsHOME\\lib&nbsp;DESCRIPTION&nbsp;&nbsp;&nbsp;&nbsp; ObjectManager is the home of the&nbsp; linked&nbsp; list,&nbsp; double&nbsp; linked&nbsp;&nbsp;&nbsp;&nbsp; list, hash table, and stack handling functions.&nbsp;TYPES AND CONSTANTS&nbsp;&nbsp;&nbsp;&nbsp; See individual header files in $CVIPtoolsHOME\\include.&nbsp;RETURN VALUES&nbsp;&nbsp; &nbsp;&nbsp;See individual header files in $CVIPtoolsHOME\\include.&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; DLL.c, HT.c, LL.c, Stack.c&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1995, 1997, 2004 SIUE - by Gregory Hance&nbsp; and&nbsp; Scott&nbsp;&nbsp;&nbsp;&nbsp; Umbaugh.&nbsp;\n\r\n\r&nbsp;","ObjectManager","scr\\CVIPlibraries/ObjectManager.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  3  2004-06-04T02:27:00Z  2004-06-09T16:23:00Z  1  618  3524  SIUE  29  8  4134  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     pbm - functions to support portable bitmap programs&nbsp;SYNOPSIS     #include &lt;pbm.h&gt;     &nbsp;DESCRIPTION - PACKAGE-WIDE ROUTINES  KEYWORD MATCHING     int pm_keymatch( char* str, char* keyword, int minchars )&nbsp;     Does a case-insensitive match of str against  keyword.   str     can be a leading sunstring of keyword, but at least minchars     must be present.&nbsp;  LOG BASE TWO     int pm_maxvaltobits( int maxval )     int pm_bitstomaxval( int bits )&nbsp;     Convert between a maxval and  the  minimum  number  of  bits     required to hold it.&nbsp;  MESSAGES AND ERRORS     void pm_message( char* fmt, ... )&nbsp;     printf() style routine to write an informational message.&nbsp;     void pm_error( char* fmt, ... )&nbsp;     printf() style routine to write an error message and abort.&nbsp;     void pm_usage( char* usage )&nbsp;     Write a usage message.   The  string  should  indicate  what     arguments are to be provided to the program.&nbsp;  GENERIC FILE MANAGEMENT     FILE* pm_openr( char* name )&nbsp;     Open the given file  for  reading,  with  appropriate  error     checking.   A  filename  of  &quot;-&quot;  is  taken as equivalent to     stdin.&nbsp;     FILE* pm_openw( char* name )&nbsp;     Open the given file  for  writing,  with  appropriate  error     checking.&nbsp;     void pm_close( FILE* fp )&nbsp;     Close the file descriptor, with appropriate error checking.&nbsp;  ENDIAN I/O     int pm_readbigshort( FILE* in, short* sP )     int pm_writebigshort( FILE* out, short s )     int pm_readbiglong( FILE* in, long* lP )     int pm_writebiglong( FILE* out, long l )     int pm_readlittleshort( FILE* in, short* sP )     int pm_writelittleshort( FILE* out, short s )     int pm_readlittlelong( FILE* in, long* lP )     int pm_writelittlelong( FILE* out, long l )&nbsp;     Routines to read and write short and  long  ints  in  either     big- or little-endian byte order.&nbsp;DESCRIPTION - PBM-SPECIFIC ROUTINES  TYPES AND CONSTANTS     typedef ... bit;     #define PBM_WHITE ...     #define PBM_BLACK ...&nbsp;     each bit should contain only  the  values  of  PBM_WHITE  or     PBM_BLACK.&nbsp;     #define PBM_FORMAT ...     #define RPBM_FORMAT ...     #define PBM_TYPE PBM_FORMAT     #define PBM_FORMAT_TYPE(f) ...&nbsp;     For distinguishing different file formats and types.&nbsp;  INITIALIZATION     void pbm_init( int* argcP, char* argv[] )&nbsp;     All PBM programs must call this routine.&nbsp;  MEMORY MANAGEMENT     bit** pbm_allocarray( int cols, int rows )&nbsp;     Allocate an array of bits.&nbsp;     bit* pbm_allocrow( int cols )&nbsp;     Allocate a row of the given number of bits.&nbsp;     void pbm_freearray( bit** bits, int rows )&nbsp;     Free the array allocated  with  pbm_allocarray()  containing     the given number of rows.&nbsp;     void pbm_freerow( bit* bitrow )&nbsp;     Free a row of bits.&nbsp;  READING FILES     void pbm_readpbminit( FILE* fp, int* colsP, int* rowsP, int* formatP )&nbsp;     Read the header from a PBM file, filling in the  rows,  cols     and format variables.&nbsp;     void pbm_readpbmrow( FILE* fp, bit* bitrow, int cols, int format )&nbsp;     Read a row of bits into the bitrow array.  Format  and  cols     were filled in by pbm_readpbminit().&nbsp;     bit** pbm_readpbm( FILE* fp, int* colsP, int* rowsP )&nbsp;     Read an entire bitmap file into memory, returning the  allo-     cated  array  and  filling  in  the rows and cols variables.     This function combines  pbm_readpbminit(),  pbm_allocarray()     and pbm_readpbmrow().&nbsp;  WRITING FILES     void pbm_writepbminit( FILE* fp, int cols, int rows, int forceplain )&nbsp;     Write the header for a portable bitmap file.  The forceplain     flag forces a plain-format file to be written, as opposed to     a raw-format one.&nbsp;     void pbm_writepbmrow( FILE* fp, bit* bitrow, int cols, int forceplain )&nbsp;     Write a row from a portable bitmap.&nbsp;     void pbm_writepbm( FILE* fp, bit** bits, int cols, int rows, int forceplain )&nbsp;     Write the header and all data for a portable  bitmap.   This     function combines pbm_writepbminit() and pbm_writepbmrow().&nbsp;SEE ALSO     pgm(3), ppm(3), pnm(3)&nbsp;AUTHOR     Copyright (C) 1989, 1991, 2004 by Tony Hansen and Jef Poskanzer.&nbsp;\n\r\n\r&nbsp;","PBM","scr\\CVIPlibraries/PBM.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  0  2004-06-04T02:28:00Z  2004-06-09T16:23:00Z  1  399  2280  SIUE  19  5  2674  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     pgm - functions to support portable graymap programs&nbsp;SYNOPSIS     #include &lt;pgm.h&gt;    &nbsp;DESCRIPTION  TYPES AND CONSTANTS     typedef ... gray;     #define PGM_MAXMAXVAL ...     extern gray pgm_pbmmaxval;&nbsp;     Each gray should contain  only  the  values  between  0  and     PGM_MAXMAXVAL.   pgm_pbmmaxval is the maxval used when a PGM     program reads a PBM file.  Normally it is  1;  however,  for     some programs, a larger value gives better results.&nbsp;     #define PGM_FORMAT ...     #define RPGM_FORMAT ...     #define PGM_TYPE PGM_FORMAT     int PGM_FORMAT_TYPE( int format )&nbsp;     For distinguishing different file formats and types.&nbsp;  INITIALIZATION     void pgm_init( int* argcP, char* argv[] )&nbsp;     All PGM programs must call this routine.&nbsp;  MEMORY MANAGEMENT     gray** pgm_allocarray( int cols, int rows )&nbsp;     Allocate an array of grays.&nbsp;     gray* pgm_allocrow( int cols )&nbsp;     Allocate a row of the given number of grays.&nbsp;     void pgm_freearray( gray** grays, int rows )&nbsp;     Free the array allocated  with  pgm_allocarray()  containing     the given number of rows.&nbsp;     void pgm_freerow( gray* grayrow )&nbsp;     Free a row of grays.&nbsp;  READING FILES     void pgm_readpgminit( FILE* fp, int* colsP, int* rowsP, gray* maxvalP, int* formatP )&nbsp;     Read the header from a PGM file, filling in the rows,  cols,     maxval and format variables.&nbsp;     void pgm_readpgmrow( FILE* fp, gray* grayrow, int cols, gray maxval, int format )&nbsp;     Read a row of grays into the grayrow array.   Format,  cols,     and maxval were filled in by pgm_readpgminit().&nbsp;     gray** pgm_readpgm( FILE* fp, int* colsP, int* rowsP, gray* maxvalP )&nbsp;     Read an entire graymap file into memory, returning the allo-     cated  array  and filling in the rows, cols and maxval vari-     ables.    This    function    combines    pgm_readpgminit(),     pgm_allocarray() and pgm_readpgmrow().&nbsp;  WRITING FILES     void pgm_writepgminit( FILE* fp, int cols, int rows, gray maxval, int forceplain )&nbsp;     Write the header for a  portable  graymap  file.   The  for-     ceplain  flag  forces  a plain-format file to be written, as     opposed to a raw-format one.&nbsp;     void pgm_writepgmrow( FILE* fp, gray* grayrow, int cols, gray maxval, int forceplain )&nbsp;     Write a row from a portable graymap.&nbsp;     void pgm_writepgm( FILE* fp, gray** grays, int cols, int rows, gray maxval, int forceplain )&nbsp;     Write the header and all data for a portable graymap.   This     function combines pgm_writepgminit() and pgm_writepgmrow().&nbsp;SEE ALSO     pbm(3), ppm(3), pnm(3)&nbsp;AUTHOR     Copyright (C) 1989, 1991, 2004 by Tony Hansen and Jef Poskanzer.&nbsp;\n\r\n\r&nbsp;","pgm","scr\\CVIPlibraries/pgm.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  2  2004-06-04T02:29:00Z  2004-06-09T16:24:00Z  1  691  3939  SIUE  32  9  4621  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     pnm - functions to support portable anymap programs&nbsp;SYNOPSIS     #include &lt;pnm.h&gt;     &nbsp;DESCRIPTION  TYPES AND CONSTANTS     typedef ... xel;     typedef ... xelval;     #define PNM_MAXMAXVAL ...     extern xelval pnm_pbmmaxval;&nbsp;     Each xel contains three xelvals, each of which  should  con-     tain   only   the   values   between  0  and  PNM_MAXMAXVAL.     pnm_pbmmaxval is the maxval used when a PNM program reads  a     PBM  file.   Normally it is 1; however, for some programs, a     larger value gives better results.&nbsp;  XEL MANIPULATIONS     xelval PNM_GET1( xel x )&nbsp;     This macro extracts a single value from  an  xel,  when  you     know  it\'s  from  a  PBM  or PGM file.  When it\'s from a PPM     file, use PPM_GETR(), PPM_GETG(), and PPM_GETB().&nbsp;     void PNM_ASSIGN1( xel x, xelval v )&nbsp;     This macro assigns a single value to an xel, when  you  know     it\'s from a PBM or PGM file.  When it\'s from a PPM file, use     PPM_ASSIGN().&nbsp;     int PNM_EQUAL( xel x, xel y )&nbsp;     This macro checks two xels for equality.&nbsp;     int PNM_FORMAT_TYPE( int format )&nbsp;     For distinguishing different file types.&nbsp;  INITIALIZATION     void pnm_init( int* argcP, char* argv[] )&nbsp;     All PNM programs must call this routine.&nbsp;  MEMORY MANAGEMENT     xel** pnm_allocarray( int cols, int rows )&nbsp;     Allocate an array of xels.&nbsp;     xel* pnm_allocrow( int cols )&nbsp;     Allocate a row of the given number of xels.&nbsp;     void pnm_freearray( xel** xels, int rows )&nbsp;     Free the array allocated  with  pnm_allocarray()  containing     the given number of rows.&nbsp;     void pnm_freerow( xel* xelrow )&nbsp;     Free a row of xels.&nbsp;  READING FILES     void pnm_readpnminit( FILE* fp, int* colsP, int* rowsP, xelval* maxvalP, int* formatP )&nbsp;     Read the header from a PNM file, filling in the rows,  cols,     maxval and format variables.&nbsp;     void pnm_readpnmrow( FILE* fp, xel* xelrow, int cols, xelval maxval, int format )&nbsp;     Read a row of xels into the xelrow array.  Format, cols, and     maxval were filled in by pnm_readpnminit().&nbsp;     xel** pnm_readpnm( FILE* fp, int* colsP, int* rowsP, xelval* maxvalP, int* formatP )&nbsp;     Read an entire anymap file into memory, returning the  allo-     cated  array and filling in the rows, cols, maxval, and for-     mat variables.  This  function  combines  pnm_readpnminit(),     pnm_allocarray()    and    pnm_readpnmrow().    Unlike   the     equivalent functions in PBM, PGM, and PPM,  it  returns  the     format so you can tell what type the file is.&nbsp;  WRITING FILES     void pnm_writepnminit( FILE* fp, int cols, int rows, xelval maxval, int format, int forceplain )&nbsp;     Write the header for a portable  anymap  file.   Unlike  the     equivalent  functions  in  PBM,  PGM,  and  PPM, you have to     specify the output  type.   The  forceplain  flag  forces  a     plain-format  file to be written, as opposed to a raw-format     one.&nbsp;     void pnm_writepnmrow( FILE* fp, xel* xelrow, int cols, xelval maxval, int format, int forceplain )&nbsp;     Write a row from a portable anymap.&nbsp;     void pnm_writepnm( FILE* fp, xel** xels, int cols, int rows, xelval maxval, int format, int forceplain )&nbsp;     Write the header and all data for a portable  anymap.   This     function combines pnm_writepnminit() and pnm_writepnmrow().&nbsp;  FORMAT PROMOTION     void pnm_promoteformatrow( xel* xelrow, int cols, xelval maxval, int format, xelval newmaxval, int newformat )&nbsp;     Promote a row of xels from one maxval and format  to  a  new     set.   Used  when  combining  multiple  anymaps of different     types - just take the max of the maxvals and the max of  the     formats, and promote them all to that.&nbsp;     void pnm_promoteformat( xel** xels, int cols, int rows, xelval maxval, int format, xelval newmaxval, int newformat )&nbsp;     Promote an entire anymap.&nbsp;  XEL MANIPULATION     xel pnm_whitexel( xelval maxval, int format )     xel pnm_blackxel( xelval maxval, int format )&nbsp;     Return a white or black xel for the given maxval and format.&nbsp;     void pnm_invertxel( xel* x, xelval maxval, int format )&nbsp;     Invert an xel.&nbsp;     xel pnm_backgroundxelrow( xel* xelrow, int cols, xelval maxval, int format )&nbsp;     Figure out an appropriate background xel based on this row.&nbsp;     xel pnm_backgroundxel( xel** xels, int cols, int rows, xelval maxval, int format )&nbsp;     Figure out a background xel based on an entire anymap.  This     can do a slightly better job than pnm_backgroundxelrow().&nbsp;SEE ALSO     pbm(3), pgm(3), ppm(3)&nbsp;AUTHOR     Copyright (C) 1989, 1991, 2004 by Tony Hansen and Jef Poskanzer.&nbsp;\n\r\n\r&nbsp;","pnm","scr\\CVIPlibraries/pnm.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  0  2004-06-04T02:30:00Z  2004-06-09T16:24:00Z  1  659  3762  SIUE  31  8  4413  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     ppm - functions to support portable pixmap programs&nbsp;SYNOPSIS     #include &lt;ppm.h&gt;     &nbsp;DESCRIPTION  TYPES AND CONSTANTS     typedef ... pixel;     typedef ... pixval;     #define PPM_MAXMAXVAL ...     extern pixval ppm_pbmmaxval;&nbsp;     Each pixel contains three pixvals, each of which should con-     tain   only   the   values   between  0  and  PPM_MAXMAXVAL.     ppm_pbmmaxval is the maxval used when a PPM program reads  a     PBM  file.   Normally it is 1; however, for some programs, a     larger value gives better results.&nbsp;     #define PPM_FORMAT ...     #define RPPM_FORMAT ...     #define PPM_TYPE PPM_FORMAT     int PPM_FORMAT_TYPE( int format )&nbsp;     For distinguishing different file formats and types.&nbsp;     pixval PPM_GETR( pixel p )     pixval PPM_GETG( pixel p )     pixval PPM_GETB( pixel p )&nbsp;     These three macros retrieve the red,  green  or  blue  value     from the given pixel.&nbsp;     void PPM_ASSIGN( pixel p, pixval red, pixval grn, pixval blu )&nbsp;     This macro assigns the given red, green and blue  values  to     the pixel.&nbsp;     int PPM_EQUAL( pixel p, pixel q )&nbsp;     This macro checks two pixels for equality.&nbsp;     void PPM_DEPTH( pixel newp, pixel p, pixval oldmaxval, pixval newmaxval )&nbsp;     This macro scales the colors of pixel p  according  the  old     and  new  maximum values and assigns the new values to newp.     It is intended to make writing ppmtowhatever easier.&nbsp;     float PPM_LUMIN( pixel p )&nbsp;     This macro determines the luminance of the pixel p.&nbsp;  MEMORY MANAGEMENT     pixel** ppm_allocarray( int cols, int rows )&nbsp;     Allocate an array of pixels.&nbsp;     pixel* ppm_allocrow( int cols )&nbsp;     Allocate a row of the given number of pixels.&nbsp;     void ppm_freearray( pixel** pixels, int rows )&nbsp;     Free the array allocated  with  ppm_allocarray()  containing     the given number of rows.&nbsp;     void pbm_freerow( pixel* pixelrow )&nbsp;     Free a row of pixels.&nbsp;  READING PBM FILES     void ppm_readppminit( FILE* fp, int* colsP, int* rowsP, pixval* maxvalP, int* formatP )&nbsp;     Read the header from a PPM file, filling in the rows,  cols,     maxval and format variables.&nbsp;     void ppm_readppmrow( FILE* fp, pixel* pixelrow, int cols, pixval maxval, int format )&nbsp;     Read a row of pixels into the pixelrow array.  Format, cols,     and maxval were filled in by ppm_readppminit().&nbsp;     pixel** ppm_readppm( FILE* fp, int* colsP, int* rowsP, pixval* maxvalP )&nbsp;     Read an entire pixmap file into memory, returning the  allo-     cated  array  and filling in the rows, cols and maxval vari-     ables.    This    function    combines    ppm_readppminit(),     ppm_allocarray() and ppm_readppmrow().&nbsp;  WRITING FILES     void ppm_writeppminit( FILE* fp, int cols, int rows, pixval maxval, int forceplain )&nbsp;     Write the header for a portable pixmap file.  The forceplain     flag forces a plain-format file to be written, as opposed to     a raw-format one.&nbsp;     void ppm_writeppmrow( FILE* fp, pixel* pixelrow, int cols, pixval maxval, int forceplain )&nbsp;     Write a row from a portable pixmap.&nbsp;     void ppm_writeppm( FILE* fp, pixel** pixels, int cols, int rows, pixval maxval, int forceplain )&nbsp;     Write the header and all data for a portable  pixmap.   This     function combines ppm_writeppminit() and ppm_writeppmrow().&nbsp;  COLOR NAMES     pixel ppm_parsecolor( char* colorname, pixval maxval )&nbsp;     Parses an ASCII color name into a pixel.  The color  can  be     specified  in  three  ways.  One, as a name, assuming that a     pointer to an X11-style color names file  was  compiled  in.     Two,  as  an  X11-style  hexadecimal  number: #rgb, #rrggbb,     #rrrgggbbb,  or  #rrrrggggbbbb.   Three,  as  a  triplet  of     decimal   floating   point   numbers  separated  by  commas:     r.r,g.g,b.b.&nbsp;     char* ppm_colorname( pixel* colorP, pixval maxval, int hexok )&nbsp;     Returns a pointer to a string describing  the  given  color.     If  the  X11  color  names  file  is available and the color     appears in it, that name is  returned.   Otherwise,  if  the     hexok flag is true then a hexadecimal colorspec is returned;     if hexok is false and the X11 color names file is available,     then the closest matching color is returned; otherwise, it\'s     an error.&nbsp;SEE ALSO     pbm(3), pgm(3)&nbsp;AUTHOR     Copyright (C) 1989, 1991, 2004 by Tony Hansen and Jef Poskanzer.&nbsp;\n\r\n\r&nbsp;","ppm","scr\\CVIPlibraries/ppm.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  3  2004-06-04T02:30:00Z  2004-07-12T22:51:00Z  1  1740  9920  SIUE  82  23  11637  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME     ROI  -  CVIPtools  toolkit  library  for  region/area  of     interest designation, manipulation of an image&nbsp;SYNOPSIS     #include &lt;CVIProi.h&gt;&nbsp;DESCRIPTION  TYPES AND CONSTANTS     typedef struct {&nbsp;           unsigned x;           unsigned y;           unsigned dx;           unsigned dy;&nbsp;           Image *dataP;&nbsp;     } ROI;&nbsp;  FUNCTION CATEGORIES&nbsp;     ****************************************************     ROI *new_ROI(void)     ****************************************************&nbsp;     Description: ROI class constructor. Creates a  new  instance     of an ROI structure.  Author(s): Gregory Hance.&nbsp;     ****************************************************     void delete_ROI(ROI *roiP)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object&nbsp;     Description:  ROI  class  destructor.   Author(s):   Gregory     Hance.&nbsp;     ****************************************************     void asgnImage_ROI(ROI *roiP, Image *imageP, unsigned x, unsigned y,     unsigned dx, unsigned dy)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to a ROI object     &lt;imageP&gt; - pointer to an Image object     &lt;x&gt; - horizontal offset of region from pixel location (0,0)     &lt;y&gt; - vertical offset of region from pixel location (0,0)     &lt;dx&gt; - width of region (number of columns)     &lt;dy&gt; - height of region (number of rows)&nbsp;     Description: assigns an ROI to an image. Note that  the  ROI     will  retain all of the same attributes as the parent image,     with the exception that some additional information describ-     ing  the  specific area/region of interest will be included.     Author(s): Gregory Hance.&nbsp;     ****************************************************     void asgnFullImage_ROI(ROI *roiP, Image *imageP)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object     &lt;imageP&gt; - pointer to an Image object&nbsp;     Description:  assign  ROI  as  the  full  image   dimension.     Author(s): Gregory Hance.&nbsp;     ****************************************************     unsigned getHorOffset_ROI(ROI *roiP)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object&nbsp;     Description: returns the horizontal offset of the  ROI  from     pixel (0,0).  Author(s): Gregory Hance.&nbsp;     ****************************************************     unsigned getVerOffset_ROI(ROI *roiP)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object&nbsp;     Description: returns the vertical offset  of  the  ROI  from     pixel (0,0).  Author(s): Gregory Hance.&nbsp;     ****************************************************     unsigned getHorSize_ROI(ROI *roiP)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object&nbsp;     Description: returns the height/horizontal size of the  ROI.     Author(s): Gregory Hance.&nbsp;     ****************************************************     unsigned getVerSize_ROI(ROI *roiP)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object&nbsp;     Description: returns the width/vertical  size  of  the  ROI.     Author(s): Gregory Hance.&nbsp;     ****************************************************     unsigned getNoOfRows_ROI(ROI *roiP)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object&nbsp;     Description: same as &quot;getVerSize_ROI&quot;.   Author(s):  Gregory     Hance.&nbsp;     ****************************************************     unsigned getNoOfCols_ROI(ROI *roiP)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object&nbsp;     Description: same as &quot;getHorSize_ROI&quot;.   Author(s):  Gregory     Hance.&nbsp;     ****************************************************     unsigned getNoOfBands_ROI(ROI *roiP)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object&nbsp;     Description: returns the number of data bands  in  the  ROI.     Author(s): Gregory Hance.&nbsp;     ****************************************************     FORMAT getDataFormat_ROI(ROI *roiP)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object&nbsp;     Description: returns the  data format of ROI (i.e.  REAL  or     COMPLEX).  Author(s): Gregory Hance.&nbsp;     ****************************************************     CVIP_TYPE getDataType_ROI(ROI *roiP)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object&nbsp;     Description: returns the data type of the  ROI.   Author(s):     Gregory Hance.&nbsp;     ****************************************************     void *getRealRow_ROI(ROI *roiP, unsigned y, unsigned band_no)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object     &lt;y&gt; - row number to reference     &lt;band_no&gt; - band number to reference     Description: returns a reference/pointer to a  real  row  of     data  from  the ROI.  NOTE: the row returned is with respect     to the ROI and not the image. (i.e.  getRealRow_ROI(roi,5,0)     will  return row 5 of the ROI which is actually a pointer to     the pixel sample at row = (5 + vertical offset), col = (hor-     izontal offset) of the image ) Author(s): Gregory Hance.&nbsp;     ****************************************************     void *getRow_ROI(ROI *roiP, unsigned y, unsigned band_no)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object     &lt;y&gt; - row number to reference     &lt;band_no&gt; - band number to reference&nbsp;     Description: same as &quot;getRealRow_ROI&quot;.   Author(s):  Gregory     Hance.&nbsp;     ****************************************************     void *getImagRow_ROI(ROI *roiP, unsigned y, unsigned band_no)     ****************************************************     Si     &lt;roiP&gt; - pointer to an ROI object     &lt;y&gt; - row number to reference     &lt;band_no&gt; - band number to reference&nbsp;     Description: returns a reference/pointer to an imaginary row     of data from the ROI.  Author(s): Gregory Hance.&nbsp;     ****************************************************     type getRealPixel_ROI(ROI *roiP, type, unsigned x, unsigned y, unsigned band_no)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object     &lt;type&gt; - the name of a valid &quot;C&quot;, CVIPtools image data type such as byte, short,     int, float or double     &lt;x&gt; - column number to reference     &lt;y&gt; - row number to reference     &lt;band_no&gt; - band number to reference&nbsp;     Description: returns a real pixel sample  from  the  ROI  of     type  &lt;type&gt;.   NOTE:  the pixel returned is with respect to     the     ROI     and      not      the      image.      (i.e.     getRealPixel_ROI(roi,byte,3,5,0) will return a pixel located     at row 5 and column 3 of the ROI which is actually the pixel     sample  at  row = (5 + &quot;vertical offset&quot;) , col = (3 + &quot;hor-     izontal offset&quot;) of the parent  image.   Author(s):  Gregory     Hance.&nbsp;     ****************************************************     type getPixel_ROI(ROI *roiP, type, unsigned x, unsigned y, unsigned band_no)     ****************************************************     &lt;roiP&gt; - pointer to an ROI object     &lt;type&gt; - the name of a valid &quot;C&quot;, CVIPtools image data type such as byte, short,     int, float or double     &lt;x&gt; - column number to reference     &lt;y&gt; - row number to reference     &lt;band_no&gt; - band number to reference&nbsp;     Description: same as &quot;getRealPixel_ROI&quot;.  Author(s): Gregory     Hance.&nbsp;     ****************************************************     type getImagPixel_ROI(ROI *roiP, type, unsigned x, unsigned y, unsigned band_no)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object     &lt;type&gt; - the name of a valid &quot;C&quot;, CVIPtools image data type such as byte, short,     int, float or double     &lt;x&gt; - column number to reference     &lt;y&gt; - row number to reference     &lt;band_no&gt; - band number to reference&nbsp;     Description: returns an imaginary pixel sample from the  ROI     of type &lt;type&gt;.  Author(s): Gregory Hance.&nbsp;     ****************************************************     void setRealPixel_ROI(ROI *roiP, type, unsigned x, unsigned y,     unsigned band_no, type pixel)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object     &lt;type&gt; - the name of a valid &quot;C&quot;, CVIPtools image data type such as byte, short,     int, float or double     &lt;x&gt; - column number to reference     &lt;y&gt; - row number to reference     &lt;band_no&gt; - band number to reference     &lt;pixel&gt; - datum to be placed at the above location&nbsp;     Description: writes a real pixel sample to the ROI  of  type     &lt;type&gt;.   NOTE: the pixel written is with respect to the ROI     and          not          the          image.          (i.e.     setRealPixel_ROI(roi,byte,3,5,0,200)  will  write to a pixel     located at row 5 and column 3 of the ROI which  is  actually     the pixel sample at row = (5 + &quot;vertical offset&quot;) , col = (3     + &quot;horizontal offset&quot;) of the parent image.&nbsp;     Author(s): Gregory Hance.&nbsp;     ****************************************************     void setPixel_ROI(ROI *roiP, type, unsigned x, unsigned y,     unsigned band_no, type pixel)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object     &lt;type&gt; - the name of a valid &quot;C&quot;, CVIPtools image data type such as byte, short,     int, float or double     &lt;x&gt; - column number to reference     &lt;y&gt; - row number to reference     &lt;band_no&gt; - band number to reference     &lt;pixel&gt; - datum to be placed at the above location&nbsp;     Description: same as &quot;setRealPixel_ROI&quot;.  Author(s): Gregory     Hance.&nbsp;     ****************************************************     void setImagPixel_ROI(ROI *roiP, type, unsigned x, unsigned y,     unsigned band_no, type pixel)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object     &lt;type&gt; - the name of a valid &quot;C&quot;, CVIPtools image data type such as byte, short,     int, float or double     &lt;x&gt; - column number to reference     &lt;y&gt; - row number to reference     &lt;band_no&gt; - band number to reference     &lt;pixel&gt; - datum to be placed at the above location&nbsp;     Description:  set/write  imaginary  pixel  sample  to   ROI.     Author(s): Gregory Hance.&nbsp;     ****************************************************     void unloadRow_ROI(void *roiP, void *rowP, unsigned y, unsigned band_no)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object     &lt;rowP&gt; - buffer to unload data into     &lt;row&gt; - row to unload     &lt;band_no&gt; - band number of the row to unload&nbsp;     Description: unload row of data from ROI at row &lt;y&gt; into the     buffer &lt;rowP&gt;.  Author(s): Gregory Hance.&nbsp;     ****************************************************     void loadRow_ROI(void *roiP, void *rowP, unsigned y, unsigned band_no)     ****************************************************&nbsp;     &lt;roiP&gt; - pointer to an ROI object     &lt;rowP&gt; - buffer to unload data into     &lt;row&gt; - row to unload     &lt;band_no&gt; - band number of the row to unload&nbsp;     Description: load data from the buffer &lt;rowP&gt; into  the  ROI     at row &lt;y&gt;.&nbsp;BUGS     none as of yet&nbsp;SEE ALSO     CVIPtools library quick reference guide&nbsp;AUTHOR     Copyright (C) 1992, 1993, 2004 SIUE - by Gregory Hance  and  Scott     Umbaugh.&nbsp;\n\r\n\r&nbsp;","ROI","scr\\CVIPlibraries/ROI.htm","   ACADEMIC COMPUTING  Normal  P!Nk  12  5  2004-06-04T02:31:00Z  2009-12-08T16:57:00Z  1  178  1020  SIUE  8  2  1196  12.00    BestFit  Clean  Clean  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                            NAME     Segmentation - CVIPtools core toolbox library for segmentation&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPsegment.h&gt;&nbsp;     See the individual function man pages for details and  exam-     ples.&nbsp;PATH        $CVIPtoolsHOME\\lib&nbsp;FUNCTIONS     The following functions are included in Segmentation:&nbsp;               auto_threshold_segment               fuzzyc_segment               gray_quant_segment               hist_thresh_segment, hist_thresh_gray               otsu_segment               igs_segment               median_cut_segment               multi_resolution_segment               pct_median_segment               predicate_test,      mean_test               quadtree2ras               split_merge_segment, split_merge_generic               sct_split_segment               threshold_segment               watershed_segment               gvfsnake_segment     The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\SEGMENTATION&nbsp;RETURN VALUES     Returns image structure pointers to the segmented image&nbsp;SEE ALSO     Functions listed above&nbsp;AUTHOR     Copyright (C) 1996, 2004 SIUE - by Scott E Umbaugh.&nbsp;\n\r\n\r&nbsp;","Segmentation","scr\\CVIPlibraries/Segmentation.htm","   ACADEMIC COMPUTING  Normal  skefel  26  12  2004-06-04T02:32:00Z  2010-01-06T19:19:00Z  2  380  2169  SIUE  18  5  2544  12.00    BestFit  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                                                             NAME     SpatialFilter - CVIPtools core toolbox library  for  spa-     tial filtering, includes edge detectors and hough transform.&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPspfltr.h&gt;      #include &lt;CVIPfs.h&gt;      #include &lt;float.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;&nbsp;     See the individual function man pages for details and  exam-     ples.&nbsp;PATH     $CVIPtoolsHOME\\lib&nbsp;TYPES AND CONSTANTS        typedef enum {GAUSSIAN, LOW1, LOW2,  NEIGHBORHOOD,  LAP1,     LAP2, LAPB1,        LAPB2, SOB_V, SOB_H, W1, W2, W3, W4, W5, W6, W7, W8,  W9}     MASK_TYPE;&nbsp;        typedef struct {           short int n;           short int **vertical;           short int **horizontal;           short int **diag1;           short int **diag2;        } KIRSCH_MASK;&nbsp;        struct mask3x3 {           MASK_TYPE choice;           float kernel[9];        } MASK3x3[] = {MASKS1};&nbsp;        struct mask5x5 {           MASK_TYPE choice;           float kernel[25];        } MASK5x5[] = {MASKS2};&nbsp;        #define LAPLACIAN 1        #define ROBERTS 2        #define SOBEL 3        #define KIRSCH 4        #define FREI 5&nbsp;FUNCTIONS     The following functions are included in SpatialFilter:&nbsp;      ad_filter      ace2_filter      acuity_nightvision_filter      adaptive_contrast_filter      adapt_median_filter      alpha_filter      boiecox_filter      canny_filter      cerchar_filter      contra_filter      convolve_filter      edge_detect_filter      edge_link_filter      exp_ace_filter      get_default_filter      geometric_filter      harmonic_filter      harris_filter      hough_filter      hough_inverse      hough_transform      image_sharp      improved_mmse_filter      kirsch_filter      kuwahara_filter      log_ace_filter      marr_hildreth_filter      maximum_filter      mean_filter      median_filter      midpoint_filter      minimum_filter      mmse_filter      moravec_filter      param_ad_filter      pratt_merit      prewitt_filter      raster_deblur_filter      shen_castan_filter      single_filter      smooth_filter      sobel_filter      specify_filter      unsharp_filter      Ypmean_filter&nbsp;    The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\SPATIALFILTER&nbsp;&nbsp;RETURN VALUES     See individual function man pages&nbsp;SEE ALSO     Functions listed above&nbsp;AUTHOR     Copyright (C) 1996, 1997, 2004 SIUE - by Scott E Umbaugh, Kun Luo,     Dave Lyons, John Creighton.&nbsp;\n\r\n\r&nbsp;","SpatialFilter","scr\\CVIPlibraries/SpatialFilter.htm","   ACADEMIC COMPUTING  jhansi  8  2  2004-06-04T02:33:00Z  2009-07-07T20:28:00Z  1  144  824  SIUE  6  1  967  12.00    120  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                              NAME    Transform  -  CVIPtools  core  toolbox  library  for  2-D     transforms&nbsp;SYNOPSIS      #include &lt;CVIPtoolkit.h&gt;      #include &lt;CVIPdef.h&gt;      #include &lt;CVIPimage.h&gt;      #include &lt;CVIPconvert.h&gt;      #include &lt;CVIPtransform.h&gt;&nbsp;     See the individual function man pages for details and  exam-     ples.&nbsp;PATH     $CVIPtoolsHOME\\lib&nbsp;&nbsp;FUNCTIONS     The following functions are included in Transform:&nbsp;      fft_transform      fft_mag      fft_phase      ifft_transform      dct_transform      idct_transform      haar_transform      wavhaar_transform      wavdaub4_transform      walhad_transform         The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\TRANSFORMS&nbsp;&nbsp;RETURN VALUES     A pointer to the spectrum Image on success; a  NULL  pointer     on failure&nbsp;SEE ALSO     Functions listed above&nbsp;AUTHOR     Copyright (C) 1996, 1997, 2004  SIUE - by Scott  E  Umbaugh,  Arve     Kjoelen, Simon Low.&nbsp;\n\r\n\r&nbsp;","Transform","scr\\CVIPlibraries/Transform.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  5  2  2004-06-04T02:35:00Z  2004-07-12T22:55:00Z  1  185  1060  SIUE  8  2  1243  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME&nbsp;&nbsp;&nbsp; TransformFilter - CVIPtools core&nbsp; toolbox&nbsp; library&nbsp; for&nbsp; two-&nbsp;&nbsp;&nbsp;&nbsp; dimensional transform-domain filtering&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPtoolkit.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPdef.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPimage.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPconvert.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPtransform.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPxformfilter.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; See the individual function man pages for details and&nbsp; exam-&nbsp;&nbsp;&nbsp;&nbsp; ples.&nbsp;PATH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $CVIPtoolsHOME\\lib&nbsp;FUNCTIONS&nbsp;&nbsp;&nbsp;&nbsp; The following functions are included in TransformFilter:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Butterworth_Band_Pass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Butterworth_Band_Reject&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Butterworth_High&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Butterworth_Low&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; geometric_mean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; High_Freq_Emphasis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h_image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; homomorphic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ideal_Band_Pass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ideal_Band_Reject&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ideal_High&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ideal_Low&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inverse_xformfilter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; least_squares&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nonfft_xformfilter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; notch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parametric_wiener&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; power_spect_eq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simple_wiener&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wiener&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\XFORMFILTER&nbsp;&nbsp;RETURN VALUES&nbsp;&nbsp;&nbsp;&nbsp; Image pointer to filtered transform data&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; Specific man pages for functions listed above&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1996, 2004 SIUE - by Scott E Umbaugh, Simon Low, Kun&nbsp;&nbsp;&nbsp;&nbsp; Luo, Arve Kjoelen.&nbsp;\n\r\n\r&nbsp;","TransformFilter","scr\\CVIPlibraries/TransformFilter.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  4  2  2004-06-04T02:34:00Z  2004-07-12T22:54:00Z  1  1240  7074  SIUE  58  16  8298  10.3501    Clean  Clean                  MicrosoftInternetExplorer4 NAME&nbsp;&nbsp;&nbsp;&nbsp; Vector - CVIPtools toolkit library for performing&nbsp; vector&nbsp;&nbsp;&nbsp;&nbsp; algebra and manipulation&nbsp;SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;CVIPvector.h&gt;&nbsp;FUNCTIONS&nbsp;&nbsp;&nbsp;&nbsp; The following functions are included in this man page:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; band2pixel_Vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; convolve_Vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy_Vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; findHisto_Vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; findMaxVal_Vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; findMinVal_Vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normalize_Vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pixel2band_Vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printHisto_Vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subSample_Vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The C files containing these functions are located under $CVIPtoolsHOME\\CVIPC\\VectorAlgebra&nbsp;&nbsp;DESCRIPTION&nbsp; FEATURE EXTRACTION&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp; double findMinVal_Vector(void *a, unsigned length, CVIP_TYPE data_type)&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;a&gt; - pointer to vector&nbsp;&nbsp;&nbsp;&nbsp; &lt;length&gt; - no of elements in vector&nbsp;&nbsp;&nbsp;&nbsp; &lt;data_type&gt; - valid CVIPtools data type (i.e. one of CVIP_BYTE, CVIP_SHORT,&nbsp;&nbsp;&nbsp;&nbsp; CVIP_INTEGER, CVIP_FLOAT or CVIP_DOUBLE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: the minimum value in the span of&nbsp; the&nbsp; vector&nbsp; &lt;a&gt;.&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; Finds&nbsp; the minimum value in the span of a vec-&nbsp;&nbsp;&nbsp;&nbsp; tor. The value is returned as a floating point value of type&nbsp;&nbsp;&nbsp;&nbsp; double.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp; double findMaxVal_Vector(void *a, unsigned length, CVIP_TYPE data_type)&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;a&gt; - pointer to vector&nbsp;&nbsp;&nbsp;&nbsp; &lt;length&gt; - no of elements in vector&nbsp;&nbsp;&nbsp;&nbsp; &lt;data_type&gt; - valid CVIPtools data type (i.e. one of&nbsp;&nbsp;&nbsp;&nbsp; CVIP_BYTE, CVIP_SHORT, CVIP_INTEGER, CVIP_FLOAT or CVIP_DOUBLE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: the maximum value in the span of&nbsp; the&nbsp; vector&nbsp; &lt;a&gt;.&nbsp;&nbsp;&nbsp;&nbsp; Description:&nbsp; Finds&nbsp; the maximum value in the span of a vec-&nbsp;&nbsp;&nbsp;&nbsp; tor. The value is returned as a floating point value of type&nbsp;&nbsp;&nbsp;&nbsp; double.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp; DATA REPRESENTATION&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp; byte **band2pixel_Vector(byte **bandP, unsigned int no_of_bands,&nbsp;&nbsp;&nbsp;&nbsp; unsigned int imgsize)&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;bandP&gt; - pointer to array of band vectors&nbsp;&nbsp;&nbsp;&nbsp; &lt;no_of_bands&gt; - number of spectral bands in image&nbsp;&nbsp;&nbsp;&nbsp; (number of band vectors)&nbsp;&nbsp;&nbsp;&nbsp; &lt;imgsize&gt; - size of image (length of each band vector)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to array pixel vectors.&nbsp; Description:&nbsp; con-&nbsp;&nbsp;&nbsp;&nbsp; verts&nbsp;&nbsp; a&nbsp; band&nbsp; vector&nbsp; array&nbsp; to&nbsp; a&nbsp; pixel&nbsp; vector&nbsp; array.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp; byte **pixel2band_Vector(byte **pixP, unsigned int no_of_bands,&nbsp;&nbsp;&nbsp;&nbsp; unsigned int imgsize)&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;bandP&gt; - pointer to array of pixel vectors&nbsp;&nbsp;&nbsp;&nbsp; &lt;no_of_bands&gt; - number spectral bands in image (length of each pixel vector)&nbsp;&nbsp;&nbsp;&nbsp; &lt;imgsize&gt; - size of image (number of pixel vectors)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to array pixel vectors.&nbsp; Description:&nbsp; con-&nbsp;&nbsp;&nbsp;&nbsp; verts&nbsp;&nbsp; a&nbsp; pixel&nbsp; vector&nbsp; array&nbsp; to&nbsp; a&nbsp; band&nbsp; vector&nbsp; array.&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp; void copy_Vector(void *avecP, void *bvecP, unsigned int vdim, CVIP_TYPE atype,&nbsp;&nbsp;&nbsp;&nbsp; CVIP_TYPE btype)&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;avecP&gt; - pointer to vector A&nbsp;&nbsp;&nbsp;&nbsp; &lt;bvecP&gt; - pointer to vector B&nbsp;&nbsp;&nbsp;&nbsp; &lt;vdim&gt; - dimension of each vector&nbsp;&nbsp;&nbsp;&nbsp; &lt;atype&gt; - type of data pointed to by vector A&nbsp;&nbsp;&nbsp;&nbsp; &lt;btype&gt; - type of data pointed to by vector B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: nada.&nbsp; Description: copies the contents of vector A&nbsp;&nbsp;&nbsp;&nbsp; into&nbsp; vector&nbsp; B.&nbsp; Handles all 25 different type combinations&nbsp;&nbsp;&nbsp;&nbsp; of A and B. NOTE: this function&nbsp; simply&nbsp; copies&nbsp; one&nbsp; vector&nbsp;&nbsp;&nbsp;&nbsp; into&nbsp; another;&nbsp; therefore copying a vector of a more precise&nbsp;&nbsp;&nbsp;&nbsp; type to that of a less precise type will work&nbsp; properly&nbsp; but&nbsp;&nbsp;&nbsp;&nbsp; may&nbsp; result in garbage if the range of A is not inclusive of&nbsp;&nbsp;&nbsp;&nbsp; that of B.&nbsp; Author(s): Gregory Hance.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp; void *normalize_Vector(void *srcvecP, float *normP, CVIP_TYPE vecdtype,&nbsp;&nbsp;&nbsp;&nbsp; unsigned int no_of_vecs, unsigned int vdim)&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;srcvecP&gt; - pointer to array of vectors&nbsp;&nbsp;&nbsp;&nbsp; &lt;normP&gt; - normalization vector&nbsp;&nbsp;&nbsp;&nbsp; &lt;vecdtype&gt; - valid CVIPtools data type of vector&nbsp;&nbsp;&nbsp;&nbsp; &lt;no_of_vecs&gt; - number of vectors&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: pointer to a normalized array of vectors.&nbsp; Descrip-&nbsp;&nbsp;&nbsp;&nbsp; tion:&nbsp; This function will normalize an array of vectors with&nbsp;&nbsp;&nbsp;&nbsp; respect&nbsp; to&nbsp; the&nbsp; normalization&nbsp;&nbsp; vector&nbsp;&nbsp; &lt;normP&gt;.&nbsp;&nbsp;&nbsp; (i.e.&nbsp;&nbsp;&nbsp;&nbsp; srcvecP[0]([0],[1],...,[vdim-1])/normP[0],&nbsp;&nbsp;&nbsp;&nbsp; srcvecP[1]([0],[1],...,[vdim-1])/normP[1].&nbsp; If the data type&nbsp;&nbsp;&nbsp;&nbsp; of&nbsp; the&nbsp; vectors&nbsp; is&nbsp; less&nbsp; precise than &quot;float&quot; or equal to&nbsp;&nbsp;&nbsp;&nbsp; &quot;float&quot; then the result will be type &quot;float&quot;. If the&nbsp; arrays&nbsp;&nbsp;&nbsp;&nbsp; are&nbsp; of&nbsp; type&nbsp; &quot;double&quot;&nbsp; then the result will be an array of&nbsp;&nbsp;&nbsp;&nbsp; normalized vectors of&nbsp; type&nbsp; &quot;double&quot;.&nbsp;&nbsp; Author(s):&nbsp; Gregory&nbsp;&nbsp;&nbsp;&nbsp; Hance.&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; convolve_Vector(double *xvecP, double *hvecP, int xlen,&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hlen)&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xvecP&gt; - input sequence vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;hvecP&gt; - impulse sequence vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;xlen&gt; - length of input vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;hlen&gt; - length of impulse vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: None.&nbsp;&nbsp;&nbsp;&nbsp; Description: This function performs convolution on two&nbsp; vec-&nbsp;&nbsp;&nbsp;&nbsp; tors.&nbsp;&nbsp;&nbsp;&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gregory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hance.&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp; int findHisto_Vector(byte *vecP, int vsize, void *hP, int l,&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CVIP_TYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dtype)&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;vecP&gt; - input vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;vsize&gt; - size of input vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;hP&gt; - histogram vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;l&gt; - expected low value in input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;h&gt; - expected high value in input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;dtype&gt; - valid CVIPtools data type of vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: None.&nbsp;&nbsp;&nbsp;&nbsp; Description: This function will find&nbsp; the&nbsp; histogram&nbsp; of&nbsp; an&nbsp;&nbsp;&nbsp;&nbsp; input vector of type CVIP_INTEGER or CVIP_DOUBLE.&nbsp;&nbsp;&nbsp;&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gregory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hance.&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp; int printHisto_Vector(const char *fname, void *hP, CVIP_TYPE&nbsp;&nbsp;&nbsp;&nbsp; dtype,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; h,&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; skipval)&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;fname&gt; - filename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;hP&gt; - histogram vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;dtype&gt; - valid CVIPtools data type of vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;l&gt; - expected low value in input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;h&gt; - expected high value in input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;skipval&gt; - value to set to zero when computing histogram&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: None.&nbsp;&nbsp;&nbsp;&nbsp; Description: This function will write&nbsp; the histogram&nbsp; of&nbsp; an&nbsp;&nbsp;&nbsp;&nbsp; input vector of type CVIP_INTEGER or CVIP_DOUBLE to a file.&nbsp;&nbsp;&nbsp;&nbsp; Author(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gregory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hance.&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp; void *subSample_Vector(void *vecP, unsigned&nbsp; dim,&nbsp; CVIP_TYPE&nbsp;&nbsp;&nbsp;&nbsp; data_type,&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp; skip,&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp; *new_dim)&nbsp;&nbsp;&nbsp;&nbsp; ******************************************************************&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;vecP&gt; -pointer to input vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;dim&gt; - dimension of input vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;data_type&gt; - valid CVIPtools data type of vector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;skip&gt; - number of elements to skip for sampling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;new_dim&gt; - new vector length&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns: New sampled vector.&nbsp;&nbsp;&nbsp;&nbsp; Description: This function will produce a vector by sampling&nbsp;&nbsp;&nbsp;&nbsp; every&nbsp; &lt;skip&gt; element of an input vector. This function will&nbsp;&nbsp;&nbsp;&nbsp; accept&nbsp; CVIPtools&nbsp; datatypes&nbsp;&nbsp; of&nbsp;&nbsp; CVIP_BYTE,&nbsp;&nbsp; CVIP_SHORT,&nbsp;&nbsp;&nbsp;&nbsp; CVIP_INTEGER, CVIP_FLOAT, and CVIP_DOUBLE&nbsp;&nbsp;&nbsp;&nbsp; Author(s): Gregory Hance.&nbsp;BUGS&nbsp;&nbsp;&nbsp;&nbsp; none as of yet&nbsp;SEE ALSO&nbsp;&nbsp;&nbsp;&nbsp; CVIPvector.h, CVIPtools library quick reference guide&nbsp;AUTHOR&nbsp;&nbsp;&nbsp;&nbsp; Copyright (C) 1992, 1995, 2004 SIUE - by Gregory Hance&nbsp; and&nbsp; Scott&nbsp;&nbsp;&nbsp;&nbsp; Umbaugh.&nbsp;\n\r\n\r&nbsp;","Vector","scr\\CVIPlibraries/Vector.htm","   ACADEMIC COMPUTING  hari  27  175  2004-06-09T20:59:00Z  2010-09-25T22:30:00Z  1  339  1938  SIUE  16  4  2273  11.5606    Clean  Clean    false  false  false                  MicrosoftInternetExplorer4        Welcometo CVIPtools from SIUE Asoftware package for the exploration of computer vision and image processing\n\r\n\r&nbsp;\n\r\n\r&nbsp;\n\r\n\r                                  \n\r\n\r&nbsp;Introduction\n\r\n\rCVIPtoolsis a Windows based software package developed at the Computer Vision and ImageProcessing Laboratory at Southern IllinoisUniversity Edwardsville, under the continuing direction of Dr. Scott EUmbaugh. One of the primary purposes of the CVIPtools development is to allow students, faculty,and other researchers to explore the power of computer processing of digitalimages. \n\r\n\rCVIPtools is a collection ofcomputer imaging tools providing services to the users at four layers: the Cfunction layer, the COM interface layer, the CvipOplayer and the Graphical User Interface (GUI). The C function layer consists ofall image and data processing procedures and functions. The Common Object Module(COM) interface layer implements the COM interface for each higher levelCVIPtools function, primarily the Toolbox functions with a few Toolkitfunctions. The CvipOplayer encapsulates the COM interface functions and provides an ObjectOriented Programming (OOP) approach. The GUI implements the image queue andmanages user input and resultant output. The CVIPtools GUI allows even thecasual computer users to experiment with many of the sophisticated toolsavailable to computer imaging specialists without the need for any knowledge ofcomputer programming.\n\r\n\r                         \n\r\n\r   Edge Detection        Image Segmentation      Local Histogram Eq.       Image Warping      Block Truncation Coding\n\r\n\r                                              \n\r\n\r                                        ","Welcome to CVIPtools","scr\\Cviptools_ HELP.htm","   Yue  Normal  hari  13  369  2010-05-11T17:07:00Z  2010-09-25T22:12:00Z  1  2512  12515  223  83  14944  11.5606        120    Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                                                                  Analysis: Edge/Line Detection\n\r\n\r&nbsp; &nbsp;&nbsp;For All Functions:\n\r&nbsp;    Kirsch, Pyramid, Robinson:\n\r&nbsp; &nbsp; &nbsp;Sobel, Prewitt:\n\r&nbsp; &nbsp; &nbsp;Roberts,Laplacian:\n\r&nbsp; &nbsp; &nbsp;Frei-Chen:\n\r\n\r     Marr Hildreth:\n\r\n\r     Canny:\n\r\n\r     Shen-Castan:\n\r\n\r     Boie-Cox:\n\r&nbsp; &nbsp; &nbsp;Hough:\n\r&nbsp; &nbsp; &nbsp;Edge link:\n\r\n\r     Pratt Merit:\n\r\n\r&nbsp; &nbsp;&nbsp;CercharFilter:\n\r\n\r&nbsp; &nbsp;&nbsp;Harris Filter:\n\r\n\r&nbsp;&nbsp; &nbsp;Moravec Filter:&nbsp; &nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters, press the ‘Apply’ button atlower right to perform the operation. Currently, these functions return animage which contains the magnitude information only. \n\r\n\rThe use of a ‘Pre-filter’ will causethe current image to be processed with the chosen filter before edge detectiontakes place. This is typically some form of a smoothing filter that is used tosmear out high-frequency noise, thereby helping to eliminate false edges causedby noise. \n\r\n\rThe use of a ‘Post Threshold’ valuewill cause the image that results from the edgedetector to have binary thresholding performed on it.If you use the default ‘No post threshold’, you can manually apply thresholding to the resultant image with the ‘Thresholdcurrent image at’ at the bottom of the window or from the ‘Utilities -&gt;Convert’ window. \n\r\n\rNote that the output image from anedge detection operator is of SHORT data type, so may exceed the 0-255 BYTErange. If you use the histogram to select a threshold value, be aware that thehistogram is linearly remapped to BYTE for display. The image data range can befound by using the ‘Utilities-&gt;Stats-&gt;Image data range’ selection. A goodmethod for threshold selection is to start with the midpoint of this range, andthen decrease it until desired results are obtained. \n\r\n\rNote:If the kernel size is selected more than 17, it may exceed the data rangecausing invalid image output. Also, depending upon the image data, very largekernel size may cause CVIPtools to fail.\n\r\n\rBack to Top&nbsp; &nbsp; Kirsch, Pyramid, Robinson:\n\r\n\rSelect a Pre-filter, if desired, from the pop-up menu. Select orenter a Post-threshold value, if desired. The Kirsch and Robinson use 8 masksand will provide similar results, since the Robinson uses a simplified versionof the Kirsch masks. As a result of the specific mask coefficients, theRobinson returns an image with a smaller data range. The Pyramid operator uses2 masks and will return wider edges, since this implementation is based on 7x7masks, and the Kirsch and Robinson are based on 3x3 masks. Kirsch and Robinsonfilters returns magnitude image and direction image. Data range of directionimage is from -3pi/4 to +pi. \n\r\n\rBack to Top&nbsp; &nbsp; Sobel,Prewitt:\n\r\n\rEnter or select from the pop-up menu a kernel size; in general thelarger the kernel size, the wider the resulting edges. That is, the edges appearmore smeared out in the resulting image. Select a Pre-filter, if desired, fromthe pop-up menu. Select or enter a Post-threshold value, if desired. Finally,choose whether or not to keep dc. If the ‘Keep DC’ option is selected, theoutput image will retain more of the original image, not just the edges. Alsothe function returns magnitude image and direction image. Data range ofdirection image is from -pi to +pi.\n\r\n\rBack to Top&nbsp; &nbsp; Roberts, Laplacian:\n\r\n\rSelect which type/mask to use, select the ‘Show Type/Mask’ button tosee them. Select a Pre-filter, if desired, from the pop-up menu. Select orenter a Post-threshold value, if desired. Finally, choose whether or not toKeep DC. If the ‘Keep DC’ option is selected, the output image will retain moreof the original image, not just the edges. Note that the Roberts Type 2 isprobably the fastest edge detector. The Laplacian,unlike the others, retains the sign of the result with the output image (thesign corresponds to the “direction” of the edge). \n\r\n\rBack to Top&nbsp; &nbsp; Frei-Chen:\n\r\n\rFirst select the Frei-Chen subspacedesired: line, edge, max, or min angle. The line and edge subspace selectionsuse the corresponding four line or edge masks as the subspace of interest. Themax selection will select the maximum of the edge or line subspace projections.The ‘min angle’ returns the result from the edge and line projection that hasthe minimum angle between that particular vector (corresponding to the currentpixel) and these two subspaces. The minimum angle corresponds to the closestfit, without consideration of magnitude.      \n\r\n\r&nbsp;    \n\r\n\r&nbsp;      \n\r\n\redge subspace:         \n\r\n\r&nbsp;      \n\r\n\rIf you want to set a threshold on the edge projection, select  ‘Threshold Angle’, then enter or select a value in  degrees. \n\r  If you don’t want to set a threshold on the edge projection, de-select  ‘Threshold Angle’         \n\r\n\rline subspace:         \n\r\n\r&nbsp;      \n\r\n\rIf you want to set a threshold on the line projection, select  ‘Threshold Angle’, then enter or select a value in  degrees.   \n\r\n\rIf you  don’t want to set a threshold on the line projection, select ‘Threshold  Angle’         \n\r\n\rmax[edge/line] or min angle[edge/line]:          \n\r\n\r&nbsp;      \n\r\n\rAngle threshold does not apply.   \n\r\n\rAfter  selecting the projection, select a Pre-filter and/or Post-threshold if  desired, and choose whether or not to keep dc.         \n\r\n\r&nbsp;      \n\r\n\r&nbsp;   \n\r\n\rBack to Top  Marr Hildreth:\n\r\n\rFirst select the desiredvariance for Marr-Hildreth: single variance or doublevariance. Then select or enter the sigma and delta values. If you want to postprocess the image by combining the bands then check the box next to‘Post-Process by Combining Bands’. If you select the Dual Variance then you cansee the intermediate images generated in this process by checking the option‘Show intermediate Images’.  Afterselecting the parameters press the ‘Apply’ button to the lower right to get theedge detected image.\n\r\n\r Back to Top  Canny: \n\r\n\rThe Canny edgedetector is optimal for step edges corrupted by white noise. It requiresselecting and entering three parameters: &quot;High threshold factor&quot;,&quot;Low threshold factor&quot;, and &quot;Variance&quot;. The high thresholdis computed from the image which is greater than 90% of the pixels afterapplying non maxima suppression to the magnitude images. The high threshold ismultiplied with high threshold factor to obtain the final high threshold for hysteresis. The low threshold is computed from the image byaveraging the high threshold and minimum value in the image after applying thenon maxima suppression to the magnitude images. The low threshold is thenmultiplied with the low threshold factor to obtain the final low threshold for hysteresis. The variance refers to the variance of theGaussian filter. If you want to view the intermediate magnitude and direction(phase) images check the box next to ‘Show Intermediate Images’. After settingthe parameters press the ‘Apply’ button to the lower right to get the edgedetected image.\n\r\n\rBack to Top  Shen-Castan: \n\r\n\rThe Shen-Castan edge detector was developed as an optimalsolution to a specific mathematical model. The optimal filter used to smooththe image is the Infinite Symmetric Exponential Filter (ISEF). It requiresselecting and entering five parameters: &quot;High threshold factor&quot;,&quot;Low threshold factor&quot;, &quot;Smoothing factor&quot;, &quot;Windowsize&quot;, and &quot;Thin factor&quot;. The high threshold is computed fromthe image which is greater than 90% of the pixels after applying non maxima suppressionto the magnitude images. The high threshold is multiplied with high thresholdfactor to obtain the final high threshold for hysteresis.The low threshold is computed from the image by averaging the high thresholdand minimum value in the image after applying the non maxima suppression to themagnitude images. The low threshold is then multiplied with the low thresholdfactor to obtain the final low threshold for hysteresis.The input image is convolved with ISEF filter of the selected smoothing factor,to mitigate the noise effects. However the computation is increased by usingrecursive filters. The window size is the size of the window for false zerocrossing suppression, which is used to remove spurious edges. The thin factoris the distance between the final line points which is used to apply thinning.If you want to view the intermediate magnitude and direction (phase) imagescheck the box next to ‘Show Intermediate Images’. After setting the parameterspress the ‘Apply’ button to the lower right to get the edge detected image.     \n\r\n\rBack to Top  Boie-Cox:\n\r\n\rThe Boie-Cox edge detector is a generalizationof Canny algorithm. It requires selecting and enteringfive parameters: &quot;Ordinary threshold&quot;, &quot;hysteresisthreshold&quot;, &quot;Variance&quot;, and &quot;Thinning edge&quot;. The ordinarythreshold is computed by entering the &quot;Threshold factor&quot;. If thethreshold factor is 1, then the mean absolute value of the image is used as thethreshold value. If the threshold factor is not equal to 1, then thresholdvalue is equal to threshold factor * mean absolute value of the image. The hysteresis threshold is computed by entering the &quot;Lowthreshold factor&quot; and the &quot;High Threshold factor&quot;. The highthreshold is computed from the image which is greater than 90% of the pixelsafter applying non maxima suppression to the magnitude images. The highthreshold is multiplied with high threshold factor to obtain the final highthreshold for hysteresis. The low threshold iscomputed from the image by averaging the high threshold and minimum value in theimage after applying the non maxima suppression to the magnitude images. Thelow threshold is then multiplied with the low threshold factor to obtain thefinal low threshold for hysteresis. The variancerefers to the variance of the Gaussian filter. If the thinning edge is notselected, thinning is not performed which implies that the thickness of theedges is not reduced. If thinning edge is selected, thinning is performed. Ifyou want to view the intermediate magnitude and direction (phase) images checkthe box next to ‘Show Intermediate Images’. After setting the parameters pressthe ‘Apply’ button to the lower right to get the edge detected image.     \n\r\n\rBack to Top  Hough:\n\r\n\rThe‘Line Angles’ entry refers to the angle a desired line makes with the column (horizontal)axis in the current image, in a clockwise direction. The range on the angles is0 to 180 degrees. For example, to find a line that runs from the upper-left tothe lower-right corner, enter 45 as the line angle. To find a line that runsfrom the lower-left to the upper-right, enter 135 as the line angle. Note: theangle of the line itself is different from the angle of ‘rho’(the normal to the line). \n\r\n\r You may specify ranges of angles with a dash,such as 45-55, and you must use a blank space as a separator, as in 0 45-50 90.\n\r\n\rAfterentering the line angles, select or enter both theminimum number of pixels that define a line and the maximum connect distance.Note that the “Line Pixels(min)” applies to all pixelson a given line, so they are not necessarily connected. Also, the connectdistance applies to all lines, so this will tend to fill in open places if toolarge a number is selected (see ‘Edge Link’ below). \n\r\n\rNote:the Hough transform is typically applied to an image after edge detection and thresholding have been performed.\n\r\n\rBack to Top &nbsp;Edge Link:\n\r\n\rSelect or enter the maximum ‘Connect distance’, this corresponds tothe maximum ‘open’ area between points that will be filled in. Edge linking isnormally performed on an image after edge detection AND thresholdinghas been performed. Note that this edge linker tends to fill in small open areas, this is due to the fact that it considers ALL linesand not just the ones you think appear in the image.     \n\r\n\rBack to Top  Pratt Merit:\n\r\n\rThisfunction calculates the Pratt’s Figure of Merit of the image. The Pratt FOM, is defined as follows:\n\r\n\r                                          \n\r\n\r&nbsp;\n\r\n\rIN= the maximum of II and IF\n\r\n\rII= the number of ideal edge points in the image\n\r\n\rIF= the number of edge points found by the edge detector\n\r\n\r&#945; = a scaling constant that can be adjustedto adjust the penalty for offset edges\n\r\n\rdi = the distance ofa found edge point to, an ideal edge point\n\r\n\rFor this metric, Fwill be 1 for a perfect edge. Normalizing to the maximum of the ideal and foundedge points guarantees a penalty for smeared edges or missing edge points. Ingeneral, this metric assigns a better rating to smeared edges than to offset ormissing edges. This is done because techniques exist to thin smeared edges, butit is difficult to determine when an edge is missed. The distance, d, can be defined in more than one wayand typically depends on the connectivity definition used. To use, select theideal edge image and the edge detection image from the pop-up menu. Enter orselect the scale factor from the pop-up menu. The scaling factor is the scalingconstant that can be adjusted to adjust the penalty for offset edges. Press the‘Apply’ button to perform the operation. The Pratt’s Figure of Merit appears inthe ‘Result’ box. If the input image has multiple bands, the average Pratt’sFigure of Merit of all bands is shown.\n\r\n\rBack to Top  CercharFilter:\n\r\n\rThis is used to find the edges in the multispectral images. This takes color image as the input.It determines the edges in the color image. After selecting the image pressapply button to perform the operation. The output image is a gray scale image.\n\r\n\rBack to Top  HarrisFilter:\n\r\n\rSelect the function and enter the threshold value,border, alpha and minimum distance. The border value finds out the largestcorners value in the given pixel range. Dmin value isused to find out the corner in the given range. Alpha value is the sensitivityvalue.\n\r\n\rBack to Top    Moravec Filter:\n\r\n\rSelect desired threshold value. This function finds outthe corners in the given image. If the threshold value is high the corners areless. If the threshold value is low the corners determined are high. Afterselecting the desired threshold value, press Apply button. It produces theimage with corners.\n\r\n\rBack to Top\n\r\n\r&nbsp;      ","Edge/Line Detection","scr\\How To Use CVIPtools/Analysis/cvip_ana_edgeline.html","   Yue  skefel  32  112  2003-10-20T04:31:00Z  2010-07-17T21:12:00Z  1  637  3632  30  8  4261  12.00    Clean  Clean  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                              Analysis: Features\n\r\n\rThe feature extraction window requires five parameters: theoriginal image, a segmented image, a feature file name (new or existing), andthe row and column coordinates of a point on the object of interest. The user mayalso provide a class descriptor of the object. \n\r\n\rThe &#8216;Original image&#8217; is selected by holding the CTRL key onthe keyboard with a left-mouse click. The &#8216;Segmented image&#8217; isselected by holding the ALT key on the keyboard with a left-mouse click. Theuser then selects the object with a left-mouse click on the original orsegmented image.\n\r\n\rYou need to press &#8216;Save as&#8217; and save the feature file first.If you select an existing file, you may view the file by pressing the&#8216;View Feature File&#8217; button. If the filename is new, it will becreated as you run the program. The default directory for features files is in&#8216;$CVIPtoolsHOME\\bin\\feature&#8217;, but theuser can specify another location to save the feature file, if desired.\n\r\n\rThe row and column coordinates of the object of interest are enteredmanually or by clicking the mouse on the Original Image to select thecoordinates. If a choice has been made with the mouse on the original image,those coordinates will be used by the program in calculating the objectfeatures.\n\r\n\rSelect features to be extracted by clicking on individual check-boxeswithin any of the five categories. If all features in a category are desired,press the &#8216;Select All&#8217; button, which activates the selectionindicator for each of the buttons it controls. You can deselect all features atone time by pressing &#8216;Deselect All&#8217; if you have previously pressed&#8216;Select All&#8217;. You can also press the &#8216;View LabeledImage&#8217; button to get the labeled image.\n\r\n\rThe BINARY OBJECT and the RST-INVARIANT MOMENT-BASED FEATURES operate onthe binary object from the segmented image. The HISTOGRAM and SPECTRAL FEATURESoperate on the original image data using the segmented image to define theobject. They operate on each band of any multi-band image separately. \n\r\n\rThe TEXTURE FEATURES operate on the original image data, but perform aluminance transform on any color image, before extracting the features. Thefeatures are calculated for four orientations: 0, 45, 90 and 135 degrees; andthen the average of these four and the range are returned. The texturalfeatures are defined in Chapter 6 of ComputerImaging, by Scott E Umbaugh. &nbsp; &nbsp; Three of thefeatures require additional parameters:\n\r\n\rBINARY OBJECT FEATURES-&gt;Projections needs values forheight and width of a normalizing box. The object of interest will be resizedto fit against the upper and left sides of the normalizing box before theprojections are calculated. \n\r\n\rTEXTURE FEATURES requires a value for pixel distance. This is thedistance that is used in calculating the co-occurrence matrix (similar to2nd-order or joint histogram, which approximates the joint probabilitydistribution). This distance defines which pairs of pixels are used todetermine the co-occurrence matrix. A larger distance will define a coarsertexture, while a smaller distance will define a finer texture. Additionally,the user has the option to include pixel pairs containing zeros, with the&#8220;Include Zero Pairs&#8221; check box. \n\r\n\rSPECTRAL FEATURES requires values for numbers of rings and sectors touse. The spectral features use the Fourier transform. \n\r\n\rAfter providing all required parameters and selecting the features toextract, press &#8216;Apply&#8217;. If the feature file name you provide isthat of an existing file, the header information in that file will be checkedto insure you have selected the same features for the new object as for objectsalready listed in the file. If you have not made the same selections, a warningbox will pop up. Once you create a feature file, all additions to it must befor images with the same number of bands, and must have the same featuresselected. Either change your selections for which features to extract to agreewith those listed in the file header, or enter a new name for the feature file.\n\r\n\rNote that, due to how the labeling function works, DO NOT try to extractfeatures from an object of gray level zero. If you do this, it will extract featuresrelating to all pixels with gray level zero, which may not be the connectedobject you want. ","Features","scr\\How To Use CVIPtools/Analysis/cvip_ana_feature.html","   Yue  ACADEMIC COMPUTING  14  50  2003-10-20T03:36:00Z  2004-06-14T20:56:00Z  1  836  4769  39  11  5594  10.3501    Clean  Clean  MicrosoftInternetExplorer4      Analysis: Geometry&nbsp;&nbsp; &nbsp;For All Functions:\n\r&nbsp; &nbsp; &nbsp;Crop:\n\r&nbsp; &nbsp; &nbsp;Paste:\n\r&nbsp; &nbsp; &nbsp;Resize:\n\r&nbsp; &nbsp; &nbsp;Rotate:\n\r&nbsp; &nbsp; &nbsp;Translate:\n\r&nbsp; &nbsp; &nbsp;Zoom:&nbsp; &nbsp; FOR ALLFUNCTIONS:\n\r\n\rAfter setting the desired parameters,press the &#8216;Apply&#8217; button at lower right to perform the operation. \n\r\n\rFor all of the following functions, the current image is automaticallyselected, and can be changed by clicking mouse button 1 on an image in the mainwindow&#8217;s image queue. &nbsp; &nbsp; Crop:\n\r\n\rThe crop function allows you cut a subimage out of the current image and put it in the IMAGEQUEUE. This may be done to select a region of interest (ROI), or to paste apart of one image into another with the following &#8216;Paste&#8217; function.\n\r\n\rTo crop an image, the width, height and upper left coordinates of the subimage can be entered directly in the entry boxes orselected from the pop-up menu. \n\r\n\rAlternately, you can select the crop area by dragging with mouse button 1on the current image with the &#8216;Shift&#8217; key pressed. If youdon&#8217;t like the size of the rectangle, you can make a new one on top ofthe present one. When you are done making a new rectangle the previous one getsdeleted automatically. Note that, although the coordinates are used automaticallywhen you press &#8216;Apply&#8217;, they will not appear in the window untilAFTER the &#8216;Apply&#8217; button has been pressed. \n\r\n\rOnce, the parameters are set as desired, press &#8216;Apply&#8217; in thelower right corner. &nbsp; &nbsp; Paste:\n\r\n\rThis function allows you to paste animage, or subimage, onto another image. The standardmethod will replace the underlying pixel values in the original image with thepasted image. Alternately, this can be done transparently, which adds the twotogether so that the original image is still visible under the pasted image. \n\r\n\rTo select an image to be pasted into the current image you can select thename from the pop-up menu. Next, type in the row and column coordinate of theupper left corner of location in the current image where you desire to pastethe image or select the row and column coordinates from the pop-up menu. Finally,a transparent paste can be selected, if desired. \n\r\n\rOnce, the parameters are set as desired, press &#8216;Apply&#8217; in thelower right corner. &nbsp; &nbsp; Resize:\n\r\n\rWith the resize function you can enlargeor shrink an image. Additionally, you can spatially distort an image byenlarging it in one dimension and shrinking it in the other dimension. Thedesired new dimensions in height and width are entered into the entry boxes orselected from the pop-up menu. Once, the parameters are set as desired, press&#8216;Apply&#8217; in the lower right corner. &nbsp; &nbsp; Rotate:\n\r\n\rThis function will rotate an image andplace the result within a black rectangle large enough to contain the entirerotated image. \n\r\n\rTo perform a rotation, enter or select a float or integer value for thenumber of degrees of rotation. A positive number will rotate the imageclockwise, and a negative number will rotate counterclockwise. Once, theparameters are set as desired, press &#8216;Apply&#8217; in the lower rightcorner. \n\r\n\rNote that this function will handle complex images, for example, an fft spectrum. &nbsp; &nbsp; Translate:\n\r\n\rThis function will shift an image left orright, and up or down. It allows for wrapping the shifted areas onto theopposite side of the image or to let the portions shifted out be filled withspecific gray level values. \n\r\n\rTo perform a translation, select the directions and enter the desiredamounts. Then select the method of dealing with parts of the image uncovered bythe translation. &#8216;Wrap the image...&#8217; will cause those parts of theimage that move beyond an edge to reappear at the opposite edge; the entireimage will still be present, but will be rearranged. &#8216;Fill thearea...&#8217; will cause areas left behind by moving the image to be filledwith a uniform gray value you enter. Once, the parameters are set as desired,press &#8216;Apply&#8217; in the lower right corner. &nbsp; &nbsp; Zoom:\n\r\n\rThis function performs a zoom operationand can also be used to enlarge an image by zoomingthe entire image. Two methods are available for the zooming: zero-order orlinear interpolation. In general, the linear interpolation method will providemore visually pleasing results, but will take longer to perform. The zero-ordermethod will result in blocky effects, but is faster and does not &#8220;createdata&#8221; - the linear interpolation method &#8220;creates data&#8221; viainterpolation, which is undesirable in some applications. \n\r\n\rTo zoom in on an image quadrant, choose the quadrant of the image toexpand. Then enter a factor by which to expand the quadrant. If you want to zoom an area other than a fixed quadrant, first select&#8216;the area beginning from...&#8217; button. You then choose the area tozoom by entering or selecting the upper left row and column coordinates and theheight and width values into the entry boxes. \n\r\n\rAlternately, you can select the area to zoom by dragging with mousebutton 1 on the current image while keeping the &#8216;Shift&#8217; key pressed.If you don&#8217;t like the size of the rectangle you can redraw a new one onthe first one. Note that, although the coordinates are used automatically whenyou press &#8216;Apply&#8217;, they will not appear in the window until AFTERthe &#8216;Apply&#8217; button has been pressed. \n\r\n\rNext, enter the factor by which you want to expand the image in the windowlabeled &#8216;By&#8217;. Next, select &#8216;zero order&#8217; or &#8216;linearinterpolation&#8217; for the method in the window labeled &#8216;pixels&#8217;.Once, the parameters are set as desired, press &#8216;Apply&#8217; in the lowerright corner. ","Geometry","scr\\How To Use CVIPtools/Analysis/cvip_ana_geometry.html","   Scott  ACADEMIC COMPUTING  7  144  2005-12-02T05:00:00Z  2006-01-12T00:47:00Z  1  451  2576  21  6  3021  10.3501    Clean  Clean  MicrosoftInternetExplorer4    false  false  false         Analysis: Pattern Classification\n\r\n\rThe pattern classification window allows the user to selecta data normalization method, a distance or similarity measure for feature vector comparison, and one of threebasic classification algorithms. The pattern classification window requires twofeature files created with Analysis-&gt;Features.One is used for the training set and one is used for the test set. The useralso specifies the name of an output file which will contain the patternclassification results.\n\r\n\r&nbsp;\n\r\n\rData normalization\n\r\n\rFor min-max and softmax&nbsp; normalization,the user enters the necessary parameters for normalization. If required, thetraining set is used to determine any other parameters needed for datanormalization. These same parameters are then applied to the test set. For outof range cases in the test set, the values are clipped to the low or high endof the range.\n\r\n\r&nbsp;\n\r\n\rDistance and Similarity Measures\n\r\n\rThe user selects the distance or similarity measure to be used for thepattern classification. This metric is then used to compare feature vectors inthe test set to the training set.\n\r\n\r&nbsp;\n\r\n\rClassification Methods\n\r\n\rThe user can select: 1) Nearestneighbor &#8211; the feature vector(s) to be classified from the test setare compared to all vectors in the training set using the selecteddistance/similarity measure and classified as the one to which it is closest,2) K-Nearest neighbor &#8211; thefeature vector(s) to be classified from the test set are compared to allvectors in the training set using the selected distance/similarity measure andclassified as the majority class in the nearest K feature vectors (K isan integer selected by the user), or 3) Nearestcentroid &#8211; the feature vector(s) to beclassified from the test set are compared to the centroid(average) vectors for each class in the training set using the selecteddistance/similarity measure and classified as the one to which it is closest.\n\r\n\r&nbsp;\n\r\n\rOutput&nbsp; file\n\r\n\rThe output file is a text file containing: 1) CVIPtools feature file header,2) Pattern classification header, which contains fields for: Classification Algorithm, DataNormalization, Distance Measure, Test Set File name, Training Set File name, NormalizedTraining Set File name, NormalizedTest Set File name, Output Filename, and the following information for each feature vector: 1)&nbsp; Image Name in Test Set,&nbsp; 2) Object\'s row coordinate in Test Set,3) Object\'s column coordinate in Test Set, 4) Class in Test Set, 5) Class inTraining Set, 6) Value of Distance or Similarity Measure.\n\r\n\rThe last section in the output file contains statistics for the testresults. A table of success rates for each class, as well as how themisclassified feature vectors were classified is given. \n\r\n\r&nbsp;\n\r\n\rNote\n\r\n\r1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The C functions for Pattern Classification routines areincluded in the &#8220;feature&#8221; library.\n\r\n\r2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In the Nearest Neighbor method and the K-NearestNeighbor method, if the distance/similarity measure for the classes is found tobe equal, then the last class encountered with that distance measure is considered.\n\r\n\r&nbsp;&nbsp;","Pattern Classification","scr\\How To Use CVIPtools/Analysis/cvip_ana_pattern_classification.html","   Iris Cheng  jhansi  39  53  2003-10-20T16:24:00Z  2009-07-07T20:30:00Z  2  887  5060  Westar  42  11  5936  12.00    120  Clean  Clean  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                              Analysis: Transforms\n\r\n\rForAll Functions:\n\rDCT, FFT, Haar,Walsh, Hadamard:\n\rWavelet:\n\rFilters\n\rLow Pass, High Pass:\n\rBand Pass, Band Reject:\n\rHigh frequency emphasis:\n\rNotch:\n\r\n\rExtractFFT Phase Only Image:\n\r\n\rExtractFFT Magnitude Only Image:&nbsp;&nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters, pressthe ‘Apply’ button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed by clickingmouse button 1 on an image in the main window’s image queue. \n\r\n\rNote that using any of the filters requires a transform to be performedfirst. Then select the transform image in the queue for filtering. The inversetransform will be performed automatically. &nbsp; &nbsp; DCT, FFT, HAAR, WALSH, HADAMARD:\n\r\n\rSelect Forward or Inverse for the direction ofthe transform. For a forward transform, select the blocksizefrom the menu. All of the transform algorithms used in CVIPtools are fastalgorithms, which require power-of-2 blocksizes. Anyimage that has non-power-of-2 dimensions will be padded with zeros as required.\n\r\n\rThe inverse transform will only succeed on an image that previously had aforward transform performed upon it. The blocksizeused during the forward transform is automatically found and used for theinverse operation. \n\r\n\rNote that Walsh and Hadamard use the sametransform kernels, or basis images, but with different ordering. The Walsh is sequency-ordered; Hadamard usesnatural ordering. Thus, any filtering performed on a Hadamardspectrum will yield interesting, but probably not useful, results. \n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; WAVELET:\n\r\n\rSelect Forward or Inverse for the direction ofthe transform. For the forward transform, select the Basis functions to use andthe number of decompositions to perform. One decomposition will yield a 4-band result, two will yield a 7-band result, according to: \n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# ofbands in result = 3*(# of decompositions) + 1 \n\r\n\rThe inverse transform will only succeed on an image that previously had theforward transform performed upon it. The number of decompositions used duringthe forward transform is automatically used for the inverse operation. &nbsp;&nbsp; FILTERS\n\r\n\rThe following functions are transform-domainfilters which operate on a frequency, sequency orwavelet images (transform output). When used, the resulting filtered spectrumis displayed, and the inverse transform is performed on the filtered spectrumto display the resultant image. Note that the filters assume DCT-type symmetryon wavelet transform images; this may not yield the expected results. &nbsp;&nbsp; Low Pass, High Pass:\n\r\n\rLowpass filteringwill tend to blur an image, and highpass filteringwill tend to extract details and edges. Enter or select a cutoff frequency forthe filter, from 1 to (blocksize - 1). You will keepthe ‘DC’ component during filtering if the square on the left side of the ‘KeepDC’ button is checked; you will discard ‘DC’ if the square is blank. Finally,select a filter type. If your choice is Butterworth, select a filter order fromthe menu. &nbsp; &nbsp; Band Pass, Band Reject:\n\r\n\rThese filters will have varying results basedon the selection of the cutoff frequencies. To use them, enter or select lowand high cutoff frequencies for the filter, from 1 to (blocksize- 1). The value for high cutoff must be larger than the low cutoff frequency.You will keep the DC component during filtering if the square on the left sideof the ‘Keep DC’ button is checked; you will discard ‘DC’ if the square islight. Finally, select a filter type. If your choice is Butterworth, select afilter order from the menu. &nbsp; &nbsp; High frequency emphasis:\n\r\n\rThis filter is used to enhance image detailsby boosting high frequency information. The ‘Cutoff Frequency’ is the cutofffor the highpass filter and the ‘Emphasis offset’determines the amount of the original image that is retained by setting thegain for the low frequencies in the cutoff region. To use, enter or select acutoff frequency for the filter, from 1 to (blocksize- 1). You will keep the DC component during filtering if the square on the leftside of the ‘Keep DC’ button is checked; you will discard DC if the square isblank. Enter an emphasis offset value or select one from the menu. Finally,select a filter order from the menu. &nbsp;&nbsp; Notch:\n\r\n\rNotch is a function to perform selectivefiltering on a user-defined area of an image or spectrum. It is often appliedto frequency domain (FFT) images to eliminate regular sinusoidal interference. \n\r\n\rThis filter cuts out a square with side length entered as the notch ‘Size’,centered at coordinates listed as ‘Row’ and ‘Column’. &nbsp; &nbsp; Enter the rowand column coordinates and size for the filter by one of two ways:\n\r\n\r1) Backspace over the existing value and enter a new value from thekeyboard. \n\r\n\r2) Select a value from the pop-up menu for ‘Size’.\n\r\n\rFor notching multiple spectral areas, use the notch filter in Restoration-&gt;Frequencyfilters. &nbsp;&nbsp; Extract FFT Phase Only Image:\n\r\n\rSelect a complex image, such as an FFTspectral image. This button will set the magnitude equal to a constant,retaining the phase information, and then perform the inverse FFT transform.This allows you to see the information contained in phase-only.     Extract FFT Magnitude Only Image:&nbsp;&nbsp; \n\r\n\rSelect a complex image, such as an FFT spectral image. Thisbutton will set the phase equal to zero, retaining the magnitude information,and then perform the inverse FFT transform. This allows you to see theinformation contained in magnitude-only. \n\r\n\r&nbsp;","Transforms","scr\\How To Use CVIPtools/Analysis/cvip_ana_transforms.html","   Yue  Normal  Mounika  35  87  2004-06-14T23:27:00Z  2010-04-30T15:47:00Z  1  1939  11055  92  25  12969  11.5606    BestFit    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                             Analysis: Segmentation\n\r\n\rForAll Functions:\n\r\n\rAutoThreshold Segmentation:\n\rFuzzy C Mean:\n\rGray Level Quantization:\n\rHistogram Thresholding:\n\r\n\rOTSUThresholding:\n\rMedian Cut:\n\rPCT/Median:\n\rSCT/Center:\n\rMulti Resolution:\n\rSplit and Merge:\n\r\n\rWatershed Segmentation:\n\rMorphological Filtering:\n\r\n\rHit or MissTransform:\n\r\n\rThinning:\n\r\n\rSkeletonization:&nbsp; &nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters,press the ‘Apply’ button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed byclicking mouse button 1 on an image in the main window’s image queue. \n\r\n\rSelect a segmentation method by clicking on the button to the left of thedesired function, then change the default values as desired. These values canbe entered directly from the keyboard into the entry box, or selected from thepop-up menu that appears when the downward pointing arrow is selected. \n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   Auto Threshold Segment:\n\r\n\rTo use, select a value from the pop-up menu or enter a value fromkeyboard for the limit. Usually the limit value is the small value (typically 0to 20.0). This algorithm performs the automatic threshold of the image. Thethreshold value depends on the limit. If the limit value is less, the thresholdvalue is good.&nbsp; &nbsp; Fuzzy C Mean:\n\r\n\rTo use, select a value from the pop-upmenu or enter a value from keyboard (typically 0  20.0) for the Gaussian kernel variance. Ingeneral, the larger the number, the coarser the segmentation, with fewer graylevels. \n\r\n\rNote: If the input image is a gray level image, this function will createa 3-band (RGB) image by copying the gray image into each of the three bands. &nbsp; &nbsp; Gray Level Quantization:\n\r\n\rSelect the desired number of gray levelsfrom the pop-up menu, or type directly into the entry box. The number must be apower of 2. Select Standard or IGS quantization. IGS minimizes false contouringthat can occur in areas that appear to be uniform, but also adds a ditheredeffect to the image which may not be desired for segmentation. If IGS isselected, it is recommended that morphological filtering is performed, forexample erosion, before using the segmented image for feature extraction. &nbsp; &nbsp; Histogram Thresholding:\n\r\n\rNo parameters to enter. The algorithmdetermines the number of ‘good’ peaks in the histogram to use for thesegmentation.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    Otsu Thresholding:\n\r\n\r           No parameters to enter.The algorithm determines the number of ‘good’ threshold value to use for thesegmentation.&nbsp;&nbsp;&nbsp; &nbsp; Median Cut:\n\r\n\rTo use, select a value from the pop-up menuor enter a value from keyboard for the desired number of colors. This algorithmis based on an algorithm originally developed to map 24-bit color images to8-bit color. It works by finding the maximum spread along the red, green orblue axes, and then dividing the color space with the median value along thataxis. This division of the color space continues until the number of desiredcolors is reached. At this point, all the color vectors in a given subdivisionof the color space are used to find an average color for that subdivision.After all the average colors are found, the algorithm goes back and maps eachof the original color vectors to the closest one. &nbsp; &nbsp; PCT/Median:\n\r\n\rTo use, select a value from the pop-upmenu or enter a value from keyboard for the desired number of colors. Thisalgorithm performs the Principal Components Transform on the 3-D color space,and then performs the Median Cut described above. &nbsp; &nbsp; SCT/Center:\n\r\n\rTo use, select values from the pop-upmenus or enter values from keyboard for the desired number of colors along theA and B axis. The algorithm performs the Spherical Coordinate Transform, anddivides the color space by splitting the 2-D space created by angles A and B.This division is done by a simple center split - that is, evenly divided alongeach angle axis based on the numbers specified. Note that only the subspacecontained in the image is used (this means the maximums and minimums are foundalong each axis and these limit the subspace used for the division). After thisis done, the average is found for each color in each subdivision, and theoriginal color vectors are mapped to these. &nbsp; &nbsp; Multi_Resolution:\n\r\n\rMulti_resolution is similar to the ‘Split andMerge’ (below), with entry level fixed at a value of zero. This starts theprocess with the entire image as the initial region. Hit or Miss\n\r\n\rTo use this, select the desired matrix size by selecting the radiobutton. The mask window will pop up on the screen. The default mask values willbe shown in the grid. Enter the desired filter values from the key board in thegrid. The grid mainly contains 0’s, 1’s and x’s. x’s are nothing but don’tcare’s which can be either 0 or 1. Press the enter button in the grid or in thesegmentation window. This function works only on binary images. Thinning\n\r\n\rTo use this, select the desired matrix size by selecting the radiobutton. The mask window will pop up on the screen. The default mask values willbe shown in the grid. Enter the desired filter values from the key board in thegrid. The grid mainly contains 0’s, 1’s and x’s. x’s are nothing but don’tcare’s which can be either 0 or 1. Press the enter button in the grid or in thesegmentation window. This function works only on binary images. Skeletonization\n\r\n\rTo use this, select the desired matrix size by selecting the radiobutton. The mask window will pop up on the screen. The default mask values willbe shown in the grid. Enter the desired filter values from the key board in thegrid. The grid mainly contains 0’s, 1’s and x’s. x’s are nothing but don’tcare’s which can be either 0 or 1. Select the number of iteration to beperformed on the input image by selecting the desired value from the drop downbox. Select the connectivity from the drop down list and select the desiredmethod from the method drop down list. Press the enter button in the grid or inthe segmentation window. This function works only on binary images.&nbsp; &nbsp; Splitand Merge:\n\r\n\rAll selections require an ‘Entry level’parameter; the lower the entry level, the larger the initial region. \n\r\n\rThere are six tests for homogeneity. The tests and theirrequired parameters are:     \n\r\n\r&nbsp;                 \n\r\n\r1)             \n\r\n\rPure Uniformity: region considered homogeneous if    completely uniform, i.e. all the pixels have the same gray value. No extra    parameters required.                   \n\r\n\r2)             \n\r\n\rLocal Mean vs. Global Mean: region is considered    homogeneous if the local mean is greater than the global mean. No extra    parameters required.                   \n\r\n\r3)             \n\r\n\rLocal Standard Deviation vs. Global Mean: region is    considered homogeneous if the local standard deviation is less than 10% of    the global mean. No extra parameters required.                   \n\r\n\r4)             \n\r\n\rVariance test: region is considered homogeneous if at    least a given percentage of the pixels are within 2 sigma of the local    mean, unless the standard deviation exceeds a maximum threshold.     \n\r\n\rParameters:                      \n\r\n\r-Percentage (in decimal format; typically .70-.98)                             \n\r\n\r&nbsp;                  \n\r\n\rthe percentage of pixels in a region that must be      within 2 standard deviations of the mean for the region to be homogeneous                                  \n\r\n\r-Threshold                             \n\r\n\r&nbsp;                  \n\r\n\rmaximum allowed value for standard deviation; if      exceeded, area is non-homogeneous                    \n\r\n\r                  \n\r\n\r5)             \n\r\n\rWeighted gray level distance: region is considered    homogeneous if a computed value is less than the chosen threshold. The    weighted gray level value is found:            \n\r\n\r   &nbsp;&nbsp;&nbsp;&nbsp;                                                              \n\r\n\rwhereGi is a gray level in theregion, and Mode is the most frequentgray level in the region. \n\r\n\rParameter:      \n\r\n\r-Threshold         \n\r\n\r&nbsp;      \n\r\n\rmaximum value for weighted gray level value         \n\r\n\r&nbsp;      \n\r\n\r&nbsp;   \n\r\n\r&nbsp;     \n\r\n\r6)       \n\r\n\rTexture homogeneity: A region is divided into 4 equal-sized  sections called quadrants. A region is considered homogeneous if computed  texture features of all quadrants of the region are within the given  similarity measure. The features used are: energy (also called angular second  moment or ASM), inertia, correlation, inverse difference, and entropy. The  five features are calculated for four orientations: 0, 45, 90 and 135  degrees, and then the average of the results from these four orientations are  used. The textural features and similarity measure are defined in Pattern  Recognition Engineering, Nadler and Smith, Wiley, 1993, pp.262-270.   \n\r\n\rParameters:              \n\r\n\r-Similarity                   \n\r\n\r&nbsp;            \n\r\n\rmaximum allowable value for similarity of quadrants of    the region.                   \n\r\n\r-Pixel Distance (usually 1 or 2)                   \n\r\n\r&nbsp;            \n\r\n\rdistance between pixels, used in finding GLDM (Gray    Level Dependence Matrix), a matrix used in texture feature determination     \n\r\n\rNOTE: Texture homogeneity test is EXTREMELY SLOW.            \n\r\n\r   \n\r\n\r&nbsp;     \n\r\n\rPCT option:         \n\r\n\r&nbsp;      \n\r\n\rIf the image being segmented is color, user may elect to  perform a Principal Components Transform (PCT) on the image before  segmentation is run. A PCT will be performed if the square on the left side  of the ‘PCT’ is checked; no PCT is performed if the square is blank.   \n\r\n\rNote: If you have selected a color image for Split and Merge or Multi_Resolution  segmentation and the PCT button is not available, reselect your segmentation  method to activate the button. \n\r  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     Watershed Segmentation:&nbsp; &nbsp;The watershedsegmentation algorithm as implemented in CVIPtools was initially designed toseparate a single object from the background in color images. It provides theuser with two parameters – merge and threshold. The merge parameter has acheckbox, to merge or not to merge. If merge is selected, the thresholdparameter determines the amount of merging that will occur. The thresholdparameter works by creating a histogram using the average gray value withineach watershed segment. Next, it finds the maximum value in the histogram andmerges this group with adjacent lower and higher gray levels, until thethreshold is reached. The threshold represents the percent of total area in theimage. To use, select or deselect the ‘Merge Result’ option. If the MergeResult option is selected then select or enter the threshold value. Then pressthe ‘Apply’ button to the lower right to perform the operation.&nbsp;Morphological Filtering:     \n\r\n\rClosing, Opening, Erosion,  Dilation functions:         \n\r\n\r&nbsp;      \n\r\n\rThese functions are normally used on images that have undergone  segmentation, but can be used on original images for various filtering  effects. They will work on binary, gray-level, and color images. They work on  multi-band (color) images by treating each individual band as a gray-level  image. With gray-level images, the brighter of two adjacent objects is  assumed to be the &quot;object&quot; for morphological purposes.   \n\r\n\rTo use, select a kernel type from the pop-up menu. Parameters for kernel  type:         \n\r\n\rcircle:         \n\r\n\r&nbsp;      \n\r\n\renter kernel size from keyboard or select from the pop-up  menu         \n\r\n\rsquare:         \n\r\n\r&nbsp;      \n\r\n\renter kernel size from keyboard or select from the pop-up  menu; enter length of side from keyboard or select from pop-up menu         \n\r\n\rrectangle:         \n\r\n\r&nbsp;      \n\r\n\renter kernel size from keyboard or select from the pop-up  menu; enter height, width from keyboard or select from pop-up menu         \n\r\n\rcross:         \n\r\n\r&nbsp;      \n\r\n\renter kernel size from keyboard or select from the pop-up  menu; enter thickness (of each arm of cross) and (overall) cross size from  keyboard or select from pop-up menu         \n\r\n\rIterative Modification function:         \n\r\n\r&nbsp;      \n\r\n\rFor binary images only. A binary image can be created from  any image by using the button at the bottom of the Analysis-&gt;Edge/Line detection  window, or by using Utilities-&gt;Convert-&gt;Binary threshold.   \n\r\n\rParameters:         \n\r\n\r-Rotation (y/n)         \n\r\n\r&nbsp;      \n\r\n\rConsider all rotations of the surrounds, or only their  initial rotation shown with the View Surrounds button.        \n\r\n\r-Boolean         \n\r\n\r&nbsp;      \n\r\n\rSelect the desired expression from the pop-up menu for the  binary operation to be performed. Note that ‘a’ is true only if the pixel’s  surround is in the set selected, and ‘b’ is the current pixel value.         \n\r\n\r-iteration         \n\r\n\r&nbsp;      \n\r\n\rSelect the desired number of iterations from the pop-up  menu or type directly into the entry box. Selecting Infinite performs the function until no further change is  detected.        \n\r\n\r-sub fields         \n\r\n\r&nbsp;      \n\r\n\rType the desired number of subfields directly into the  entry box. Must be 1, 2, or 3. This divides the image into subfields that are  operated on sequentially. When 1 is selected the operation is performed on  the entire image in (simulated) parallel during each iteration.         \n\r\n\r-surrounds         \n\r\n\r&nbsp;      \n\r\n\rCheck the box for each surround that you want applied to  the image. You can see the surrounds by pressing the ‘View Surrounds’ button.     &nbsp;","Segmentation","scr\\How To Use CVIPtools/Analysis/cvip_segmentation.html","   Yue  skefel  14  26  2003-10-20T03:43:00Z  2010-01-06T20:00:00Z  1  477  2725  22  6  3196  11.9999    Clean  Clean    false  false  false  MicrosoftInternetExplorer4        Compression: Lossless\n\r\n\rLossless compression must be used when youcannot afford to lose any of the original data. The decompressed image and theoriginal image will be identical. Typically, compression ratios are small (twoto three at the most), and often less than one (no compression, the file gotbigger). The algorithms here are often used as the final step in a more complexcompression algorithm. \n\r\n\r&nbsp;\n\r\n\rFor All Functions: \n\rHuffman, Ziv-Lempel:\n\rDPC:\n\r\n\rBitplane RLC:\n\r\n\rJPEG2000:&nbsp; &nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters,press the &#8216;Apply&#8217; button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed byclicking mouse button 1 on an image in the main window&#8217;s image queue. \n\r\n\rAfter compression, you may save either the decompressed image or thecompressed data file by pressing the appropriate button. If the compressed fileis saved, it will automatically be decompressed when loaded back into CVIPtools. \n\r\n\rThe second type of save is the &#8216;Save&#8217; option under the&#8216;File&#8217; selection on the main menu bar. This option saves the imagein the file type you select. To use this file-converting save, highlight animage in the image queue or just click on it and then select the&#8216;File-&gt;Save&#8217; option from the menu bar. This will allow you tosave the compressed image in your desired image type from the &#8216;Save astype&#8217; pop-up menu.&nbsp; &nbsp; Huffman, Ziv-Lempel:\n\r\n\rThese are both standard lossless compressionmethods. Typically resulting in about 10% compression, that is a compressionratio of about 1.1. &nbsp; &nbsp; DPC:\n\r\n\rDifferential predictive coding takesadvantage of the fact that adjacent pixels in an image are highly correlated(have similar values). Thus, we can predict the next value based on theprevious value(s), and then all we need to compress is the error signal. Theerror signal is the difference between the predicted value and the actualvalue. The prediction equation used is based on a weighted sum of the previousvalue and the global mean for the image. The correlation coefficient providesthe weighting for the previous value, and (1 minus the correlation coefficient)is the weight for the global mean. Values around 0.9 are typical correlation coefficientsfor images. \n\r\n\rTo use, enter or select the &#8216;Correlation&#8217; (coefficient) fromthe pop-up menu and select from pop-up menus the scan direction and number ofbits. The scan direction determines if the prediction will be done along thehorizontal or vertical direction, and the number of bits determines how manybits are used in the error signal encoding. For lossless compression, a shiftcode is used. &nbsp;&nbsp;&nbsp;&nbsp; Bitplane RLC:\n\r\n\rPerforms run length coding on each bit plane individually.Preprocessing with binary to gray code will improve compression; remember to postprocess with gray to binary code to recover the imageafter decompression. Although you can select to retain only certain bits, keepin mind if you do not keep them, all the result is actually lossycompression.&nbsp;&nbsp;&nbsp;&nbsp; JPEG2000:\n\r\n\rPerforms lossless JPEG2000 compression to the inputimage. \n\r\n\r&nbsp;","Lossless","scr\\How To Use CVIPtools/Compression/cvip_cmprs_lossless.html","   Yue  skefel  8  242  2010-01-06T19:49:00Z  2010-05-11T18:57:00Z  4  2266  12918  107  30  15154  12.00    200  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                               Compression: Lossy\n\r\n\rLossy compression methods work byeliminating information in an image that is not visually necessary. Theoriginal image cannot be EXACTLY recovered from the compressed image, although witha good method the results will look very much like the original. There will bea tradeoff between the amount of compression and the resultant image quality. \n\r\n\rFor All Functions:\n\rBTC:\n\rMultilevel BTC, Predictive Multilevel BTC:\n\rJPEG:\n\r\n\rBit-plane Run Length Coding:\n\rDynamic Window-based Run Length Coding:\n\rDPC:\n\rZonal:\n\rFractal:\n\rVector Quantization:\n\rXVQ:\n\rTransform Compression:\n\r\n\rJPEG2000:&nbsp; &nbsp; FORALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters,press the &#8216;Apply&#8217; button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected and can be changed byclicking mouse button 1 on an image in the main window&#8217;s image queue. \n\r\n\rAfter compression, you may save either the decompressed image or thecompressed data file. If the compressed file is saved, it will automatically bedecompressed when loaded back into CVIPtools. \n\r\n\rThe second type of save is the &#8216;Save&#8217; option under the&#8216;File&#8217; selection on the main menu bar. This option saves the imagein the file type you select. To use this file-converting save, highlight animage in the image queue or just click on it and then select the&#8216;File-&gt;Save&#8217; option from the menu bar. This will allow you tosave the compressed image in your desired image type from the &#8216;Save astype&#8217; pop-up menu.\n\r\n\r&nbsp;&nbsp;BTC:\n\r\n\rBlock truncation coding works by replacinga subimage (block) with two gray values (two-level block truncation) and abitstring to identify which pixel in each block gets which gray level. To use,select the desired block size. In general, the larger the blocksize the higherthe compression ratio and the lower the image quality. &nbsp; &nbsp; Multilevel BTC,Predictive Multilevel BTC:\n\r\n\rThese both use a four-level block codingmethod, but the predictive algorithm adds another level of complexity.Algorithmic details can be found in: \n\r\n\r&#8220;Multilevel Block Truncation Coding Using a Minimax Error Criterionfor High-Fidelity Compression of Digital Images.&#8221;, Yiyan Wu and David C.Coll, IEEE TRANSACTIONS ON COMMUNICATIONS. Vol.41, No.8, AUGUST 1993 \n\r\n\rTo use, enter or select from the pop-up menu the blocksize. &nbsp;&nbsp; JPEG\n\r\n\rJPEG stands for Joint Photographic ExpertsGroup and is a standard method for image compression. This code is based on theIndependent JPEG Groups software. The &#8216;Quality&#8217; controls the amountof compression as well as the quality of the decompressed image. If&#8216;Smooth&#8217; is selected, this will be applied when the image isdecompressed to help mitigate the blocky effects that occur with this algorithmat low quality settings. If &#8216;Grayscale&#8217; is selected with a colorimage, the resulting image will be gray, not color. The quantization table(s)can be selected with the popup menu, and can be modified with the&#8216;View...Table&#8217; buttons. The default tables are the standard tables,and the &#8216;Nonquant&#8217; selection will result in nearly losslesscompression. The chrominance and luminance tables keep using the modifiedtables, even if you select the default option for the &#8216;Quant.Table&#8217;. Click the &#8216;Save&#8217; button to save the table and use themodified table property.&nbsp; &nbsp; Bit-plane Run Length Coding:\n\r\n\rTo use, select the bits that you want to retain. Thealgorithm decomposes image into eight binary bit-planes each corresponding toeach bit position in an eight-bit binary.&nbsp; &nbsp;Dynamic Window-Based Run Length Coding:\n\r\n\rTo use, enter or select from the pop-upmenu the window size, which determines the gray level range considered&#8220;constant&#8221; for the run length coding. Algorithmic details can befound in: \n\r\n\r&#8220;A Dynamic Window-Based Runlength Coding Algorithm Applied toGray-Level Images&#8221;, M. Kumaran, S.E Umbaugh, GRAPHICAL MODELS AND IMAGEPROCESSING, Vol. 57, No. 4, July 1995, pp. 267-282. &nbsp;&nbsp; DPC:\n\r\n\rDifferential predictive coding takes advantageof the fact that adjacent pixels in an image are highly correlated (havesimilar values). Thus, we can predict the next value based on the previousvalue(s), and then all we need to compress is the error signal. The errorsignal is the difference between the predicted value and the actual value. Theprediction equation used is based on a weighted sum of the previous value andthe global mean for the image. The correlation coefficient provides theweighting for the previous value, and (1 minus the correlation coefficient) isthe weight for the global mean. Values around 0.9 are typical correlationcoefficients for images. \n\r\n\rTo use, enter or select the &#8216;Correlation&#8217; (coefficient) fromthe pop-up menu, and select from the pop-up menus the scan direction and numberof bits. Since a one-dimensional predictor is used, it can be done in eitherthe horizontal or vertical direction. The number of bits determines how manybits are used for the encoding. Select the encoding method from the pop-upmenu; &#8216;Reconstr. with Lloyd-Max Quantizers&#8217; needs a standarddeviation to be entered or selected from the pop-up menu. In general, the bestresults will be obtained with this method by selecting the largest standarddeviation possible that does not cause artifacts to appear in the resultantimage. &nbsp;&nbsp; Zonal:\n\r\n\rZonal compression is transform domainbased compression. After the transform is performed, only selected&#8220;zones&#8221; in the transform domain are selected for compression, andthe other transform coefficients are eliminated. The retained coefficients arelinearly quantized to byte-sized data (0-255), and the linear mapping valuesfor each block are retained for the decompression process. \n\r\n\rTo use, enter or select from pop-up menus the &#8216;CompressionRatio&#8217;, &#8216;transform&#8217;, &#8216;Mask shape&#8217; and&#8216;Blocksize&#8217;. The compression ratio in conjunction with the masktype is used to determine which transform coefficients are retained. With arelatively large blocksize, the compression ratio you set will be close to whatyou actually get. With a small blocksize the actual compression ratio will besmaller than the setting, due to the overhead involved with each block.Selection of &#8216;DC quantize&#8217; will include the DC term with the linearremapping to BYTE of all retained frequency terms; deselection of DC quantizewill retain the DC-coefficient as a FLOAT, and only remap the other retainedfrequency terms to BYTE types.&nbsp; &nbsp;&nbsp; Fractal:\n\r\n\rFractal compression utilizes the propertyof self similarity in images. The natural images are such that a portion of theimage is always an affine transformation of some other portion of the image.The fractal compression method in CVIPtools uses the quadtree scheme topartition the image into subimages and each of the subimage is compared to thedomains(which also are subimages) and the resulting mapping equations arestored in the compressed file. A quadtree scheme is a representation of animage in which each node, corresponding to a square portion of the image,contains four subnodes, corresponding to the four quadrants of the square. Theroot of the tree is the initial image. The decompression algorithm is aniterative process which utilizes the stored mapping in the compressed file togenerate the decompressed image. \n\r\n\rTo use, enter or select from pop-up menus tolerance, recursion size min.,recursion size max. and domain pool type. The tolerance is a real value whichis a loose target for the final rms error of the encoded image. Lower valuesresult in better looking encoded images which have a lower compression ratio. \n\r\n\rThe recursion size min. is the minimum number of times that the largestsquare sub-image will be recursively partitioned. Using larger values willresult in higher compression ratios when the file is easy to encode. Using arecursion size min. of 2 for a 256x256 image means that the image will bepartitioned at least twice, so we would look for mapping starting from 64x64subimage. \n\r\n\rThe recursion size max. is the maximum number of times that the largestsquare sub-image will be recursively partitioned. Using larger values will helpencode the fine detail in the image at the cost of lower compression ratios. \n\r\n\rThe domain pool type selects a method for determining the domain poolwith which the range is compared to get the resultant mapping. The domain pooltype 0 gives fast results while the results get slower with higher values forthe domain pool. The domain pool type 2 takes an exceptionally long time. Whenyou check the slower encoding button, the algorithm takes a very long time, butthe resulting image looks better and has a higher compression ratio. So thechoice of the parameters would very much depend upon the application. Some ofthe parameters are fixed in the GUI. For references, look at the Fractal imagecompression - Theory and application book by Yuval Fisher. Copyright 1995Springer-Verlag, Inc., New York. &nbsp;&nbsp; Vector Quantization:\n\r\n\rVector quantization works by dividing theimage into blocks (vectors) and generating a codebook for those vectors. Thecodebook contains the vectors, these can be thought of as subimages, which areused to represent the image. The index into the codebook is stored in place ofthe pixel values. It uses the LBG algorithm to generate the codebook, which isan iterative algorithm that continues searching for an &#8220;optimal&#8221;codebook until some minimum error criterion is reached. \n\r\n\rYou enter a value for the Error Threshold. This number is actually thedifference of the total error between two consecutive iterations. The smallerthe number, the &#8220;better&#8221; the codebook and the longer it takes.Since we are actually searching in a many-dimensional space, there is noguarantee of a globally optimal solution. Also, the search algorithm does nottake into account human visual perception, so a &#8220;better&#8221; solutionmay actually look worse. \n\r\n\rYou enter the Entries, which is the number of vectors in the codebook. Sothe size of the codebook is the (number of entries)x(vector size). The vectorsize is determined by the Vector Height and Width. For example, with a heightof 4 and width of 4, the vector size is 4x4=16. \n\r\n\rThe final two parameters are controlled by selection of one of the fourradiobuttons on the left. These have to do with how the image is compressed andsaved to a file, and represent the four possible permutations of the following twothings: 1) You can either generate a new codebook from the image, or use acodebook that has already been generated (it can be from any image, but must besaved to a file). 2) You can either save the codebook with the compressed file,or in a separate file. In general, you will get better results if you use acodebook generated from the specific image file. However, if you have a groupof similar images, you may want to generate a common codebook and save it in aseparate file. If you save the codebook in a separate file, you will have ahigher compression ratio, but you must keep track of the codebook file. If youkeep the codebook with the compressed (coded) file, then the compression ratiowill not be as large. &nbsp;&nbsp; XVQ\n\r\n\rXVQ is designed for compression using vector quantizationin the discrete wavelet or discrete cosine transform domains. The user canchoose the transform domain and select the principal components transform PCTas pre-process (for color images), by selecting one of the four transform options(DCT, PCT_DCT, WAVELET, PCT_WAVELET).The user selects one of the four compression algorithms (VQ1, VQ2, VQ3, VQ4),which represent different codebook and vector sizes. For a 512x512 color image,with FLOAT data type, VQ1 ~ VQ4 represent the compression ratios at 4:1, 8:1,14:1 and 20:1. \n\r\n\rThe user can select the data type for the codebook, less precise datatypes will provide greater compression. If BYTE is chosen, the user can selectthe method that will be used to remap the float data (from the transform), intobyte format. \n\r\n\rIf BYTE or SHORT data type and the DCT (or DCT_PCT) is selected, the usercan chose to quantize the DC term or not. &nbsp; &nbsp;TRANSFORM COMPRESSION\n\r\n\rTRANSFORM COMPRESSION is designed for experimentation withspectral transform based compression. You can select different color spaces(RGB, PCT, YCbCr), transforms (DCT, Wavelet(Haar), Wavelet(Daub4)), thetransform block size, quantization type (None, Quantization Table,JPEG_Q_Table), coding method is Huffman. \n\r\n\rThe equations used for the YCbCr color space are: \n\r\n\rY = 0.299R + 0.587G + 0.114B \n\rCb = - 0.1687R - 0.3313G + 0.5B + 2 ** (Sample Precision/2) \n\rCr = 0.5R - 0.4187G + 0.0813B + 2 ** (Sample Precision/2) \n\r\n\rR = Y + 1.402Cr \n\rG = Y - 0.34414(Cb - 2 ** (Sample Precision/2)) - \n\r0.71414(Cr - 2 ** (Sample Precision/2)) \n\rB = Y + 1.722(Cb - 2 ** (Sample Precision/2)) \n\r\n\rSample Precision is number of bits per pixel per color band. . \n\r\n\rIf the size of the input image is not a power of 2, it will be zeropadded. \n\r\n\rNote:\n\r\n\r&lt;color_space&gt;&nbsp;&nbsp;PCT and YCbCr do not apply for gray-levelimages. \n\r\n\r\n\r\n\r&lt;JEPG_Q_Table&gt;This uses the standard JPEG Quantization Table whichapplies only to the DCT with 8x8 blocksize. \n\r\n\rFor other transforms or blocksizes this option is not available. \n\r\n\r\n\r&lt;coding&gt;Only Huffman coding is available. Note that the data willconvert to BYTE automatically. \n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n\r\n\rIf the size of the input image is not a power of 2, it will be zeropadded. \n\r\n\rTo illustrate how transform compression works, we consider the example ofhow it works on a 3-level wavelet decomposition\n\r\n\rExample: 3-level waveletdecomposition\n\r\n\r&nbsp;SHAPE &nbsp;\\* MERGEFORMAT                                                                                               \n\r\n\r10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                                 \n\r\n\r9                                                \n\r\n\r8                                                  \n\r\n\r6                                                \n\r\n\r7                                                \n\r\n\r5                                                \n\r\n\r1                                                \n\r\n\r2                                                \n\r\n\r4     \n\r\n\r&nbsp;                                                \n\r\n\r3                         \n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n\r\n\rFigure 1. Application of the valuesin the Quantization Table to the wavelet coefficients &nbsp; &nbsp;\n\r\n\r&nbsp;\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Supposethe following parameters are selected:\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColorSpace: RGB\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Transform&nbsp;&nbsp;&nbsp; : Wavelet(haar)\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Blocksize&nbsp;&nbsp;&nbsp;&nbsp; : 8x8\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Coding &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :Huffman\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Quant.Table: Yes\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Forthe above selected parameters transform compression works as follows:\n\r\n\rFirstly, the wavelet transform isperformed on the image using a blocksize of 8x8. Then the values from theQuantization Table are applied to each 8x8 block in the order described in thefigure 1 shown above. This is done by dividing the wavelet coefficients by thecorresponding values in the Quantization Table. In the next stage Huffmancoding is performed on the image and inverse wavelet transform gives thecompressed image.\n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp; JPEG2000\n\r\n\rJPEG2000 is a new image compression standard that isdeveloped by Joint Photographic Experts Group in the year 2000. In order to usethis function, first you have to select either &#8216;Ratio&#8217; or&#8216;Quality&#8217; from the parameters menu. Ratio specifies the amount ofcompression that is to be applied to input image. Quality specifies the qualitylevel to be achieved during&nbsp; thecompression. Number of Layers defines the number of resolution or number ofdecomposition for the discrete wavelet transform (DWT). Block size defines thesize of the code-block. ","Lossy","scr\\How To Use CVIPtools/Compression/cvip_cmprs_lossy.html","   Yue  ACADEMIC COMPUTING  6  19  2003-10-20T04:03:00Z  2004-06-16T19:17:00Z  1  355  2026  16  4  2377  10.3501    Clean  Clean         MicrosoftInternetExplorer4      Compression: Preprocessing\n\r\n\rPreprocessing is often performed with imagecompression methods in order to reduce the amount of data that needs to becompressed. Any preprocessing done before compression usually will require a postprocessing step after decompression to reverse theprocess. For example, we may reduce the image size as a preprocessing step, andthen enlarge it as a postprocessing step. Otheruseful pre and postprocessing functions can be foundunder &#8216;Utilities&#8217; and &#8216;Analysis-&gt; Geometry&#8217;. Otheruseful postprocessing methods can be found in the&#8216;Enhancement&#8217; window. \n\r\n\rFor All Functions:\n\rSpatial Quantization:\n\rGraylevel Quantization:&nbsp; &nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters,press the &#8216;Apply&#8217; button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed byclicking mouse button 1 on an image in the main window&#8217;s image queue. &nbsp;&nbsp; Convert Binary to Gray code, Convert Gray code to binary:\n\r\n\rNo parameters. Often used as preprocessing (binary togray) and postprocessing (gray to binary) for graylevel run length coding; since, with a gray code adjacent values differ in onlyone bit. &nbsp; &nbsp; Spatial Quantization:\n\r\n\rThis will reduce the image size. Enter orselect from pop-up menus height and width, and select method from pop-up menu.The method is used to determine how this reduction is done. The average methodwill assign pixel values in the reduced image with the average of thecorresponding neighborhood pixel values, median with the median, and decimationsimply eliminates rows and columns (similar to zero-order hold enlarging). Notethat other methods are available under &#8216;Analysis-&gt;Geometry&#8217;. &nbsp; &nbsp; GraylevelQuantization:\n\r\n\rThis will reduce the number of gray levelvalues in the image. Enter or select from the pop-up menu the number of graylevels desired, which must be a power of 2. Select Standard or IGS (ImprovedGray Scale). Normally, for preprocessing you will want to use Standard and thenuse IGS for postprocessing. Since IGS adds a randomnumber to the quantized values it will increase the randomness in the image,which is undesirable for compression. However, it will improve the imagequality (after decompression) by reducing false contours in the image that mayresult from gray level reduction. ","Preprocessing","scr\\How To Use CVIPtools/Compression/cvip_cmprs_prep.html","   umbaughs  skefel  2  5  2010-07-12T19:34:00Z  2010-07-12T19:34:00Z  1  297  1693  SIUE  14  3  1987  12.00    Clean  Clean  false        false  false  false    EN-US  X-NONE  X-NONE                                                                                                                                                                                                                                                                                                                                                                   \n\r\n\rCVIP-ATAT\n\r\n\r&nbsp;\n\r\n\rThe Computer Vision and Image Processing Algorithm Testand Analysis Tool, CVIP-ATAT, was created to facilitate the development of bothhuman and computer vision applications. The primary function of this tool is toallow the user to explore many more algorithmic possibilities than can beconsidered by processing one image at a time with CVIPtools.It allows for the automatic processing of large image sets with many differentalgorithmic and parameter variations. We call this the “front-end” tool becauseits primary purpose is to find the best algorithm to preprocess, segment andpost-process a set of images for a particular application in order to bestseparate the most important regions of interest within the image.\n\r\n\r&nbsp;\n\r\n\r            It hasa GUI which allows the user to enter multi-stage algorithms for testing andanalysis. At each stage the user can specify a number of different processes totest and a range for the processes’ parameters. The user also specifies a setof images to process and a set of “ideal” output images which will be used todetermine the success for each algorithm. Note that one algorithm is defined as a specific set of processes and aspecific set of parameter values.\n\r\n\r \n\r\n\r            Thetool will then automatically perform algorithms which consist of all thepermutations of the values for each of the parameters for each process and allthe processes for each stage. Next, the user can compare the various algorithmresults to determine the best set of processes and parameters for theparticular application. The tool is useful for application development wherethe ideal image results are available, or can be created. Additionally, it canserve as a front end development tool for image analysis to find the optimalset of processes and parameters for extracting regions of interest for furtherprocessing. For more details on its use see the HELP pages in CVIP-ATAT and Chapter 12 in the textbook, Digital Image Processing and Analysisby Scott E Umbaugh.","CVIP-ATAT","scr\\How To Use CVIPtools/CVIP_ATAT/CVIP-ATAT_Help.htm","   umbaughs  skefel  2  23  2010-07-12T19:34:00Z  2010-07-12T19:34:00Z  1  354  2019  SIUE  16  4  2369  12.00    false        false  false  false    EN-US  X-NONE  X-NONE                                                                                                                                                                                                                                                                                                                                                                   \n\r\n\rCVIP-FEPC\n\r\n\r&nbsp;\n\r\n\rThe Computer Vision and Image Processing FeatureExtraction and Pattern Classification Tool, CVIP-FEPC, was created tofacilitate the development of both human and computer vision applications. Theprimary application area is computer vision, but it can be used, for example,as an aid in the development of image compression schemes for human visionapplications. This can be done by helping to determine salient image featuresthat must be retained for a given compression scheme. Conversely, computervision applications are essentially deployed image analysis systems for aspecific application, so the feature extraction and pattern classification isan integral part of all computer vision systems.\n\r\n\r&nbsp;\n\r\n\r            Theprimary function of this tool is to explore feature extraction and patternclassification and allow the user to perform batch processing with large imagesets and is thus much more efficient than processing one image at a time withCVIPtools. It allows the user to select the features and pattern classificationparameters for the automatic processing of these large image sets. CVIP-FEPCenables the user to easily specify the training and test sets and run multipleexperiments in an efficient manner. Alternately, the user can select leave-one-out to run a completeleave-on-one test. Its primary purpose is to find the best parameters for aparticular application in order to best classify the image objects of interest.\n\r\n\r&nbsp;\n\r\n\r            Thistool is designed to work with a set of images that have binary masks that havebeen created for the objects of interest – one object per image. These maskscan be created manually with CVIPtools, or, many image database applicationswill have the masks available. The masks should be put in a directory (folder)named masks under the folder wherethe images reside, and have the same name as the corresponding images (the fileextensions can be different).\n\r\n\r&nbsp;\n\r\n\r             In general, the user will load the images,specify the classes, select the features, select the test set or leave-one-out,choose the pattern classification parameters and then let the program processthe entire image set.  An output filewill be created with the results for the experiment. For more details on itsuse see Chapter 12 in the textbook, DigitalImage Processing and Analysis by Scott E Umbaugh.\n\r\n\r&nbsp;\n\r\n\rØ&nbsp;Warning – do not put spaces in the class names!","CVIP-FEPC","scr\\How To Use CVIPtools/CVIP_FEPC/CVIP-FEPC_Help.htm","   Yue  ACADEMIC COMPUTING  13  25  2003-10-20T04:19:00Z  2004-09-25T23:55:00Z  1  706  4025  33  9  4722  10.3501    MicrosoftInternetExplorer4      Enhancement: Pseudocolor\n\r\n\rPseudocolor works on grayscale and binary images.Pseudocolor is often used to enhance images since the human visual system canperceive thousands of colors in a small spatial area, but only about 100 graylevels. \n\r\n\rFor AllFunctions:\n\rFrequency domain mapping:\n\rGray level mapping:\n\r\n\rGray level mapping II:\n\rIntensity slicing:&nbsp; &nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters,press the &#8216;Apply&#8217; button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed byclicking mouse button 1 on an image in the main window&#8217;s image queue. &nbsp; &nbsp; Frequency domainmapping:\n\r\n\rThis works by first performing a Fouriertransform on the image, filtering, followed by an inverse Fourier transform.The spectral regions used for the filters are circular and ring-shaped, with a low-passregion about the origin specified by the low cut-off, a band-pass regionspecified by the low and high cut-off, and the high-pass region specified bythe high cut-off. Then the inverse Fourier transform is performed on each ofthe filtered outputs separately, and the results from each of the bands are putinto either the red, green or blue band of a color image. \n\r\n\rTo use, select or enter low and high cut-off frequencies, then select acolor for the low-pass, band-pass, and high-pass bands. Each band must be adifferent color (R, G, or B). \n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Gray level mapping:\n\r\n\rGray level mapping pseudocolor works bydefining a different mapping equation for each of the red, green and blue bandsof the output color image. The input is the original gray level values. \n\r\n\rTo use, select a shape for each band from its pop-up menu. Note thatcustomized gray level mapping/pseudocolor can be done usingEnhancement-&gt;Histograms-&gt;Linear Modification in conjunction withUtilities-&gt;Create-&gt;Extract and Utilities-&gt;Create-&gt;Assemble bands. \n\r\n\r&nbsp;\n\r\n\r&nbsp;&nbsp;&nbsp; Graylevel mapping II:\n\r\n\rGray level mapping pseudocolor works by defining adifferent mapping equation for each of the red, green and blue bands of theoutput color image. The inputs are the original gray level values. \n\r\n\rTo use, select the required mapping file from the pop-up menu or load itfrom a different directory or just type in the filename in the text boxprovided. Select a Gray scale image on which the mapping is to be performed.You can also make your own map by pressing the &#8216;Custom Remap Curve&#8217;button at the bottom of the &#8216;Enhancement&#8217; window. Here, you canselect either the &#8216;Linear&#8217; or &#8216;Lagrange Interpolation&#8217;method. Select the &#8216;Red&#8217;, &#8216;Blue&#8217; or &#8216;Green&#8217;band and then make your own curve. The &#8216;Y&#8217; axis represents the&#8216;Remapped Values&#8217; and the &#8216;X&#8217; axis represents the&#8216;Original Values&#8217;. To make a common curve for all bands select&#8216;All&#8217; and then make the curve. You can make a curve by selectingany point in the &#8216;Interpolation Box&#8217; by a left mouse click. Theleft mouse button is also used to drag the points. The points at the ends canonly move up and down while the points created at other locations can moveanywhere inside the box. To get rid of any point, just get the mouse on thatpoint and click the right mouse button. You can also add the points manually byselecting or entering the &#8216;X&#8217; and &#8216;Y&#8217; co-ordinates fromthe pop-up menu. Press &#8216;Add&#8217; after entering each point. After youmake a curve for all the bands, press &#8216;All&#8217; to view all the curvestogether. Then press &#8216;Save&#8217; to save this map. When this map issaved it appears in the main windows pop-up menu. You can then select it andpress &#8216;Apply&#8217; at the lower right of the &#8216;Enhancement&#8217;window to perform the gray level mapping.&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;Intensity Slicing:\n\r\n\rHere you can specify up to four ranges ofgray levels and the RGB values for the colors to which you want to map eachrange of gray level values. \n\r\n\r&nbsp;\n\r\n\rIntensity slicing will change all pixels with values inthe range &#8216;From&#8217; to the range &#8216;To&#8217; from their grayvalues to a color with RGB values selected or entered in the boxes to the rightof the range. \n\r\n\rIn the topmost &#8216;From&#8217; box, select or enter a value, thenselect or enter a larger value in the &#8216;To&#8217; box beside it. Thenselect or enter the RGB values in the boxes in the same row as the desiredrange. \n\r\n\rYou may designate up to four ranges for slicing. Use the rows in orderfrom top to bottom, and each new row must start &#8216;From&#8217; a largervalue than the preceding row&#8217;s &#8216;To&#8217; value. \n\r\n\rChecking the &#8216;Set Out of Range Data to 0&#8217; box will cause theselected range(s) to be returned on a black image; not selecting or deselectingit will return the original image with color highlights in the selectedrange(s). ","Pseudocolor","scr\\How To Use CVIPtools/Enhancement/cvip_enhan_pseudo.html","   Yue  ACADEMIC COMPUTING  8  40  2003-10-20T04:25:00Z  2004-08-02T19:15:00Z  1  812  4631  38  10  5433  10.3501    MicrosoftInternetExplorer4      Enhancement: Sharpening\n\r\n\rImage sharpening is done to enhancedetails in an image. This is done by boosting the edge, or high frequency,information in an image. In the spatial domain this can be done by adding theresult from a high pass spatial mask, such as an edge detector, to the originalimage, or by using special algorithms such as unsharp masking. In the frequencydomain this is done by boosting the high frequency information. \n\r\n\r&nbsp;\n\r\n\rFor All Functions:\n\rSharpening Algorithm I:\n\rSharpening Algorithm II:\n\r\n\rHigh pass spatial filter:\n\rHigh boost:\n\rUnsharp masking:\n\rFFT, DCT Sharpening:\n\rHigh Frequency emphasis:\n\rHomomorphic Sharpening:\n\r\n\r&nbsp;&nbsp; &nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters,press the &#8216;Apply&#8217; button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed byclicking mouse button 1 on an image in the main window&#8217;s image queue. \n\r\n\r&nbsp;\n\r\n\rSPATIAL DOMAIN SHARPENING &nbsp; &nbsp; Sharpening Algorithm I:\n\r\n\rThis algorithm works as follows: 1)performs a Laplacian edge detection on the original image, 2) performs a Sobeledge detection on the original image, 3) multiplies result from Laplacian andSobel, 4) adds the product from step 3 to the original image, 5) histogramstretches the result from step 4. \n\r\n\rWith the &#8216;Intermediate Image Remapping&#8217; option you can remapthe product (from step 3) to BYTE range (0-255) before you add it to theoriginal image. This has the effect of improving image contrast, but withreduced sharpening effect. Two different Laplacian masks can be selected, butMask II tends to give more raggedy edges. Choosing a larger mask size for theSobel will tend to brighten the major edges, but will also tend to smear themout slightly. The final two selections, &#8216;Low/High clip percentage&#8217;,determine how much of the histogram is clipped during the final histogramstretch. &nbsp; &nbsp; Sharpening Algorithm II:\n\r\n\rThe sharpening algorithm first performs ahistogram shrink to the range [10,100], then sharpens using theRoberts gradient method to improve edges. Finally, the image is histogram equalized.You can choose to add the result to the original image or not with the checkboxin the lower left corner of the &#8216;Parameters&#8217; frame. \n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; High pass spatial filter:\n\r\n\rThis applies a spatial convolution mask to the image. You can choose toadd the result to the original image or not with the checkbox in the lower leftcorner of the &#8216;Parameters&#8217; frame.      \n\r\n\rFor the high pass filter, the mask used is:    &nbsp; &nbsp; 0 &nbsp;&nbsp;&nbsp;&nbsp; -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp; &nbsp; -1&nbsp;&nbsp;&nbsp;&nbsp;  4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1&nbsp; &nbsp; 0 &nbsp;&nbsp;&nbsp;&nbsp; -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp; &nbsp; High boost:\n\r\n\rTo use, select mask size from the pop-upmenu. In general, a larger mask will result in wider-looking enhanced edges.      \n\r\n\rThe default mask is:    &nbsp; &nbsp; -1&nbsp;&nbsp;&nbsp;&nbsp; -1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1&nbsp; &nbsp;-1&nbsp;&nbsp;&nbsp;&nbsp;  9 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1&nbsp; &nbsp;-1 &nbsp;&nbsp;&nbsp; -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1\n\r\n\rNext, enter or select a center value for the mask. Normallyyou want the center value for an NxN mask to be (NxN). A higher value willretain more of the original image, while a number less than NxN will result ina negative of the original image. If you do not add the result to the originalimage the result will often look black, but the image can be made visible witha histogram stretch or equalization (note: a histogram equalization can beperformed on the displayed image by selecting the image and pressing an&#8216;e&#8217; on the keyboard. \n\r\n\rThe &#8216;Add to Original Image&#8217; checkbox in the lower left cornerof the &#8216;Parameters&#8217; frame applies to this function as well as theones above. &nbsp; &nbsp; Unsharp masking:\n\r\n\rThe unsharp masking algorithm used here(there are others) works by first using a lowpass spatial filter on the image,then a histogram shrink on this low passed image. This result is thensubtracted from the original image, and then a histogram stretch is performedto improve contrast. (Note that subtracting a low passed image from an originalimage is similar to adding a high passed image.) \n\r\n\rTo use, select or enter lower and upper limits for the histogram shrink,and the percent to clip at the low and high ends for the final histogramstretch. \n\r\n\r&nbsp;\n\r\n\rFREQUENCY DOMAIN SHARPENING \n\r\n\rThe frequency domain sharpening algorithms perform highpass or high boostfiltering using Butterworth filters, and then add the result to the originalimage. This is followed by a histogram stretch to improve contrast. \n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; FFT, DCT Sharpening:\n\r\n\rTo use, enter or select cutoff frequencyfor the highpass filter and select the Butterworth filter order. &nbsp; &nbsp; High Frequency emphasis:\n\r\n\rTo use, select transform type, filterorder and emphasis offset from the pop-up menus. Next enter or select thecutoff frequency, and select or deselect &#8216;Keep DC&#8217;, as desired. &nbsp; &nbsp; Homomorphic Sharpening:\n\r\n\rHomomorphic filtering process uses a highfrequency emphasis filter. Here you can control both the high and low frequencygains. This process also includes a log mapping before filtering and an inverselog after the filtering. The idea for the log mapping is to decouple thelighting conditions from the reflectance properties of the objects in theimage. \n\r\n\rTo use, enter or select the cutoff frequency from pop-up menus and lowerand higher frequency gains. If you select &#8216;Add to Original Image&#8217;,the algorithm will do this AND will perform a histogram stretch to improvecontrast. ","Sharpening","scr\\How To Use CVIPtools/Enhancement/cvip_enhan_sharp.html","   Yue  skefel  3  21  2010-01-06T19:43:00Z  2010-01-06T19:45:00Z  1  544  3107  25  7  3644  11.9999    BestFit  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                             Enhancement: Smoothing\n\r\n\rImage smoothing methods work by smoothingout abrupt gray level changes within an image. This results in loss of detail.Normally this is done to either mitigate the effects of noise, which is usuallyhigh frequency information, or to impart a softer look to the image. Imagesmoothing is usually accomplished with some form of lowpassfiltering. \n\r\n\r&nbsp;\n\r\n\rFor All Functions:\n\rSpatial Domain Smoothing:\n\rMean, Median, Midpoint filters, Gaussian filter:\n\rContra-harmonic, Ypmean filters:\n\rKuwahara Filter:&nbsp;&nbsp;&nbsp; \n\r\n\rFrequency Domain Smoothing:\n\rFFT Smoothing:\n\rDCT Smoothing:\n\r\n\rAnisotropic Diffusion Filter:\n\r\n\rParametric Anisotropic Diffusion Filter:&nbsp; &nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters,press the &#8216;Apply&#8217; button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed byclicking mouse button 1 on an image in the main window&#8217;s image queue. &nbsp; &nbsp; SPATIAL DOMAINSMOOTHING:\n\r\n\rThe spatial filters included here are theones we have found to be best for image smoothing. More spatial filters can befound under Restoration-&gt;Spatial filters. &nbsp; &nbsp; Mean,Median, Midpoint filters, Gaussian filter:\n\r\n\rThe mean filter is an arithmetic mean orneighborhood averaging filter. The median is an order filter, while themidpoint is a combination order and average filter. The Gaussian filter is similarto the mean filter but has a Gaussian weighting to the mask coefficients whichfall off as we get away from the center pixel. \n\r\n\rTo use, select a mask size from the pop-up menu. &nbsp; &nbsp; Contra-harmonic,Ypmean filters:\n\r\n\rThese are both order filters, based onordering the values within the window under the mask. \n\r\n\rTo use, select mask size and order from pop-up menus. &nbsp;&nbsp;&nbsp; Kuwahara Filter:\n\r\n\rKuwahara Filter is an Edge Preserving Filter. \n\r\n\rTo use, select mask size from pop-up menus.&nbsp; &nbsp; FREQUENCY DOMAIN SMOOTHING:\n\r\n\rFrequency domain smoothing is done byusing a 1st-order Butterworth filter in conjunction with a Fourier transform.(More control can be obtained over the filtering process in theAnalysis-&gt;Transforms window.) &nbsp; &nbsp; FFT Smoothing:\n\r\n\rTo use, enter or select the cutofffrequency for the lowpass filter. &nbsp; &nbsp; DCT Smoothing:\n\r\n\rTo use, enter or select the cutofffrequency for the lowpass filter. \n\r\n\rNote: If you select a new current image, you should reselect a smoothingmethod in order to update the blocksize that is displayed.&nbsp;&nbsp;&nbsp;&nbsp; Anisotropic DiffusionFilter:\n\r\n\rAnisotropic Diffusion Filter isused to reduce image noise while preserving significant parts of the image suchas edges, lines or borders. To use it, first select either standard orparametric versions of ad filter. Then for standard, select/enter iterationnumber, smoothing per iteration and edge threshold. For parametric,select/enter iteration number, smoothing per iteration, edge threshold, andblock size. Iteration number specifies how many times the image is going to bediffused. Higher number of iterations will remove more of the noise but moredetail will be lost as well. Smoothing per iteration specifies the strength ofthe diffusion process, in other words, how fast is the image going to bediffused. Edge threshold specifies the minimum strength of edges that will bepreserved during the diffusion. Block size specifies the size of the kernelthat is used to calculate diffusion coefficient.&nbsp; \n\r\n\r&nbsp;","Smoothing","scr\\How To Use CVIPtools/Enhancement/cvip_enhan_smooth.html","   ACADEMIC COMPUTING  Normal  Mounika  8  4  2004-06-25T22:33:00Z  2010-04-23T16:09:00Z  1  1111  6336  SIUE  52  14  7433  11.5606    140  Clean  Clean    false  false  false                                       MicrosoftInternetExplorer4  false      EN-US  X-NONE  X-NONE                                             Enhancement: Histogram/Contrast\n\r\n\rThese functions modify the distribution ofgray levels in an image, thereby changing the brightness and contrast. They dothis by controlling the shape or distribution of the output image histogram. Inaddition to the histogram modification functions, the gray level mappingfunctions are included here, since they also have the end result of modifyingthe histogram. \n\r\n\rFor All Functions:\n\rHistogram Equalization:\n\rHistogram Slide:\n\rHistogram Shrink:\n\rHistogram Stretch:\n\rLocal Equalization:\n\rAdaptive Contrast Filter:\n\rColor Contrast Algorithm:\n\rHistogram Specification:\n\rLinear Modification:\n\rGray Level Multiplication:&nbsp; &nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters, press the ‘Apply’button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed byclicking mouse button 1 on an image in the main window’s image queue&nbsp; &nbsp; Histogram Equalization:\n\r\n\rHistogram equalization is a standardmethod to improve the contrast in an image. If the original image has very poorcontrast, you will see dramatic results. \n\r\n\rTo use the function: \n\r\n\rFor gray-scale images, no parameters are needed. \n\r\n\rFor color images, select the band to use as a basis for equalization from‘On Band’ buttons. Selection of ‘Value’ will result in the image beingtransformed to the HSL colorspace, equalization ofthe brightness (‘Lightness’), and inverse transform to an RGB image. \n\r\n\rNote that histogram equalization can be done by selecting the image ascurrent image and pressing ‘e’ on the keyboard. However, when this is done, theequalized image is represented with the same name as the current image(overwrites the current image), in the image queue. &nbsp; &nbsp; Histogram Slide:\n\r\n\rSliding the histogram up will brighten the image andsliding it down will darken the image. \n\r\n\rTo use, select slide direction, and enter or select from pop-up menu theamount of slide. &nbsp; &nbsp; Histogram Shrink:\n\r\n\rThis will reduce the contrast in an image.It may be a useful preprocessing step in a compression algorithm (followed by astretch after decompression). \n\r\n\rTo use, enter or select from pop-up menus the lower and upper values. &nbsp; &nbsp; Histogram Stretch:\n\r\n\rThis will improve the contrast in animage. By clipping a small percentage at the ends, you can avoid thepossibility of a few high or low pixel values compromising the stretch effect. \n\r\n\rTo use, enter or select from pop-up menus the low and high limit values,and the percent to clip from low and high ends. &nbsp; &nbsp; Local Equalization:\n\r\n\rThis performs histogram equalization onsmall blocks throughout the image. This will let you see more local detail,often in areas that may appear constant. \n\r\n\rTo use: \n\r\n\rFor gray-scale images, set the desired blocksize.\n\r\n\rFor color images, select the band to use as a basis for equalization from‘On Band’ buttons, then set the desired blocksize. Ablack border will appear on the output image as a result of the selected blocksize. \n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; Adaptive Contrast Filter:\n\r\n\rHere are four Adaptive Contrast Enhancement(ACE) filters. To use them, first select the desired filter from the radiobuttons: ‘Adaptive Contrast Filter, ACEII, log(ACE) orexp(ACE)’ \n\r\n\rTo use them, enter or select from pop-up menus the local gain factor,local mean factor, and the kernel size. The ‘Adaptive Contrast’ selection hastwo additional parameters, min and max local gain, which provide limits on thefirst term in the equation. These are the equations: \n\r\n\rAdaptive Contrast equation:                               \n\r\n\rwhere,\n\r\n\r mI(r,c)= the mean for the entire image I(r,c) \n\rsl= the local standard deviation \n\rml = the local mean \n\rk1 = Local gain factor (multiplier), between 0 and 1 \n\rk2 = Local mean factor (multiplier), between 0 and 1 \n\rkernel size = size of local window \n\rmin and max set limits on the gain from the local gain term \n\r\n\rACEII equation: &nbsp; &nbsp;          \n\r\n\rwhere,\n\r\n\r ml= the local mean \n\rk1 = Local gain factor (multiplier), between 0 and 1 \n\rk2 = Local mean factor (multiplier), between 0 and 1 \n\rkernel size = size of local window \n\r\n\rlog(ACE) equation:              \n\r\n\rwhere,\n\r\n\r mlbar = 1 - ml(r,c)/M, normalized complement of local mean \n\rIbar = 1 - I(r,c)/M,normalized complement of image \n\rwhere M = number of gray levels (255) \n\rk1 = Local gain factor (multiplier), between 0 and 1 \n\rk2 = Local mean factor (multiplier), between 0 and 1 \n\rkernel size = size of local window \n\r\n\rexp(ACE) equation: \n\r\n\r \n\r\n\rwhere,\n\r\n\r M = thenumber of gray levels (255) \n\rml = the local mean \n\rk1 = Local gain factor (exponent) \n\rk2 = Local mean factor (exponent) \n\rkernel size = size of local window    Color Contrast Algorithm:\n\r\n\rThis will improve the color of the image. To use, selecta color image and by entering or selecting the low and high limit values, andthe percent to clip from low and high ends values from pop-up menus and hitapply button. The improvement of the color of the image depends on the valueschosen for the low limit, high limit, low clip and high clip.&nbsp; &nbsp; Histogram Specification:\n\r\n\rYou will specify the histogrammodification equation for each band in the image separately. The equation caninclude algebraic operators (+,-,*,/,^), and any of the following functions:\n\r\n\rsin(arg)&nbsp;&nbsp;&nbsp;          sinh(arg)&nbsp;          imp(arg)&nbsp;&nbsp;         sqrt(arg) \n\rcos(arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cosh(arg)&nbsp;&nbsp;        floor(arg)&nbsp;&nbsp;&nbsp;       abs(arg) \n\rtan(arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     tanh(arg)&nbsp;&nbsp;&nbsp;&nbsp;       step(arg)&nbsp;          ceil(arg) \n\rasin(arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      exp(arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      u(arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         deg(arg) \n\racos(arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     ramp(arg)&nbsp;&nbsp;       rad(arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n\ratan(arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     r(arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        log(arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  \n\r\n\rFor gray-scale images, type the desired equationinto the ‘Formula for R band’ equation box or select an equation from thepop-up menu to the right of the box. The following equations are included inthe pop-up menu as examples: \n\r\n\rsin(0.025*x)&nbsp;&nbsp;   &nbsp;ramp(2.0*x+5) \n\rx+25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       exp(0.025*x)\n\rx*2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       log(0.5*x+2) \n\r\n\rFor example, to specify a tangent, enter:tan(100*x); to use sqrt, you may enter: sqrt(x+10). \n\r\n\rFor color images, type equations for each band orselect equations from pop-up menus. &nbsp; &nbsp; Linear Modification:\n\r\n\rEnter integers for the starting and endinggray values to change and a new initial gray level. Then enter a number for theslope of the line to be used to modify the gray levels within the specifiedrange. The slope may be positive, negative, or zero. A zero slope will causeall values in the given range to be mapped to the ‘Initial value’ gray level.Finally, you may either retain values outside the specified range or set themto zero. \n\r\n\rThis function can be used in conjunction withUtilities-&gt;Create-&gt;Extract bands and Utilities-&gt; Create-&gt;Assemblebands to customize a gray level mapping pseudocolorimage. &nbsp; &nbsp; Gray Level Multiplication:\n\r\n\rSelect with or without ‘Byte clipping’,then enter the multiplication factor or select it from the pop-up menu. If youchoose with ‘Byte clipping’, the image is first remapped to Byte, then ismultiplied by the factor and truncated to Byte. If you choose without ‘Byteclipping’, data is converted to float, multiplied by the factor, and a floatimage is put into the image queue. The returned image is remapped to Byte fordisplay only. \n\r\n\rNote that another multiplication option is available with Utilities-&gt;Arith/Logic-&gt;Multiply. There you can multiply twoimages. \n\r\n\r&nbsp;","Histogram/Contrast","scr\\How To Use CVIPtools/Enhancement/histograms.htm","   Yue  ACADEMIC COMPUTING  6  5  2003-10-20T04:30:00Z  2004-09-17T01:06:00Z  1  54  309  2  1  362  10.3501    Clean  MicrosoftInternetExplorer4      Exiting the program\n\r\n\rTo exit from the program, select&#8216;File-&gt;Exit&#8217; from the menu bar at the top of the program. Aconfirmation message box will appear. To exit select &#8216;Yes&#8217;, toremain in the program select &#8216;No&#8217;. \n\r\n\rNOTE: When you exit the program, every image that you have created willbe LOST if you have not specifically saved each with the &#8216;File-&gt;Save&#8217;option. ","Exiting the program","scr\\How To Use CVIPtools/File/cvip_exit.html","   Yue  ACADEMIC COMPUTING  12  13  2003-10-20T05:44:00Z  2004-09-10T20:35:00Z  1  113  646  5  1  758  10.3501    Clean  Clean  MicrosoftInternetExplorer4      Loading an image\n\r\n\rIf you want to load an image in the imagequeue, select the &#8216;File-&gt;Open&#8217; option from the menu bar andbrowse to the folder where the required image is stored. Select the image andpress the &#8216;Open&#8217; button.&nbsp;The selected will be loaded and displayed. It will also be added to theimage queue list. \n\r\n\rCurrently, CVIPtools will read in the following image file formats: \n\r\n\r\n\rEPS &nbsp;&nbsp;&nbsp; (EncapsulatedPostscript: monochrome only) \n\rGIF &nbsp;&nbsp;&nbsp;&nbsp; (GraphicsInterchange Format) \n\rIRIS &nbsp;&nbsp;&nbsp; (Silicon Graphics)\n\rITX &nbsp;&nbsp;&nbsp;&nbsp; (Itex) \n\rJPEG &nbsp; (Joint PhotographicsExpert Group) \n\rPPM &nbsp;&nbsp; (Portable PixMap: PNM, PPM, PGM, PBM) \n\rRAS&nbsp;&nbsp;&nbsp;&nbsp; (Sun Rasterfiles) \n\rTIF &nbsp;&nbsp;&nbsp;&nbsp; (Tagged ImageFile Format) \n\rVIP &nbsp;&nbsp;&nbsp;&nbsp; (Visualizationin Image Processing/CVIPtools format)\n\rBMP &nbsp;&nbsp; (Windows or OS /2 Bitmap)\n\r\n\rPS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Postscript)\n\r\n\r&nbsp;\n\r\n\r&nbsp;","Open an image","scr\\How To Use CVIPtools/File/cvip_load_image.html","   Yue  ACADEMIC COMPUTING  8  32  2003-10-20T06:21:00Z  2004-09-25T22:07:00Z  1  134  768  6  1  901  10.3501    Clean  Clean  MicrosoftInternetExplorer4      Save an image\n\r\n\rThe &#8216;Save&#8217; in CVIPtools is inthe &#8216;File-&gt;Save&#8217; option on the menu bar. To use it, just selectthe image by clicking on it and then choose this &#8216;Save&#8217; option. Theimage will be saved with the current name in the &#8216;images&#8217; folder.You can select either one of the following types to save the image from the&#8216;Save as type&#8217; pop-up menu: \n\r\n\r&nbsp;\n\r\n\rWindows Bitmap (*.bmp)\n\r\n\rJPEG (*.jpg)\n\r\n\rTagged Image File Format (*.tif)\n\r\n\rCompuserveGraphic Interchange (*.gif)\n\r\n\rCVIPtools VIPFormat (*.vip)\n\r\n\rPortable Pixelmap(*.ppm)\n\r\n\rPortable Graymap(*.pgm)\n\r\n\rPortable Bitmap (*.pbm)\n\r\n\rSun Raster Image (*.ras)\n\r\n\rSGI Image File (*.iris)\n\r\n\rITEXImage File (*.itx)\n\r\n\rEncapsulated Postscript (*.eps)\n\r\n\rPostscript (*.ps)\n\r\n\rIf you want to save an image in more than one file type, be sure to clickon its name in the image queue before each &#8216;Save&#8217; operation. Youcan also use the floppy disk symbol just below the menu bar to save the image.\n\r\n\r&nbsp;","Save an image","scr\\How To Use CVIPtools/File/cvip_save.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  3  15  2004-06-18T21:02:00Z  2004-06-25T22:42:00Z  1  112  645  SIUE  5  1  756  10.3501    Clean  Clean                  MicrosoftInternetExplorer4         \n\r\n\rDelete:\n\r\n\r&nbsp;\n\r\n\rThis option deletes(closes) theselected image in the image queue from the program. To use, select the image tobe deleted and press the ‘Delete’ button just above the image queue.\n\r\n\r&nbsp;\n\r\n\rDelete all:\n\r\n\r&nbsp;\n\r\n\rThis option deletes(closes) all theimages in the image queue from the program. Before deleting the images from theprogram it prompts the user to save the unsaved images. To use, press the‘Delete all’ button just above the image queue.\n\r\n\r&nbsp;\n\r\n\rLock Input:\n\r\n\r&nbsp;\n\r\n\rThis option locks the selected image in the image queue, onwhich the user wishes to perform a number of different operations. Selectingthis option allows the user to continue working on the same image instead ofgoing back to selecting the same image repeatedly after performing everyoperation.  \n\r\n\r&nbsp;","Delete","scr\\How To Use CVIPtools/File/Delete.htm","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  5  21  2004-06-18T20:44:00Z  2004-06-25T22:41:00Z  1  113  645  SIUE  5  1  757  10.3501    Clean  Clean                  MicrosoftInternetExplorer4         \n\r\n\rShow Histogram:\n\r\n\r&nbsp;\n\r\n\rSelecting this option helps viewing the histogram of thepresently selected image in the image queue. To use, select ‘File-&gt;ShowHistogram’ option from the menu bar on top.\n\r\n\r&nbsp;\n\r\n\rShow Spectrum:\n\r\n\r&nbsp;\n\r\n\rThis option enables you to view the ‘FFT Phase’, ‘Magnitude’or the ‘Log-remapped’ Spectrums of the selected image in the image queue. Touse, select one of the choices from the ‘File-&gt;Show Spectrum’ option fromthe menu bar on top.\n\r\n\r&nbsp;\n\r\n\rView Band:\n\r\n\r&nbsp;\n\r\n\rThis option enables the user to view any one of the three‘Red’, ‘Green’ or ‘Blue’ bands of the selected image from the image queue. Touse, select ‘File-&gt;View Band’ option and choice of band you want to viewfrom the menu bar on top. This feature can also be from the Toolbar just belowthe menu bar.\n\r\n\r&nbsp;\n\r\n\r ","Show Histogram","scr\\How To Use CVIPtools/File/Show Histogram.htm","   Yue  umbaughs  18  36  2004-06-18T21:38:00Z  2010-10-03T06:24:00Z  1  886  5056  42  11  5931  12.00          false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                            About CVIPtools\n\r\n\rCVIPtools is designed for the exploration of computerimaging by allowing you to interactively experiment with computer imagingtechniques, functions and algorithms. It is designed to be used for education,as well as for research and development. It is an on-going project developed atSouthern Illinois University at Edwardsville in the Computer Vision and ImageProcessing Laboratory under the direction of Scott E Umbaugh, PhD. \n\r\n\rThe Program\n\rDevelopment History\n\rPrimary CVIPtools Developers\n\rAdditional Developers\n\rCVIPtools ContributorsThe Program\n\r\n\rCVIPtools is a collection of computer imaging toolsproviding services to the users at four layers: the C function layer, the COMinterface layer, the CVIPImage layer and the Graphical User Interface (GUI).The C function layer consists of all image and data processing procedures andfunctions. The Common Object Module (COM) interface layer implements the COMinterface for each higher level CVIPtools function, primarily the Toolboxfunctions with a few Toolkit functions. The CVIPImage layer encapsulates theCOM interface functions and provides an Object Oriented Programming (OOP)approach. The GUI implements the image queue and manages user input andresultant output. The CVIPtools GUI allows even the casual computer users toexperiment with many of the sophisticated tools available to computer imagingspecialists without the need for any knowledge of computer programming.Development History\n\r\n\rScott Umbaugh designed the first version of CVIPtools in1992, which was implemented by Greg Hance. Much development was done with thistext menu-driven version by Scott Umbaugh, Greg Hance, Arve Kjoelen, Mark Zukeand Kun Luo from 1993-95. Scott Umbaugh and Mark Zuke designed the graphicaluser interface in 1995-96, which was implemented by Mark Zuke and Yansheng Wei.The CVIPtcl and CVIPwish shells were initially designed by Scott Umbaugh andKun Luo and implemented by Kun Luo and Zhen Li in 1995-96. Arve Kjoelenprovided system support from 1994-97, as well as doing development work withCVIPtools. Yansheng Wei developed extensive enhancements to CVIPtools during1996-97, including a complete re-organization and cleanup of the code. WenZheng and Sreenivas Makam assisted Scott Umbaugh and Yansheng Wei with thefinal production of the first publicly released version in 1997, version 3.6.Sreenivas Makam, Wen Zheng and Aek Chomaitong worked on the development ofversion 3.7 in 1997-1998. Aek Chomaitong, Satish Sammanna, and Lu Guo completedthe first release of this as version 3.7c in Fall 1998. Ragavendar Swamisai andYue Cheng worked on the development of version 3.9 in 1999-2002 and alsocompleted the release of this version in Fall 2002. The CVIPtools TclViewer forCVIPtools3.9 version was developed by Satish Sammanna, Ragavendar Swamisai andCraig Pohl. XVQ compression function was created by Lu Guo and Yue (Iris) Cheng.Transform compression function was created by Zhijian Lin. \n\r\n\rThe new CVIPtools for Windows was firstdesigned by Scott Umbaugh, Yue (Iris) Cheng, and Dejun Zhang in Fall 2001. TheCVIPtools COM interface was first implemented in Visual C++ by Zhang in Spring2002, with the Main GUI window and image queue written in Visual Basic. Zhangwas joined by Xiaohe Chen in Summer 2002 and together they created the firstalmost complete version Fall 2003. Huashi Ding joined the development team andstarted with implementing the Utility GUI. Zhang worked on the Analysis andRestoration, while Chen worked on Compression and Enhancement. HusainKagalwalla joined our team Spring 2004 and worked on the new Help for Windows.The new CVIPlab was developed by Zhang, while Cheng and Ding completed thedebugging of the first release version of CVIPtools4.3 Summer 2004.\n\r\n\rThe port of CVIPtools to C# began in 2007 by Patrick Solt and Evan Bian.This version of CVIPtools, version 5.x, includes many new CVIP functions, anup-to-date user interface, and two algorithm development programs, CVIP-FEPCand CVIP-ATAT. These programs facilitate algorithm development and batchprocessing, thereby enabling the CVIPtools users to have a more completedevelopment environment. CVIP-FEPC was created and developed by Patrick Soltand Jesse Phelps. CVIP-ATAT was initially developed by Sid Smith, Jeremy Wood,Geer Shaung, and Evan Bian. Pelin Guvenc and Peng Liu completed CVIP-ATAT inits current form. The overall development of CVIPtools5.x was performedprimarily by Patrick Solt and Jhansi Akkineni. Additional development with thisversion was handled by Hari Krishna Akkineni, Mounika Mamidi, Pelin Guvenc andSerkan Kefel. CVIPtools5.3 was completed in 2010.Primary CVIPtoolsUNIX Version Developers\n\r\n\rScott Umbaugh, Gregory Hance, Arve Kjoelen, Kun Luo, MarkZuke, Yansheng Wei. AdditionalCVIPtools UNIX Version Developers\n\r\n\rZhen Li, Wenxing Li, Wen Zheng, Sreenivas Makam, AekChomaitong, Satish Sammanna, Lu Guo, Ragavendar Swamisai, Yue (Iris) Cheng \n\r\n\rPrimary CVIPtools Windows Version Developers\n\r\n\rScottUmbaugh, Dejun Zhang, Xiaohe Chen, Huashi Ding, Yue (Iris) Cheng, HusainKagalwalla, Patrick Solt, Wenjun(Evan) Bian, Hu Wang, Jhansi Lakshmi Akkineni,Hari Krishna Akkineni, Mounika Mamidi, Pelin Guvenc, Serkan Kefel, Jesse Phelps,Jakia Afruz, Peng Liu.\n\r\n\rCVIPtoolsContributors\n\r\n\rMark Heffron, Asif Haswarey, Melvin Johnson, AmbalRamachandran, Sridhar Ramalingam, Ramesh Reddy, John Creighton, Brad Walker,Jiaxin Tan, Hong Niu, Dave Lyons, Simon Low, Marc Thompson, Muthu Sankarasubbu,Srinivas Madiraju, Frank Smith, Steve Costello, Joseph Tsai, Ivan Lambov, BradNoble, Robert McClean, Lance Kendrick, Chandra Swaminathan, Praveen Chandr, KuiCai, Craig Pohl, Zhijian Lin, Subhashini Srinivasan, Sushuma Gouravaram, GeerShuang, Amit Kharbanda, Ray Walter, Justin Trumpet, Nabin Mishra, Nilesh Shakya.","CVIPtools Contributors","scr\\How To Use CVIPtools/GettingStarted/cvip_contributors.html","   Yue  umbaughs  9  6  2003-10-20T04:14:00Z  2010-10-03T06:09:00Z  1  98  564  4  1  661  12.00          false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                              Copyrightinformation\n\r\n\rCopyright (C) 1996 - 2011 Scott E Umbaugh, SouthernIllinois University Edwardsville \n\r\n\rPermission to use, copy, modify, and distribute this software and itsdocumentation for any purpose and without fee is hereby granted, provided thatthe above copyright notice appear in all copies and that both that copyrightnotice and this permission notice appear in supporting documentation. Thissoftware is provided without express or implied warranty. The developers andSIUE shall not be held liable in any event for incidental or consequentialdamages in connection with, or arising out of, the furnishing, performance, oruse of this program. ","Copyright information","scr\\How To Use CVIPtools/GettingStarted/cvip_copyright.html","   Yue  umbaughs  19  87  2003-10-20T06:18:00Z  2010-10-03T06:16:00Z  1  719  4103  34  9  4813  12.00          false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                              Getting Started\n\r\n\rWelcome to CVIPtools. This program allows you apply variouscomputer imaging techniques to digital images, and compare results fromdifferent algorithms. \n\r\n\rTo start, you must first load an image. For loading an image, select the&#8216;Open&#8217; option from the &#8216;File&#8217; menu and browse to findthe image to be loaded. Select the image and press the open button. Theselected image is loaded.&nbsp; Note thatstarting with version 5.3 blocks of images can be selected and loaded using theWindows standards of the &lt;Shift&gt; and &lt;Ctrl&gt; keys to mark more thanone image.\n\r\n\rAfter loading an image, the image(s) will be displayed and the name(s)will appear in the image queue (see below) on the left of the main window. \n\r\n\rNext, click the mouse on one of the selections across the top of the mainwindow: Analysis, Restoration, Enhancement, Compression, or Utilties and thecorresponding pop-up menu will appear. Select the category of operationsdesired from the pop-up menu and it will expand into a window that contains allthe functions for that category. In general, a specific function is selected bythe radiobuttons on the left of the window, and the &#8216;Apply&#8217; buttonin the lower right will perform the operation. The &#8216;Cancel&#8217; buttonwill remove the window from the screen. \n\r\n\rSee the help pages on the individual functions to learn about them. \n\r\n\rThe Image Queue\n\rImage Viewer\n\rFunction Parameter Entry \n\rQuitting CVIPtools&nbsp; &nbsp; TheImage Queue\n\r\n\rThe image queue, displayed on the left ofthe main window, is the place to select images for processing. This is done byclicking on the name in the queue with the left mouse button. The image queuecan have a long list of images but the current image is highlighted. Any imagefrom the list can be made the current image by clicking on it. The&#8216;Delete&#8217; button ( Located on the top-left corner just below thetoolbar) removes the current image from the image queue. The &#8216;Deleteall&#8217; button removes all the images from the image queue. Note thatstarting with version 5.3 groups of selected images can be deleted using theWindows standards of the &lt;Shift&gt; and &lt;Ctrl&gt; keys to mark more thanone image. The &lt;Delete&gt; key or the button on the GUI can be used todelete the selected images. If the images in the image queue have not beenpreviously saved, a message box will appear just to confirm that the unsavedimages will be lost. The &#8216;Lock Input&#8217; checkbox (when checked) helpsto lock onto an image as the current image if the user wants to perform variousoperations on the same image. The image queue can be made to appear ordisappear by using the &#8216;View-&gt;Image Queue&#8217; option from the menubar. Note that the image queue is RAM-based and contains the images in the formof CVIPtools image structures, which will be remapped for display purposes, ifneeded. &nbsp; &nbsp; Function Parameter Entry\n\r\n\rAll CVIPtools functions have default parameter values thatwill provide reasonable and useful results. Additionally, the pop-up menus havelists of values that are typical and/or useful for most parameters. If you areunfamiliar with a function, try the default values first. If you don&#8217;tget what you want then try the pop-up selections. However, do not feel limitedto these values - most parameters allow entry of any value you like and willnot allow entry of values that will bomb the program. Also, in computer imagingapplications, the results you get are image and application dependent, so ourlist of typical values may not work for your particular application. In somecases you may want to get &quot;nonstandard&quot; results. So, livedangerously, explore, enter your own values. \n\r\n\rIf a filename is too long to fit in a text box after the user selects thefile (the path is too long), just place your cursor on the text box afterselecting the required file to display its complete filename.\n\r\n\rThere are many methods used for data entry: \n\r\n\r- An entry box with an arrow button to its right allows you to click onthe arrow with the mouse and drag the mouse over the desired value on the list.The selected value will appear in the entry box when you release the mousebutton. \n\r\n\r- With functions that need two images, the second image name can beselected from the pop-up menu and the current image will be the first image.For examples see arithmetic operations under Utilities-&gt;Arith/Logic. \n\r\n\rSee specific help pages for the functions you want to use for help withrequired parameters. &nbsp; &nbsp;Quitting CVIPtools\n\r\n\rIn the main window, select File-&gt;Exit. This will bringup an Alert box, which will ask you if you really want to exit. If you select&#8216;yes&#8217;, be aware that all images in the queue that have not beenwritten to disk will be lost. Note: images are written to disk with a Saveoperation. ","Start","scr\\How To Use CVIPtools/GettingStarted/cvip_start.html","   ACADEMIC COMPUTING  skefel  6  89  2005-11-21T20:49:00Z  2010-07-10T17:45:00Z  2010-07-10T18:04:00Z  1  387  2211  SIUE  18  5  2593  12.00    Clean  Clean  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                              Image Viewer\n\r\n\r&nbsp;\n\r\n\rThe image viewer is loaded byclicking on the open icon in the filetab provided at the upper left of the main window or by clicking on thestandard file open icon of a file folder and selecting an image. The selected imageis displayed automatically and it is the active image. The active image can bechanged by either clicking on the image name in the image queue or by clickingon the image itself.  The image viewerallows the user to perform different operations. However these operationsaffect only the image that is being displayed and not the image/images in theimage queue. The user can stretch the image by grabbing the lower right cornerof the image with the left mouse button and dragging it, in addition to the keyboardand mouse commands specified in the table below.\n\r\n\r&nbsp;\n\r\n\r&nbsp;     \n\r\n\rTable 2-2 CVIPtools  Image Viewer Keyboard and Mouse Commands        \n\r\n\rDRAW, MARK, SELECT      \n\r\n\rShift key-drag left mouse button      \n\r\n\rSelect rectangular area of image, used in crop, etc        \n\r\n\rControl key-drag left mouse button      \n\r\n\rSelect irregular shaped area if image, used in Utilities-&gt;Create-&gt;Border Mask and  Border Image and crop, etc        \n\r\n\rControl key-left mouse button      \n\r\n\rSelect Original  Image for Analysis-&gt;Features        \n\r\n\rControl-A      \n\r\n\rSelect entire image for copy/paste        \n\r\n\rControl-C      \n\r\n\rIf image has area currently selected, copy area to  clipboard – this is used for copying images into documents  \n\r\n\rElse, if image has current mesh (from Restoration-&gt;Geometric Transforms), copy mesh to clipboard        \n\r\n\rControl-V      \n\r\n\rIf mesh (from Restoration-&gt;Geometric  Transforms) is available on clipboard, paste mesh to image        \n\r\n\rAlt key-click left mouse button      \n\r\n\rMark mesh points for Restoration-&gt;Geometric  Transforms for Enter a new mesh  file; select Segmented Image for  Analysis-&gt;Features; select Second Image for Utility-&gt;Arith/Logic operations        \n\r\n\rAlt key-click left mouse button drag      \n\r\n\rAfter a mesh is entered in Restoration-&gt;Geometric Transforms, this will allow the user to  move mesh points        \n\r\n\rRight mouse button on image      \n\r\n\rMesh display select box (followed by left button to  select)  \n\r\n\rCopy/Paste current mesh        \n\r\n\rMiddle mouse button on image      \n\r\n\rRemoves drawn boxes and borders        \n\r\n\rROTATE      \n\r\n\rt      \n\r\n\rTurn 90 degrees clockwise        \n\r\n\rT      \n\r\n\rTurn 90 degrees counter-clockwise        \n\r\n\rFLIP      \n\r\n\rh, H      \n\r\n\rHorizontal flip        \n\r\n\rv, V      \n\r\n\rVertical flip        \n\r\n\rOTHERS      \n\r\n\rN      \n\r\n\rChange back to original image, including size        \n\r\n\rn      \n\r\n\rChange back to original image, without changing size        \n\r\n\rq, Q      \n\r\n\rQuit – removes image from display but leaves in queue  (clicking on the X in the upper  right corner will remove the image from queue)        \n\r\n\re, E      \n\r\n\rHistogram equalization        \n\r\n\rRight mouse button in image viewing area (workspace)      \n\r\n\rBrings up Utilities menu   \n\r\n\r    ","Image Viewer","scr\\How To Use CVIPtools/ImageViewer.html","   Iris Cheng  ACADEMIC COMPUTING  16  113  2003-10-20T16:36:00Z  2004-10-12T22:50:00Z  1  891  5082  Westar  42  11  5962  10.3501    MicrosoftInternetExplorer4      Restoration: Frequency filter\n\r\n\rFor All Functions:\n\rRestoration Filters:\n\rInverse Filter:\n\rGeometric Mean:\n\rPower Spectrum Equalization:\n\rConstrained Least Squares:\n\rWiener:\n\rPractical Wiener:\n\rParametric Wiener:\n\rNotch Filter:&nbsp; &nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters, pressthe &#8216;Apply&#8217; button at lower right to perform the operation. \n\r\n\rFor all of the restoration filters, the current image is assigned as thedegraded image, and can be changed by clicking mouse button 1 on an image inthe main window&#8217;s image queue. \n\r\n\rFor the notch filter, the current image is automatically selected, and canbe changed by clicking mouse button 1 on an image in the main window&#8217;simage queue. &nbsp; &nbsp; RESTORATION FILTERS:\n\r\n\rThese frequency domain restoration filters arebased on the model as illustrated by the generalized restoration equation inthe lower portion of the window. Note that, when a filter type is selected, anyfixed values for that filter are displayed in the section directly below theRestoration Filters section. \n\r\n\r&nbsp;\n\r\n\rThere are two ways to specify the degradation function. Theyare as follows:\n\r\n\r&nbsp;\n\r Select     &#8216;Specify a function&#8217;\n\r Select     &#8216;Use Image&#8217;\n\r\n\r\n\rFor &#8216;Specify a function&#8217;, select or enter the mask height &amp;width, select blur shape, enter blur height &amp; width (which must be equal toor smaller than mask size), select blur method, and select or enter the weightfactor. For &#8216;Use Image&#8217; just select the image to be used from thepop-up menu.\n\r\n\rNote: A linear blur function can be created with &#8216;Utilities-&gt;Create-&gt;Circle&#8217;by specifying a radius of 0 and the desired point spread function (PSF).&nbsp; &nbsp; Inverse Filter:\n\r\n\rEnter or select the cutoff frequency, and a value to limit thegain of the restoration filter. Any frequencies above the cutoff will not beused in the restoration (set to zero), and any gain values higher than thelimit will be clipped to that maximum value. &nbsp; &nbsp; Geometric Mean:\n\r\n\rEnter or select the cutoff frequency, and a value to limit the gain of therestoration filter. Any frequencies above the cutoff will not be used in therestoration (set to zero), and any gain values higher than the limit will beclipped to that maximum value. \n\r\n\rSelect the noise image from the pop-up menu. The original image is selectedin a similar manner. Remember to reselect an image as the degraded image. \n\r\n\rEnter or select alpha and gamma. &nbsp; &nbsp; Power SpectrumEqualization:\n\r\n\rEnter or select the cutoff frequency, and a value to limit thegain of the restoration filter. Any frequencies above the cutoff will not beused in the restoration (set to zero), and any gain value higher than the limitwill be clipped to that maximum value. \n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select the noise image from the pop-up menu. The original image isselected in a similar manner. Remember to reselect an image as the degradedimage. &nbsp; &nbsp; Constrained Least Squares:\n\r\n\rEnter or select the cutoff frequency, and a value to limit thegain of the restoration filter. Any frequencies above the cutoff will not beused in the restoration (set to zero), and any gain values higher than thelimit will be clipped to that maximum value. \n\r\n\rEnter or select the value of gamma.&nbsp; &nbsp; Wiener:\n\r\n\rEnter or select the cutoff frequency, and a value to limit thegain of the restoration filter. Any frequencies above the cutoff will not beused in the restoration (set to zero), and any gain values higher than thelimit will be clipped to that maximum value. \n\r\n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select the noise image from the pop-up menu. The original image isselected in a similar manner. Remember to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reselect an imageas the degraded image. &nbsp; &nbsp; Practical Wiener:\n\r\n\rSelect or enter &#8216;K&#8217;. &nbsp; &nbsp; Parametric Wiener:\n\r\n\rEnter or select the cutoff frequency, and a value to limitthe gain of the restoration filter. Any frequencies above the cutoff will notbe used in the restoration (set to zero), and any gain values higher than thelimit will be clipped to that maximum value. \n\r\n\rSelect the noise image from the pop-up menu. The original image is selectedin a similar manner. Remember to reselect an image as the degraded image. \n\r\n\rEnter or select the value of gamma. &nbsp; &nbsp; NOTCH FILTER:\n\r\n\rThe notch filter performs a transform on thecurrent image and displays the spectrum for filtering. You may notch filter oneor more areas at one time. \n\r\n\rSelect the type of transform to be performed on the image from the&#8216;Transform Type&#8217; pop-up menu and as soon as the type is selectedthe transform is executed and we have a transformed image on the screen.\n\r\n\rWhen the transform image appears, you must set the row, column, and size ofthe notch for each desired area. This can be done either by selecting thepoints on the transformed image by simply left clicking on the image andpressing the &#8216;Add&#8217; button to add notch points one by one or byfollowing the steps given below in order: \n\r\n\r1) Set the row and column of the area&#8217;s center. \n\r\n\r2) Set the size of the area to notch. \n\r\n\r3) Press the &#8216;Add&#8217; button after you enter each value for therow, column and size.\n\r\n\r4) When you are done selecting all the desired areas, press the&#8216;Apply&#8217; button to do the notch filtering.&nbsp; \n\r\n\rIf you make a mistake entering coordinates or sizes, press&#8216;Redo&#8217; to cancel all the notch point selections and re-enter thecorrect information. \n\r\n\rPress the &#8216;Apply&#8217; button to filter the spectrum, perform aninverse transform on the notch filtered spectrum, and display the resultantimage. \n\r\n\rAfter the notch filtering has been performed, the operation can be repeatedon the same transform, but with different notch regions, by simply selectingthe new notch regions and then pressing &#8216;Apply&#8217;. You only need toselect a &#8216;Transform Type&#8217; again if you want a different transformor want to operate on a different image. ","Frequency filters","scr\\How To Use CVIPtools/Restoration/cvip_restore_freqfilter.html","   Iris Cheng  ACADEMIC COMPUTING  10  46  2003-10-20T16:38:00Z  2004-11-26T22:25:00Z  1  535  3050  Westar  25  7  3578  10.3501    Clean  Clean  MicrosoftInternetExplorer4      Restoration: Geometric Transforms\n\r\n\rHere you can restore an image that has been spatially(geometrically) distorted using the method of quadrilateral tiepoints.You can also perform the opposite, that is, image distortion or image warping. \n\r\n\rThe restoration or warping takes place by a using a mesh file which containsthe (r,c) coordinates pairsfor the irregular grid. \n\r\n\rNote that to restore an image that has been distorted with this method,simply reverse the direction, select the distorted image, and use the same meshfile. \n\r\n\rTo turn On/Off the mesh display, right click on the image and select the&#8216;Draw/Show Mesh&#8217; option by clicking the left mouse button asdesired.\n\r\n\rIn general, to perform the geometric transform: enter a mesh file name,select direction, select gray level interpolation method and press&#8216;Apply&#8217;. There are three methods for using/generating the meshfile, as follows. \n\r\n\rTo Create A New Mesh File:\n\rTo Use An Existing Mesh File:\n\rTo Create A Sine Mesh&nbsp; &nbsp; TO CREATE A NEW MESH FILE:\n\r\n\rSelect &#8216;Enter a new mesh file&#8217; radio button at topof the window. \n\r\n\rEnter or select the number of rows and columns of mesh points. \n\r\n\rNow enter the mesh points. For entering mesh points press the &#8216;Alt +&nbsp; click Leftmouse button&#8217; to select all mesh points one by one. For example: If youselect 3 rows and 3 columns, you have to enter 9 mesh points. The number ofmesh points left to enter is displayed in a text box. When all the mesh pointsare entered by the user the program prompts the user to press the&#8216;Apply&#8217; button and perform the operation.\n\r\n\rAs the points are being entered, the mesh will be displayed. To turn On/Offthe mesh display, right click on the image and select the &#8216;Draw/ShowMesh&#8217; option appropriately as desired. If the mesh is NOT acceptable,press the &#8216;Redo&#8217; button and enter a new mesh. You may either keepor change the mesh file name and number of rows and columns of mesh points. Youmust enter new mesh coordinates. \n\r\n\rAfter you have an acceptable mesh, select the direction of thetransformation and the gray value interpolation method. Press&#8216;Apply&#8217; to apply the mesh to the current image. \n\r\n\rTo save the mesh you just used, click the &#8216;Save Mesh&#8217; button. Asdefault, it will be saved in $CVIPtoolsHOME\\bin\\mesh directory.&nbsp; &nbsp; TO USE AN EXISTINGMESH FILE:\n\r\n\rSelect &#8216;Use an existing mesh file&#8217; radio button atthe top of the window. \n\r\n\rPress the &#8216;Select&#8217; button. This will take you to the list ofexisting mesh files in the &#8216;mesh&#8217; directory. Select one mesh filefrom the list of&nbsp; existing meshfiles.&nbsp; \n\r\n\rSelect the direction of the transformation and the gray value interpolationmethod. Press &#8216;Apply&#8217; to apply the mesh to the current image. &nbsp; &nbsp; TO CREATEA SINE MESH\n\r\n\rSelect &#8216;Create a sine mesh&#8217; radio button at thetop of the window. \n\r\n\rEnter a mesh file name. If the file name already exists, you will beprompted to change the name. \n\r\n\rEnter or select the number of rows or columns of mesh points. The samenumber will be used for both rows and columns. \n\r\n\rNote: for a 256 x 256 image, create a sine mesh of 16 x 16 or smaller. For a512 x 512 image, the maximum mesh size will be 32 x 32.\n\r\n\rPress the &#8216;Apply&#8217; button. A mesh will be created and displayed,and will be applied to the current image. \n\r\n\rThe mesh has its upper-left corner located at column 0, row 25. Itsapproximate dimensions will be 15*(number of rows) x 15*(number of columns). \n\r\n\rTo save the Sine mesh you just applied to the image, click the &#8216;SaveMesh&#8217; button. As default, it will be saved in $CVIPtoolsHOME\\bin\\mesh directory.\n\r\n\r&nbsp;","Geometric transforms","scr\\How To Use CVIPtools/Restoration/cvip_restore_geomtransform.html","   Iris Cheng  ACADEMIC COMPUTING  8  24  2003-10-20T16:40:00Z  2004-06-15T20:59:00Z  1  438  2502  Westar  20  5  2935  10.3501    Clean  Clean         MicrosoftInternetExplorer4      Restoration: Noise\n\r\n\rFor All Functions:\n\rNegative Exponential, Rayleigh:\n\rGaussian, Uniform:\n\rGamma:\n\rSalt and Pepper:&nbsp; &nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters, pressthe &#8216;Apply&#8217; button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed by clickingmouse button 1 on an image in the main window&#8217;s image queue. \n\r\n\rYou may choose to add the noise to the current image or you can create anall-black image with added noise by selecting from the options &#8216;Usecurrent image&#8217; and &#8216;Use black image&#8217;. If you use a blackimage, enter or select the height and width of the black image to be created frompop-up menus. To see what the noise distribution looks like, view the histogramof the noise added to a black image. \n\r\n\rNoise is often added to an image to test a restoration or enhancementalgorithm. Note that after the noise is added the signal-to-noise ratio (SNR)can be found by using Utilities-&gt;Compare. In this case you want to comparethe original with the noise added image. \n\r\n\rNote that the output images are always of FLOAT data type, but can beconverted to any data type with the Utilities-&gt;Convert-&gt;Data Type option.If this is done be aware that when converting to a lesser data type the data isremapped to the range of the new data type and some information may be lost. &nbsp; &nbsp; Negative Exponential,Rayleigh:\n\r\n\rNegative exponential noise is seen in imagesilluminated by a laser. Rayleigh noise is common inradar range and velocity images. To use, select or enter a variance value.Typical variance is from 100 to 400. &nbsp; &nbsp; Gaussian, Uniform:\n\r\n\rUnknown noise processes are often modeled asGaussian noise, since it is typical of noise that occurs in natural processes.Uniform noise also is a common type of noise in images. To use, select or entera variance value. Typical variance is 100 to 400. Select or enter a mean value.Mean values less than zero will darken the resultant image; those greater thanzero will brighten the result. &nbsp; &nbsp; Gamma:\n\r\n\rGamma noise results when an image withnegative exponential noise is lowpass filtered. Touse, select or enter a variance value. Typical variance is 100 to 400. Selector enter a value for &#8216;Alpha&#8217;. Values over 1.3 can be very slow toprocess. &nbsp; &nbsp; Salt and Pepper:\n\r\n\rSalt and pepper noise, also called specklenoise, is very distinctive and often results from faulty hardware or problemsin the image acquisition process. To use, select or enter desired values forthe probability of pepper (black spots) and salt (white spots) in the image.The probabilities must sum to 1.0 or less. For BYTE images this function uses 0and 255 for pepper and salt noise respectively. For images of non-BYTE data types,the function uses the minimum and maximum values in the image for the values ofpepper and salt.","Noise","scr\\How To Use CVIPtools/Restoration/cvip_restore_noise.html","   Iris Cheng  skefel  5  92  2010-01-06T19:26:00Z  2010-01-06T19:39:00Z  2  897  5117  Westar  42  12  6002  12.00    BestFit  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                                  Restoration: Spatial filters\n\r\n\rFor All Functions:\n\rOrder Filters:\n\rMedian, Minimum, Midpoint, Maximum:\n\rAlpha Trimmed mean:\n\rMean Filters:\n\rArithmetic, Geometric, Harmonic:\n\rContra-Harmonic, Yp:\n\rAdaptive Filters:\n\rMMSE:\n\r\n\rAdaptive Median:\n\rAdaptive contrast:\n\r\n\rKuwaharaFilter:\n\r\n\rAnisotropic Diffusion Filter:\n\r\n\rParametric Anisotropic Diffusion Filter:&nbsp; &nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters, press the ‘Apply’button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed by clickingmouse button 1 on an image in the main window’s image queue. &nbsp; &nbsp; ORDER FILTERS:\n\r\n\rOrder filters are based on sorting the pixel values in agiven window (mask) from smallest to largest, and selecting the output based onposition in this ordered set. This selected output value is then used toreplace the pixel value in the center of the window. &nbsp;&nbsp; Median, Adaptive Median, Minimum, Midpoint, Maximum:\n\r\n\rTo use, select or enter a mask (window) size. The midpoint is the average ofthe minimum and maximum, and the median is the central value. &nbsp; &nbsp; Alpha Trimmedmean:\n\r\n\rTo use, select or enter a mask size, then set the trim size.The trim number determines the number of endpoint values in the ordered setthat are excluded from the calculation. The filter operation can vary betweenan arithmetic mean and a median filter, depending on the value for the ‘Trimsize’. &nbsp; &nbsp; MEAN FILTERS:\n\r\n\rMean filters are often used to mitigate effects of Gaussianor Uniform noise. Mean filters replace a pixel’s value with some form of anaverage within a local window. &nbsp; &nbsp; Arithmetic,Geometric, Harmonic:\n\r\n\rThe geometric and harmonic are nonlinear filters and arebetter at retaining image detail than the arithmetic mean filter. To use,select or enter a mask size. &nbsp; &nbsp; Contra-Harmonic,Yp:\n\r\n\rThe contra-harmonic and Yp are nonlinear filters and arebetter at retaining image detail than the arithmetic mean filter. To use,select or enter a mask size, then set filter order. The order determines thetype of noise removed. \n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; ADAPTIVEFILTERS:&nbsp; &nbsp; MMSE:\n\r\n\rTo use, first select standard or improved mmse then selector enter ‘kernel size’ and ‘Noise variance’ for standard MMSE or select orenter ‘kernel size’, ‘Noise variance’ and ‘Threshold’ for improved MMSE. Thenoise variance should match the variance of any added noise. A larger kernelwill leave more visible artifacts at edges, but will remove more of the noisefrom areas that are primarily DC (constant). &nbsp; &nbsp;AdaptiveMedian: \n\r\n\r            Theadaptive median filter initially selects the median, but applies a moresophisticated algorithm to decide if the median selected is really the desiredvalue. The adaptive median works better with all    types of noise and is better at preservingthe original image than the median filter alone. \n\r\n\r&nbsp;\n\r\n\r            To use,select the ‘Max Window Size’ from the pop-up menu and press the ‘Apply’ buttonto the lower right. The window size starts from 3x3 and goes to 11x11(maximumwindow size).\n\r\n\r&nbsp;\n\r\n\r          The AdaptiveMedian algorithm: \n\r\n\r           Xmed = median valuein window \n\r          Xmin = minimum value in window \n\r          Xmax = maximum value in window \n\r          Xrc = current pixelvalue at (r,c) \n\r          (Level 1) T1 = Xmed - Xmin, T2 = Xmed - Xmax \n\r          (Level 2) U1 = Xrc - Xmin, U2 = Xrc- Xmax \n\r          Level 1: \n\r          If T1&gt;0 &amp; T2&lt;0, goto Level 2 \n\r          Else increase window size \n\r          Level 2: \n\r          If U1&gt;0 &amp; U2&lt;0, output = Xrc \n\r          Else output=Xmed           For more details see H. Hwang, R.A. Haddad,&quot;Adaptive Median Filters: New Algorithms and Results&quot;, IEEE Trans.Image Processing, Vol. 4, pp. 499-501, April 1995   Adaptivecontrast:\n\r\n\rEnter or select from pop-up menus the local gainfactor/min/max, local mean factor, and the kernel size. Based on the equation: &nbsp;&nbsp;                                       \n\r\n\rwhere,\n\r\n\rmI(r,c)= the mean for the entire imageI(r,c) \n\rsl = the localstandard deviation \n\rml = the localmean \n\rk1 = Local gain factor(multiplier), between 0 and 1 \n\rk2 = Local meanfactor (multiplier), between 0 and 1 \n\rkernel size = size of local window \n\rmin and max set limits on the gain from the local gain term KuwaharaFilter:\n\r\n\rKuwahara Filter is an Edge Preserving Filter. Enter orselect from pop-up menus the mask size.Anisotropic Diffusion Filter:\n\r\n\rAnisotropic Diffusion Filter is used to reduce image noisewhile preserving significant parts of the image such as edges, lines orborders. To use it, first select either standard or parametric versions of adfilter. Then for standard, select/enter iteration number, smoothing periteration and edge threshold. For parametric, select/enter iteration number,smoothing per iteration, edge threshold, and block size. Iteration numberspecifies how many times the image is going to be diffused. Higher number ofiterations will remove more of the noise but more detail will be lost as well.Smoothing per iteration specifies the strength of the diffusion process, inother words, how fast is the image going to be diffused. Edge thresholdspecifies the minimum strength of edges that will be preserved during thediffusion. Block size specifies the size of the kernel that is used tocalculate diffusion coefficient.  \n\r\n\r \n\r\n\r&nbsp;","Spatial filters","scr\\How To Use CVIPtools/Restoration/cvip_restore_spatfilter.html","   Iris Cheng  skefel  20  21  2003-10-20T17:18:00Z  2010-07-17T21:15:00Z  1  407  2323  Westar  19  5  2725  12.00    Clean  Clean  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                              Utilities: Arith/Logic\n\r\n\rFor All Functions:\n\rAdd, Subtract, Multiply, Divide:\n\rAND, OR, XOR:\n\rNOT:&nbsp;&nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters, pressthe &#8216;Apply&#8217; button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed by clickingmouse button 1 on an image in the main window&#8217;s image queue. \n\r\n\rIf the images are not the same size, the smaller image will be padded withzeros on the right and bottom and the images will be aligned with the upperleft corner. If another alignment is desired, crop the image first to align theupper left corners, or use &#8216;Analysis-&gt;Geometry-&gt;Paste&#8217; to inserta smaller image into a larger one at any arbitrary point. \n\r\n\rFor multi-band images, the operation is performed on a band-by-band basis. &nbsp; &nbsp; ADD, SUBTRACT, MULTIPLY, DIVIDE:\n\r\n\rThe arithmetic functions require two imageswith the same number of bands. The second image can be selected from the pop-upmenu or by pressing ALT key from the keyboard and clicking with the left-mousebutton. These functions all output images of type &#8216;FLOAT&#8217;. \n\r\n\rMultiply options:Multiplication can be done by using two images, or one image can be multipliedby a user specified constant. If multiplication by a constant is performed, theuser has two choices: with or without BYTE clipping. Without byte clippingresults in a floating point image of the actual multiplied numbers (it isremapped to BYTE for display). With byte clipping returns a BYTE image whereall numbers less than zero are clipped at zero, and numbers greater than 255are clipped at 255. \n\r\n\rNote: If you use multiply tocreate a filtered spectrum, be sure to put the spectral image first (as the\'Current image\'). This is necessary because the multiply operation retainshistory information from the \'Current image\', not from the \'Secondimage\'.&nbsp; The inverse transform needs the history information regarding thetransform.&nbsp; &nbsp; AND,OR, XOR:\n\r\n\rThese three logic functions require two imagesof any size, but the same number of bands. The second image can be selectedfrom the pop-up menu or by pressing ALT key from the keyboard and clicking withthe left-mouse button. These functions all output images of type&#8216;BYTE&#8217;. Any input image that is not of type &#8216;BYTE&#8217; willbe remapped to &#8216;BYTE&#8217; before performing the logic operation. &nbsp;&nbsp; NOT:\n\r\n\rThis logic function requires only one image,the current image. It is automatically selected, and can be changed by clickingmouse button 1 on an image in the main window&#8217;s image queue. Any inputimage that is not of type &#8216;BYTE&#8217; will be remapped to&#8216;BYTE&#8217; before performing the &#8216;NOT&#8217; operation. ","Arith/Logic","scr\\How To Use CVIPtools/Utilities/cvip_utilarithlogic.html","   Iris Cheng  skefel  15  28  2004-06-17T19:07:00Z  2010-07-17T21:17:00Z  1  302  1726  Westar  14  4  2024  12.00    120  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                              Utilities: Compare\n\r\n\rCompare two images:\n\r\n\rPratt Merit: \n\r&nbsp;\n\r\n\r&nbsp;Compare two images:\n\r\n\r&nbsp;It compares the current image with the secondimage by subtraction, logical XOR, peak signal-to-noise (SNR) ratio orroot-mean-square (RMS) error. \n\r\n\rFirst, select the method of comparison with mouse button 1. \n\r\n\rThe current image is automatically set, and can be changed by clickingmouse button 1 on an image in the main window&#8217;s image queue. The secondimage can be selected from the pop-up menu.\n\rAfter making your selections, press &#8216;Apply&#8217; to see the differenceor XOR image or to see the SNR or RMS error that pop-up in the form of amessage box.\n\r\n\r&nbsp;\n\r\n\rPratt Merit:\n\r\n\rThis function calculates the Pratt&#8217;s Figure of Merit ofthe image. The Pratt FOM, is definedas follows:\n\r\n\r                              \n\r\n\rIN= the maximum of II and IF\n\r\n\rII= the number of ideal edge points in the image\n\r\n\rIF =the number of edge points found by the edge detector\n\r\n\r&#945; = a scaling constant that can be adjusted to adjust thepenalty for offset edges\n\r\n\rdi = thedistance of a found edge point to, an ideal edge point\n\r\n\rFor this metric, F will be 1for a perfect edge. Normalizing to the maximum of the ideal and found edgepoints guarantees a penalty for smeared edges or missing edge points. Ingeneral, this metric assigns a better rating to smeared edges than to offset ormissing edges. This is done because techniques exist to thin smeared edges, butit is difficult to determine when an edge is missed. The distance, d, can be defined in more than one wayand typically depends on the connectivity definition used. To use, select theideal edge image and the edge detection image from the pop-up menu. Enter orselect the scale factor from the pop-up menu. The scaling factor is the scalingconstant that can be adjusted to adjust the penalty for offset edges. Press the&#8216;Apply&#8217; button to perform the operation. The Pratt&#8217;s Figureof Merit appears in the &#8216;Result&#8217; box. For multi-band (color)images, the Pratt FOM returns the average from all the bands. \n\r\n\r&nbsp;","Compare","scr\\How To Use CVIPtools/Utilities/cvip_utilcompare.html","   Iris Cheng  ACADEMIC COMPUTING  10  30  2003-10-20T17:20:00Z  2004-06-16T23:17:00Z  2  734  4185  Westar  34  9  4910  10.3501    Clean  Clean         MicrosoftInternetExplorer4      Utilities: Convert\n\r\n\rThis selection contains common functions thatwill convert one type of image into another. It includes conversions betweenbinary, gray and color images; data type conversion; color space conversion;gray code conversion; bit reduction (gray level quantization); and a labelingfunction. \n\r\n\r\n\r\n\rFor AllFunctions:\n\rBinary Threshold:\n\r\n\rData type:\n\rHalftone:\n\rGray Level Quantization:\n\rGray Code-natural binary:\n\rGray to color:\n\rColor to gray:\n\rColor space:\n\rLabel image:&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters, pressthe &#8216;Apply&#8217; button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed by clickingmouse button 1 on an image in the main window&#8217;s image queue. Thesefunctions all operate on a single image and output a single image. &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BinaryThreshold:\n\r\n\rTo use, set the desired threshold in the entrybox. You have the choice of thresholding &#8216;inBYTE&#8217; or &#8216;on original data&#8217;. If you select &#8216;in BYTE&#8217;,the value entered is mapped to the same relative point in input image datarange. For example, if you choose 255, the original image will be thresholded at the maximum value in the image; if youchoose 128 the image will be thresholded at(MAX-MIN)/2. This is useful when viewing a histogram, which always appears witha 0-255 scale for the column coordinates.\n\r\n\r&nbsp;\n\r\n\rData type:\n\r\n\r&nbsp;\n\r\n\rThis will allow you to convert one data type to another. Ithandles: FLOAT, INTEGER, SHORT, and BYTE. It comes in handy if a certainfunction insists on a specific data type. To use, select the desired data typewith mouse button 1. When changing from a higher to a lower data type, the datais linearly remapped to fit into the range of the new datatype.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Halftone\n\r\n\rThis quantizes a grayscale image to two levels(a binary image).Possible methods of quantization are: (1) Floyd Steinberg --Floyd - Steinberg error diffusion, (2) Dither -- Bayer&#8217;s ordered dither(3) Threshold -- simple thresholding, Thresholdparameter takes the value between 0 and 1 which is then multiplied by 255 and(4) Cluster3, Cluster4 and Cluster8 -- three different sizes of 45-degreeclustered-dot dither. Floyd-Steinberg will almost always give the best lookingresults. Gray Level Quantization:\n\r\n\rTo use, enter or select from pop-up menu thenumber of gray levels, which must be a power of 2. Select Standard or IGSquantization. IGS minimizes false contouring that can occur in areas thatappear to be uniform. \n\r\n\r&nbsp;\n\r\n\rGray Code-naturalbinary:\n\r\n\r&nbsp;\n\r\n\rTo use, select natural binary to gray code orgray to natural binary code. Often used as a preprocessing for run-lengthcoding.Gray to color:\n\r\n\rThis is a commonly used subset of what isavailable under &#8216;Enhancement-&gt;Pseudocolor&#8217;.To use, select the desired method of conversion.      \n\r\n\rFor Frequency domain mapping:         \n\r\n\r&nbsp;      \n\r\n\rPseudocolor conversion is  performed by transforming an image into the frequency domain with an FFT,  then assigning colors to bands defined by your inputs, and finally performing  an inverse FFT.   \n\r\n\rTo use, select the low and high cutoff frequencies; high must be greater  than low, and high should be less than the smaller of the image&#8217;s  number of rows or columns. Next, select the colors for each of the three  bands created by your selection of frequencies. Each color must be used once;  no two bands can have the same color.         \n\r\n\rFor Gray level mapping:         \n\r\n\r&nbsp;      \n\r\n\rTo use, select a shape for each band from its pop-up menu.  Note: more extensive gray to color options can be found in  &#8216;Enhancement-&gt;Pseudocolor&#8217;.    Color to gray:\n\r\n\rTo use, select the desired method with mousebutton 1. The luminance is a linear RGB transform based on the human visualsystem&#8217;s response; average is the simple mean of the R, G, and B values.&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Colorspace:\n\r\n\rIt requires a color image. To use, select thenew color space from the pop-up menu. Direction (forward), normalization, andremapping of values (off) are the defaults. The defaults can be changed. \n\r\n\rThe normalize function will modify image data so the maximum value equalsone. The remap function determines what image is placed into the image queue.If remap is selected, the image remapped to BYTE (as displayed) is put in thequeue; otherwise, the FLOAT output data is used. In general, to avoidinformation loss or if an inverse transform is desired later, be sure remap isoff. Note that the Chromaticity (XYZ) inverse is not defined.\n\r\n\rLabel image:\n\r\n\rThis function will label an input image byassigning connected components the same gray level. Note that any image pixelsthat are zero will be ignored, they will not belabeled or changed. This is done to allow the user to mask out portions of theimage to be ignored. ","Convert","scr\\How To Use CVIPtools/Utilities/cvip_utilconvert.html","   Iris Cheng  ACADEMIC COMPUTING  6  41  2003-10-20T17:22:00Z  2004-10-12T23:39:00Z  1  837  4776  Westar  39  11  5602  10.3501    Clean  Clean  MicrosoftInternetExplorer4      Utilities: Create\n\r\n\rThese utilities allow you to create simpleimages: geometric shapes and sinusoids. They also allow you to add noise to animage, or to create a noise only image. With the &#8216;Extract Band&#8217; and&#8216;Assemble Bands&#8217; functions you can put together color images fromsingle band images. \n\r\n\rWhen used in conjunction with the arithmetic/logic operations, images can becreated that are useful for many experimental applications. Note that an imagewith a point in it can be created by creating a circle with radius of zero -this is useful for generating point spread function (PSF) images when used withthe &#8216;Filter&#8217; options (to convolve the point with a specific filtermask). \n\r\n\r\n\r\n\rFor AllFunctions:\n\rCheckerboard:\n\rCircle:\n\rEllipse:\n\rLine:\n\rRectangle:\n\rCosine, Sine and Square wave:\n\rExtract Band:\n\rAssemble Bands:\n\rBlack image:\n\rAdd noise:\n\rBorder Mask:\n\rBorder Image:&nbsp; &nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters, pressthe &#8216;Apply&#8217; button at lower right to perform the operation. &nbsp; &nbsp; Checkerboard:\n\r\n\rAll of the numeric parameters can be selectedfrom the pop-up menus, or you enter them directly from your keyboard. \n\r\n\rThe image height and width are the overall image dimensions. The startingrow and column define the upper-left corner of a white cell.&nbsp; &nbsp; Circle:\n\r\n\rIt creates a white circle on a blackbackground. \n\r\n\rAll of the numeric parameters can be selected from the pop-up menus, or youcan type in new values. \n\r\n\rThe image height and width are the overall image dimensions. Select thecenter and radius of the circle. Note that a radius of zero actually creates animage with a single point in it. \n\r\n\rIt the &#8216;Blur radius&#8217; is selected then a linear blur of radius enteredor selected from the pop-up menu is created around the circle. Select a blur radiusgreater than the circle radius or else it will not show any effect on theimage. &nbsp;&nbsp; Ellipse\n\r\n\rIt creates a white ellipse on a blackbackground. \n\r\n\rAll of the numeric parameters can be selected from the pop-up menus, or youcan type in new values. \n\r\n\rThe image height and width are the overall image dimensions. Select thecenter, horizontal and vertical length for the ellipse. &nbsp; &nbsp; Line:\n\r\n\rIt creates a white one-pixel wide line on ablack background (if you want a wider line use&#8216;Create-&gt;Rectangle&#8217;). \n\r\n\rAll of the numeric parameters can be selected from the pop-up menus, or youenter them directly from your keyboard. \n\r\n\rThe image height and width are the overall image dimensions. Select thestarting and ending coordinates for the line. &nbsp; &nbsp; Rectangle:\n\r\n\rIt creates a white rectangle on a blackbackground. \n\r\n\rAll of the numeric parameters can be selected from the pop-up menus, or youenter them directly from your keyboard. \n\r\n\rThe image height and width are the overall image dimensions. The startingcoordinates are the upper- left corner of the rectangle; the &#8216;To&#8217;coordinates define the height (To Row:) and width (ToCol:) of the rectangle. &nbsp; &nbsp; Cosine, Sine andSquare wave:\n\r\n\rIt creates a BYTE image of the selectedfunction. \n\r\n\rThe image height, width, frequency, and direction can be selected. &nbsp; &nbsp; Extract Band:\n\r\n\rIt creates a grayscale image from one band ofa multi-band image. \n\r\n\rTo use, select the band to extract with mouse button 1. &nbsp; &nbsp; Assemble Bands:\n\r\n\rIt creates a multi-band image from threegrayscale images of the same size. \n\r\n\rSelect the source image for a color band&nbsp; from the pop-up menu.&nbsp; &nbsp; Black image:\n\r\n\rEnter or select from pop-up menus the imageheight and width. &nbsp; &nbsp; Add noise:\n\r\n\rYou may choose to add the noise to the current image or youcan create a noise-only image (&#8216;Use black image&#8217;) by selecting theappropriate option. If you use a black image, enter or select from pop-upmenus, the height and width of the black image to be created. To see what thenoise distribution looks like, view the histogram of the noise added to a blackimage. \n\r\n\rThe output images are always of &#8216;FLOAT&#8217; data type, but can beconverted to any data type with the &#8216;Utilities-&gt;Convert-&gt;DataType&#8217; option. Negativeexponential, Rayleigh: Select or enter a variancevalue. Typical variance is from 100 to 400. \n\r\n\rGaussian, Uniform: Selector enter a variance value. Typical variance is 100 to 400. Select or enter amean value. Mean values less than zero will darken the resultant image; thosegreater than zero will brighten the result. Gamma:Select or enter a variance value. Typical variance is 100 to 400. Select orenter a value for alpha. Values over 1.3 can be very slow to process. Saltand Pepper: Select or enter desired values for the probability of pepper (blackspots) and salt (white spots) in the image. The probabilities must sum to 1.0or less. For &#8216;BYTE&#8217; images this function uses 0 and 255 for pepperand salt. For images of non-BYTE data types, the function uses the minimum andmaximum values in the image for the values of pepper and salt. &nbsp; &nbsp; Border Mask\n\r\n\rThis function returns a binary image of the border selectedusing the &#8216;Ctrl + left mouse button&#8217; on the image. The border areais filled with white color on a black background. Note that &#8216;BorderMask&#8217; does not work for images stretched with the viewer.&nbsp; &nbsp; Border Image\n\r\n\rThis function creates an image with the border. The border isselected using the &#8216;Ctrl + left mouse button&#8217; on the image. Notethat &#8216;Border Image&#8217; does not work for images stretched with theviewer.","Create","scr\\How To Use CVIPtools/Utilities/cvip_utilcreate.html","   Iris Cheng  ACADEMIC COMPUTING  5  15  2003-10-20T17:24:00Z  2004-06-17T00:09:00Z  2  519  2960  Westar  24  6  3473  10.3501    Clean  Clean         MicrosoftInternetExplorer4      Utilities: Enhance\n\r\n\rThis is a commonly used subset of what isavailable under the &#8216;Enhancement&#8217; window. They are useful if youwant to enhance an image quickly, without the need to bring up another window orset parameters. For more selections, and more control over the parameters, seethe &#8216;Enhancement&#8217; window. \n\r\n\r\n\r\n\rFor AllFunctions:\n\rBrighten/Darken:\n\rEdge Enhancement:\n\rHistogram Equalization:\n\rHistogram Stretch\n\rPseudocolor:\n\rFrequency domain mapping:\n\rGray level mapping:\n\rSharpening:&nbsp; &nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters, pressthe &#8216;Apply&#8217; button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed by clickingmouse button 1 on an image in the main window&#8217;s image queue. &nbsp; &nbsp; Brighten/Darken:\n\r\n\rYou can select the factor from the pop-upmenu, or you can type in a new value. Numbers greater than 1 will brighten theimage, those less than 1 will darken. Note that the image is first remapped toBYTE, then multiplied and clipped to a maximum value of 255. \n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Edge Enhancement:\n\r\n\rChoose the method of enhancement. If yourchoice is high frequency emphasis, also choose a transform method from thepop-up menu. The FFT and DCT sharpening methods will add the result to theoriginal image automatically. &nbsp; &nbsp; Histogram Equalization:\n\r\n\rFor gray-scale images, no parameters areneeded. \n\r\n\rFor color images, select the band to use as a basis for equalization.Selection of &#8216;Value&#8217; will result in the image being transformed tothe HSL colorspace, equalization of the brightness(Lightness), and inverse transform to an RGB image. Note that this can also bedone (for display only, the output will not be put in the image queue) with the&#8216;e&#8217; option. &nbsp; &nbsp; Histogram Stretch\n\r\n\rTo use, specify the gray level limits for thestretch operation, and, if desired, clipping percentage at the ends. It may benecessary to clip a small percentage at the ends to achieve good results. &nbsp; &nbsp; Pseudocolor:&nbsp; &nbsp; Frequencydomain mapping:\n\r\n\rTo use, select or enter low and high cutofffrequencies, then select a color for the low-pass, band-pass, and high-passbands. Each band must be a different color (R, G, or B). \n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Gray level mapping:\n\r\n\rTo use, select a shape for each band from itspop-up menu. Note: more extensive gray to color options can be found in&#8216;Enhancement-&gt;Pseudocolor&#8217;. &nbsp; &nbsp; Sharpening:\n\r\n\rThis algorithm works as follows: 1) performs aLaplacian edge detection on the original image, 2)performs a Sobel edge detection on the original image,3) multiplies result from Laplacian and Sobel, 4) adds the product from step 3 to the originalimage, 5) histogram stretches the result from step 4. \n\r\n\rWith the &#8216;Intermediate image remapping&#8217; option you can remap theproduct (from step 3) to BYTE range (0-255) before you add it to the originalimage. This has the effect of improving image contrast, but with reducedsharpening effect. Three different Laplacian maskscan be selected, but Mask II tends to give more raggedy edges. Choosing alarger mask size for the Sobel will tend to brightenthe major edges, but will also tend to smear them out slightly. The final twoselections, &#8216;Low/High clip percent&#8217;, determine how much of thehistogram is clipped during the final histogram stretch. ","Enhance","scr\\How To Use CVIPtools/Utilities/cvip_utilenhance.html","   Iris Cheng  skefel  2  41  2010-07-17T20:09:00Z  2010-07-17T20:09:00Z  1  599  3415  Westar  28  8  4006  12.00    false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                              Utilities: Filter\n\r\n\rAll the functions but the median areimplemented with spatial convolution masks. The median is ofcourse awindow-based order filter. Although both the mean and Gaussian filtering can beperformed with either &#8216;Specify a Filter&#8217;, or &#8216;Specify aBlur&#8217;, they are also included as stand alone selections since they arecommonly used. \n\r\n\r\n\r\n\rFor AllFunctions:\n\rMean:\n\rMedian:\n\r\n\rLaplacian Filter:\n\r\n\rDifference Filter:\n\rSpecify a Filter:\n\rSpecify a Blur: &nbsp; &nbsp; FORALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters, pressthe &#8216;Apply&#8217; button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed by clickingmouse button 1 on an image in the main window&#8217;s image queue. &nbsp;&nbsp; Mean:\n\r\n\rYou can select the mask size from the pop-upmenu. This performs an arithmetic mean, or average, spatial filter. \n\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Median:\n\r\n\rYou can select a standard median filter or anadaptive median filter. The standard median filter sorts the values in thewindow (defined by mask size), and replaces the center value with the middlevalue from the sorted array. The adaptive filter also sorts them and initiallyselects the median, but applies a more sophisticated algorithm to decide if themedian selected is really the desired value. The adaptive median works betterwith all types of noise and is better at preserving the original image than themedian filter alone. You can select the mask size from the pop-up menu or youcan type in a new value. The value should be odd, 3 or greater. &nbsp;&nbsp; Laplacian Filter:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To use the Laplacian Filter, select one of the three Laplacian filtermasks. When you select any of the masks, the coefficients of that mask appearin a message box. These values can be changed. If &#8220;Keep the OriginalImage&#8221; option is selected, the original image is retained in the outputimage. This will increase the value of the center coefficient by 1.&nbsp; After changing the default values press&#8216;OK&#8217; button on the message box to get the filtered image. Press the&#8216;Cancel&#8217; button to quit the message box.&nbsp;&nbsp;&nbsp; DifferenceFilter:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To use, select the size of thefilter. As you select the size a message box pops up containing all the filtercoefficients. The coefficients of this difference filter can be adjusted usingthe arrow buttonsprovided in the message box. If &#8220;Keep theOriginal Image&#8221; option is selected, the original image is retained in theoutput image. This will increase the value of the center coefficient by 1.After selecting the mask coefficients, press the &#8216;OK&#8217; button on themessage box to get the filtered image. Press the &#8216;Cancel&#8217; button toquit the message box.&nbsp;&nbsp;&nbsp; Specify a Filter:\n\r\n\rFirst, select a low-pass, high-pass spatial,center-weighted constant, or Gaussian spatial filter type from the pop-up menu.Next, select the desired filter size. Select the mask and press&#8216;Apply&#8217; button.&nbsp;&nbsp; Specify a Blur:\n\r\n\rThis window was created to correspond with the&#8216;Restoration-&gt;Frequency filters&#8217; subwindow that allows you tospecify a degradation function. Thus it can readily be used to create blurredimages for testing these restoration filters. The mask height and width specifythe size of the mask that will be convolved with the selected image, while theheight and width of the blur shape specify the size of the non-zerocoefficients in this mask. The blur shape controls the shape of the non-zerocoefficients, the blur method controls the relative weighting of the terms andthe weight parameter controls the overall magnitude of the terms in the mask. \n\r\n\rIf you want to create a special mask, or simply view the one you have selected,click on the &#8216;Edit mask&#8217; button. Now you can edit thesecoefficients from the keyboard, and press &#8216;Apply&#8217; to apply theedited mask to the current image. \n\r\n\r&nbsp; &nbsp; ","Filter","scr\\How To Use CVIPtools/Utilities/cvip_utilfilter.html","   Iris Cheng  ACADEMIC COMPUTING  12  19  2003-10-20T17:33:00Z  2006-02-06T06:16:00Z  1  348  1986  Westar  16  4  2330  10.3501    Clean  Clean  MicrosoftInternetExplorer4      Utilities: Size\n\r\n\rHere are commonly used image size functions,for more see the &#8216;Analysis-&gt; Geometry&#8217; window. \n\r\n\r\n\rFor AllFunctions:\n\rCrop:\n\r\n\rDouble Size:\n\rResize:\n\rSpatial Quant:&nbsp; &nbsp; FOR ALL FUNCTIONS:\n\r\n\rAfter setting the desired parameters, pressthe &#8216;Apply&#8217; button at lower right to perform the operation. \n\r\n\rThe current image is automatically selected, and can be changed by clickingmouse button 1 on an image in the main window&#8217;s image queue. &nbsp; &nbsp; Crop:\n\r\n\rThis will allow you to copy a portion (subimage) of an image and create a new image containing thesubimage. To use, enter the desired values into theentry boxes for the upper left corner and the height and width of the desired subimage. \n\r\n\rTo crop the region press &#8216;Shift + mouse button 1&#8217; and drag tocreate a rectangular region of interest. The selection of the crop region canbe made using any one of the above given methods. Once, the parameters are setas desired, press &#8216;Apply&#8217; in the lower right corner. &nbsp;&nbsp;&nbsp; Double Size:\n\r\n\rThis will allow youto double the size of an image. It is faster than linear interpolation by afactor of approximately 3 to 7, depending upon image size and type. Thisfunction is an implementation of the algorithm in &#8220;S. Battiato, G. Gallo, F. Stanco,A locally adaptive zooming algorithm for digital images, Image and VisionComputing 20 (2002) 805 &#8211; 812&#8221;. &nbsp;&nbsp;&nbsp; Resize:\n\r\n\rThis will allow you to shrink or enlarge animage with two different interpolation methods. To use, enter or select frompop-up menus the desired new dimensions in the width and height boxes. Thenselect the interpolation method desired. Linear interpolation will provide thesmoothest looking results. &nbsp; &nbsp; Spatial Quant:\n\r\n\rThis will allow you to reduce an image(shrink) only. To use, enter or select from pop-up menus the new height andwidth, and select a method from the pop-up menu. These methods determine howthe resulting pixel value will be derived from the corresponding (larger)neighborhood in the original image. The average value is similar to linearinterpolation, the median sorts the gray levels by magnitude and then selectsthe center value, and the decimation selection simply eliminates rows andcolumns (similar to zero-order hold). \n\r\n\r&nbsp;","Size","scr\\How To Use CVIPtools/Utilities/cvip_utilsize.html","   ACADEMIC COMPUTING  ACADEMIC COMPUTING  8  18  2004-06-17T18:50:00Z  2004-06-25T22:50:00Z  1  103  589  SIUE  4  1  691  10.3501    Clean  Clean                  MicrosoftInternetExplorer4           Utilities: StatsImage Data Range: \n\rImage Statistics:Image Data Range:\n\r\n\rThis will provide you with completeinformation about the data range(s), maximums and minimums, for an image in theimage queue. This includes multi-band and complex images. Image Statistics:\n\r\n\rThis will provide you with the mean, standarddeviation, skew, energy, and entropy for each band in the image. The functiondoes not include pixel values of zero in the calculations; this is so that youcan find gray level statistics on specific objects in an image by masking outthe rest of the image with zeros (and most real images do not have actual pixelvalues of zero).\n\r\n\r&nbsp;","Stats","scr\\How To Use CVIPtools/Utilities/cvip_utilstats.htm","   ACADEMIC COMPUTING  jhansi  13  23  2004-06-18T21:28:00Z  2009-11-20T06:16:00Z  1  317  1809  SIUE  15  4  2122  12.00    140  false      false  false  false    EN-US  X-NONE  X-NONE                                       MicrosoftInternetExplorer4                                                                                                                                                                                                                                                                                                                                 \n\r\n\rToolbar:\n\r\n\r&nbsp;\n\r\n\rSelecting this option from the ‘View-&gt;Toolbar’ on themenu bar causes the toolbar to appear on the screen right below the menu bar.Deselecting this option will cause the toolbar to disappear from the screen. \n\r\n\r&nbsp;\n\r\n\r&nbsp;\n\r\n\rImage Queue:\n\r\n\r&nbsp;\n\r\n\rSelecting this option from the ‘View-&gt;Image Queue’ on themenu bar causes the image queue, ‘Delete’, ‘Delete all’ and ‘Lock Input’options to appear on the left of the screen right below the menu bar.Deselecting this option will cause the image queue, ‘Delete’, ‘Delete all’ and‘Lock Input’ options to disappear from the left of the screen. \n\r\n\r&nbsp;\n\r\n\r&nbsp;\n\r\n\rCVIP FunctionInformation:\n\r\n\r&nbsp;\n\r\n\rSelecting this option from the ‘View-&gt; CVIP Function Information’ on the menubar causes the function information section to appear at the very bottom of thescreen. Deselecting this option will cause the function information todisappear from the bottom of the screen. \n\r\n\r&nbsp;\n\r\n\r&nbsp;\n\r\n\rStatus Bar:\n\r\n\r&nbsp;\n\r\n\rSelecting this option from the ‘View-&gt; Status Bar’ on the menu bar causes the status bar section to appear at thebottom of the screen. Deselecting this option will cause the status bar todisappear from the bottom of the screen. The ‘Status Bar’ holds informationabout the ‘Name’, ‘Color format’, ‘Image Format’, ‘Data Format’, ‘Data Type’,‘Data Range’, ‘Number of Bands’, ‘Number of Rows’ and ‘Number of Columns’ ofthe presently selected image in the image queue.\n\r\n\r&nbsp;\n\r\n\r&nbsp;\n\r\n\rShow Histogram:\n\r\n\r&nbsp;\n\r\n\rSelecting this option helps viewing the histogram of thepresently selected image in the image queue. To use, select ‘View-&gt;Show Histogram’option from the menu bar on top.\n\r\n\r&nbsp;\n\r\n\r&nbsp;\n\r\n\rShow Spectrum:\n\r\n\r&nbsp;\n\r\n\rThis option enables you to view the ‘FFT Phase’, ‘Magnitude’or the ‘Log-remapped’ Spectrums of the selected image in the image queue. Touse, select one of the choices from the ‘View-&gt;Show Spectrum’ option fromthe menu bar on top.\n\r\n\r&nbsp;\n\r\n\r&nbsp;\n\r\n\rView Band:\n\r\n\r&nbsp;\n\r\n\rThis option enables the user to view any one of the three‘Red’, ‘Green’ or ‘Blue’ bands of the selected image from the image queue. Touse, select ‘View-&gt;View Band’ option and choice of band you want to viewfrom the menu bar on top. This feature can also be from the Toolbar just belowthe menu bar.\n\r\n\r&nbsp;\n\r\n\r&nbsp;","View","scr\\How To Use CVIPtools/View/view.htm");